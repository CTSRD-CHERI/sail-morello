/******************************************************************************/
/*  BSD 3-clause Clear License                                                */
/*                                                                            */
/*  Copyright (c) 2022                                                        */
/*    Arm Limited (or its affiliates),                                        */
/*    Thomas Bauereiss,                                                       */
/*    Brian Campbell,                                                         */
/*    Alasdair Armstrong,                                                     */
/*    Alastair Reid,                                                          */
/*    Peter Sewell                                                            */
/*                                                                            */
/*  All rights reserved.                                                      */
/*                                                                            */
/*  Redistribution and use in source and binary forms, with or without        */
/*  modification, are permitted (subject to the limitations in the            */
/*  disclaimer below) provided that the following conditions are met:         */
/*                                                                            */
/*    * Redistributions of source code must retain the above copyright        */
/*      notice, this list of conditions and the following disclaimer.         */
/*    * Redistributions in binary form must reproduce the above copyright     */
/*      notice, this list of conditions and the following disclaimer in the   */
/*      documentation and/or other materials provided with the distribution.  */
/*    * Neither the name of ARM Limited nor the names of its contributors     */
/*      may be used to endorse or promote products derived from this          */
/*      software without specific prior written permission.                   */
/*                                                                            */
/*  NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED   */
/*  BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND   */
/*  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    */
/*  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND         */
/*  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE   */
/*  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,      */
/*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  */
/*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF      */
/*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON    */
/*  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  */
/*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.         */
/******************************************************************************/

type Capability = bits(129)

register PCC : bits(129)

register CNTHPS_CTL_EL2 : bits(32)

register CNTHPS_CVAL_EL2 : bits(64)

register CNTHPS_TVAL_EL2 : bits(32)

register CNTHVS_CTL_EL2 : bits(32)

register CNTHVS_CVAL_EL2 : bits(64)

register CNTHVS_TVAL_EL2 : bits(32)

let EL1 : bits(2) = 0b01

let EL2 : bits(2) = 0b10

let EL3 : bits(2) = 0b11

val HaveEL : bits(2) -> bool

register SCR_EL3 : bits(32)

val EL2Enabled : unit -> bool effect {rreg}

function EL2Enabled () = {
    return(HaveEL(EL2) & (not_bool(HaveEL(EL3)) | Slice(SCR_EL3, 0, 1) == 0b1))
}

val FIQPending : unit -> bool

register HCR_EL2 : bits(64)

val IRQPending : unit -> bool

val IsPhysicalSErrorPending : unit -> bool

struct ProcState = {
  N : bits(1),
  Z : bits(1),
  C : bits(1),
  V : bits(1),
  D : bits(1),
  A : bits(1),
  I : bits(1),
  F : bits(1),
  PAN : bits(1),
  UAO : bits(1),
  DIT : bits(1),
  TCO : bits(1),
  C64 : bits(1),
  SS : bits(1),
  IL : bits(1),
  EL : bits(2),
  nRW : bits(1),
  SP : bits(1),
  Q : bits(1),
  GE : bits(4),
  SSBS : bits(1),
  IT : bits(8),
  J : bits(1),
  T : bits(1),
  E : bits(1),
  M : bits(5)
}

register PSTATE : ProcState

val getISR : unit -> bits(32) effect {rreg}

function getISR () = {
    value_name : bits(32) = Zeros();
    value_name[8] = Bit(if IsPhysicalSErrorPending() then 0b1 else 0b0);
    value_name[7] = Bit(if IRQPending() then 0b1 else 0b0);
    value_name[6] = Bit(if FIQPending() then 0b1 else 0b0);
    if (PSTATE.EL == EL1 & EL2Enabled()) & Slice(HCR_EL2, 27, 1) == 0b0 then {
        if Slice(HCR_EL2, 5, 1) == 0b1 then {
            value_name[8] = Bit([value_name[8]] | Slice(HCR_EL2, 8, 1))
        } else ();
        if Slice(HCR_EL2, 4, 1) == 0b1 then {
            value_name[7] = Bit(Slice(HCR_EL2, 7, 1))
        } else ();
        if Slice(HCR_EL2, 3, 1) == 0b1 then {
            value_name[6] = Bit(Slice(HCR_EL2, 6, 1))
        } else ()
    } else ();
    return(value_name)
}

val AArch32_CurrentCond : unit -> bits(4)

val ConditionHolds : bits(4) -> bool effect {rreg, undef}

function ConditionHolds cond = {
    result : bool = undefined;
    match cond[3 .. 1] {
      0b000 => {
          result = PSTATE.Z == 0b1
      },
      0b001 => {
          result = PSTATE.C == 0b1
      },
      0b010 => {
          result = PSTATE.N == 0b1
      },
      0b011 => {
          result = PSTATE.V == 0b1
      },
      0b100 => {
          result = PSTATE.C == 0b1 & PSTATE.Z == 0b0
      },
      0b101 => {
          result = PSTATE.N == PSTATE.V
      },
      0b110 => {
          result = PSTATE.N == PSTATE.V & PSTATE.Z == 0b0
      },
      0b111 => {
          result = true
      }
    };
    if [cond[0]] == 0b1 & cond != 0b1111 then {
        result = not_bool(result)
    } else ();
    return(result)
}

enum Constraint = {
  Constraint_NONE,
  Constraint_UNKNOWN,
  Constraint_UNDEF,
  Constraint_UNDEFEL0,
  Constraint_NOP,
  Constraint_TRUE,
  Constraint_FALSE,
  Constraint_DISABLED,
  Constraint_UNCOND,
  Constraint_COND,
  Constraint_ADDITIONAL_DECODE,
  Constraint_WBSUPPRESS,
  Constraint_FAULT,
  Constraint_FORCE,
  Constraint_FORCENOSLCHECK
}

enum Unpredictable = {
  Unpredictable_WBOVERLAPLD,
  Unpredictable_WBOVERLAPST,
  Unpredictable_LDPOVERLAP,
  Unpredictable_BASEOVERLAP,
  Unpredictable_DATAOVERLAP,
  Unpredictable_DEVPAGE2,
  Unpredictable_INSTRDEVICE,
  Unpredictable_RESCPACR,
  Unpredictable_RESMAIR,
  Unpredictable_RESTEXCB,
  Unpredictable_RESPRRR,
  Unpredictable_RESDACR,
  Unpredictable_RESVTCRS,
  Unpredictable_RESTnSZ,
  Unpredictable_LARGEIPA,
  Unpredictable_ESRCONDPASS,
  Unpredictable_ILZEROIT,
  Unpredictable_ILZEROT,
  Unpredictable_BPVECTORCATCHPRI,
  Unpredictable_VCMATCHHALF,
  Unpredictable_VCMATCHDAPA,
  Unpredictable_WPMASKANDBAS,
  Unpredictable_WPBASCONTIGUOUS,
  Unpredictable_RESWPMASK,
  Unpredictable_WPMASKEDBITS,
  Unpredictable_RESBPWPCTRL,
  Unpredictable_BPNOTIMPL,
  Unpredictable_RESBPTYPE,
  Unpredictable_BPNOTCTXCMP,
  Unpredictable_BPMATCHHALF,
  Unpredictable_BPMISMATCHHALF,
  Unpredictable_RESTARTALIGNPC,
  Unpredictable_RESTARTZEROUPPERPC,
  Unpredictable_ZEROUPPER,
  Unpredictable_ERETZEROUPPERPC,
  Unpredictable_A32FORCEALIGNPC,
  Unpredictable_SMD,
  Unpredictable_AFUPDATE,
  Unpredictable_IESBinDebug,
  Unpredictable_BADPMSFCR,
  Unpredictable_LINKTRANSFEROVERLAPLD,
  Unpredictable_LINKBASEOVERLAPLD,
  Unpredictable_CLEARERRITEZERO
}

register configuration __unpred_tsize_aborts : bool = true

val ConstrainUnpredictable : Unpredictable -> Constraint effect {undef}

function ConstrainUnpredictable which = {
    match which {
      Unpredictable_WBOVERLAPLD => {
          return(Constraint_WBSUPPRESS)
      },
      Unpredictable_WBOVERLAPST => {
          return(Constraint_NONE)
      },
      Unpredictable_LDPOVERLAP => {
          return(Constraint_UNDEF)
      },
      Unpredictable_BASEOVERLAP => {
          return(Constraint_NONE)
      },
      Unpredictable_DATAOVERLAP => {
          return(Constraint_NONE)
      },
      Unpredictable_DEVPAGE2 => {
          return(Constraint_FAULT)
      },
      Unpredictable_INSTRDEVICE => {
          return(Constraint_NONE)
      },
      Unpredictable_RESCPACR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESMAIR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESTEXCB => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESDACR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESPRRR => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESVTCRS => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_RESTnSZ => {
          return(Constraint_FORCE)
      },
      Unpredictable_LARGEIPA => {
          if __unpred_tsize_aborts then {
              return(Constraint_FAULT)
          } else {
              return(Constraint_FORCE)
          }
      },
      Unpredictable_ESRCONDPASS => {
          return(Constraint_FALSE)
      },
      Unpredictable_ILZEROIT => {
          return(Constraint_FALSE)
      },
      Unpredictable_ILZEROT => {
          return(Constraint_FALSE)
      },
      Unpredictable_BPVECTORCATCHPRI => {
          return(Constraint_TRUE)
      },
      Unpredictable_VCMATCHHALF => {
          return(Constraint_FALSE)
      },
      Unpredictable_VCMATCHDAPA => {
          return(Constraint_FALSE)
      },
      Unpredictable_WPMASKANDBAS => {
          return(Constraint_FALSE)
      },
      Unpredictable_WPBASCONTIGUOUS => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESWPMASK => {
          return(Constraint_DISABLED)
      },
      Unpredictable_WPMASKEDBITS => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESBPWPCTRL => {
          return(Constraint_DISABLED)
      },
      Unpredictable_BPNOTIMPL => {
          return(Constraint_DISABLED)
      },
      Unpredictable_RESBPTYPE => {
          return(Constraint_DISABLED)
      },
      Unpredictable_BPNOTCTXCMP => {
          return(Constraint_DISABLED)
      },
      Unpredictable_BPMATCHHALF => {
          return(Constraint_FALSE)
      },
      Unpredictable_BPMISMATCHHALF => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESTARTALIGNPC => {
          return(Constraint_FALSE)
      },
      Unpredictable_RESTARTZEROUPPERPC => {
          return(Constraint_TRUE)
      },
      Unpredictable_ZEROUPPER => {
          return(Constraint_TRUE)
      },
      Unpredictable_ERETZEROUPPERPC => {
          return(Constraint_TRUE)
      },
      Unpredictable_A32FORCEALIGNPC => {
          return(Constraint_FALSE)
      },
      Unpredictable_SMD => {
          return(Constraint_UNDEF)
      },
      Unpredictable_AFUPDATE => {
          return(Constraint_TRUE)
      },
      Unpredictable_IESBinDebug => {
          return(Constraint_TRUE)
      },
      Unpredictable_BADPMSFCR => {
          return(Constraint_TRUE)
      },
      Unpredictable_CLEARERRITEZERO => {
          return(Constraint_FALSE)
      },
      Unpredictable_LINKTRANSFEROVERLAPLD => {
          return(Constraint_UNKNOWN)
      },
      Unpredictable_LINKBASEOVERLAPLD => {
          return(Constraint_UNKNOWN)
      },
      _ => {
          return(undefined : Constraint)
      }
    }
}

val ConstrainUnpredictableBool : Unpredictable -> bool effect {escape, undef}

function ConstrainUnpredictableBool which = {
    let c : Constraint = ConstrainUnpredictable(which);
    assert(c == Constraint_TRUE | c == Constraint_FALSE);
    return(c == Constraint_TRUE)
}

val HaveAnyAArch32 : unit -> bool

val HighestELUsingAArch32 : unit -> bool

val UsingAArch32 : unit -> bool effect {escape, rreg}

function UsingAArch32 () = {
    let aarch32 : bool = PSTATE.nRW == 0b1;
    if not_bool(HaveAnyAArch32()) then {
        assert(not_bool(aarch32))
    } else ();
    if HighestELUsingAArch32() then {
        assert(aarch32)
    } else ();
    return(aarch32)
}

val ConditionSyndrome : unit -> bits(5) effect {escape, rreg, undef}

function ConditionSyndrome () = {
    cond : bits(4) = undefined;
    syndrome : bits(5) = undefined;
    if UsingAArch32() then {
        let cond : bits(4) = AArch32_CurrentCond();
        if PSTATE.T == 0b0 then {
            syndrome[4] = Bit(0b1);
            if ConditionHolds(cond) & ConstrainUnpredictableBool(Unpredictable_ESRCONDPASS) then {
                syndrome[3 .. 0] = 0b1110
            } else {
                syndrome[3 .. 0] = cond
            }
        } else {
            if __IMPDEF_boolean("Condition valid for trapped T32") then {
                syndrome[4] = Bit(0b1);
                syndrome[3 .. 0] = cond
            } else {
                syndrome[4] = Bit(0b0);
                syndrome[3 .. 0] = __UNKNOWN_bits(4)
            }
        }
    } else {
        syndrome[4] = Bit(0b1);
        syndrome[3 .. 0] = 0b1110
    };
    return(syndrome)
}

enum Exception = {
  Exception_Uncategorized,
  Exception_WFxTrap,
  Exception_CP15RTTrap,
  Exception_CP15RRTTrap,
  Exception_CP14RTTrap,
  Exception_CP14DTTrap,
  Exception_AdvSIMDFPAccessTrap,
  Exception_FPIDTrap,
  Exception_CP14RRTTrap,
  Exception_IllegalState,
  Exception_SupervisorCall,
  Exception_HypervisorCall,
  Exception_MonitorCall,
  Exception_SystemRegisterTrap,
  Exception_InstructionAbort,
  Exception_PCAlignment,
  Exception_DataAbort,
  Exception_SPAlignment,
  Exception_FPTrappedException,
  Exception_SError,
  Exception_Breakpoint,
  Exception_SoftwareStep,
  Exception_Watchpoint,
  Exception_SoftwareBreakpoint,
  Exception_VectorCatch,
  Exception_IRQ,
  Exception_CapabilitySysRegTrap,
  Exception_CapabilityAccess,
  Exception_FIQ
}

struct ExceptionRecord = {
  exceptype : Exception,
  syndrome : bits(25),
  vaddress : bits(64),
  ipavalid : bool,
  ipaddress : bits(48)
}

val ExceptionSyndrome : Exception -> ExceptionRecord effect {undef}

function ExceptionSyndrome exceptype = {
    r : ExceptionRecord = undefined;
    r.exceptype = exceptype;
    r.syndrome = Zeros();
    r.vaddress = Zeros();
    r.ipavalid = false;
    r.ipaddress = Zeros();
    return(r)
}

val ThisInstr : unit -> bits(32)

val Unreachable : unit -> unit effect {escape}

function Unreachable () = {
    assert(false)
}

val AArch64_SystemAccessTrapSyndrome : forall ('ec : Int).
  (bits(32), int('ec)) -> ExceptionRecord effect {escape, rreg, undef}

function AArch64_SystemAccessTrapSyndrome (instr__arg, ec) = {
    instr : bits(32) = instr__arg;
    exception : ExceptionRecord = undefined;
    match ec {
      0 => {
          exception = ExceptionSyndrome(Exception_Uncategorized)
      },
      7 => {
          exception = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
          exception.syndrome[24 .. 20] = ConditionSyndrome()
      },
      24 => {
          exception = ExceptionSyndrome(Exception_SystemRegisterTrap);
          let instr : bits(32) = ThisInstr();
          exception.syndrome[21 .. 20] = instr[20 .. 19];
          exception.syndrome[19 .. 17] = instr[7 .. 5];
          exception.syndrome[16 .. 14] = instr[18 .. 16];
          exception.syndrome[13 .. 10] = instr[15 .. 12];
          exception.syndrome[9 .. 5] = instr[4 .. 0];
          exception.syndrome[4 .. 1] = instr[11 .. 8];
          exception.syndrome[0 .. 0] = [instr[21]]
      },
      41 => {
          exception = ExceptionSyndrome(Exception_CapabilityAccess)
      },
      42 => {
          exception = ExceptionSyndrome(Exception_CapabilitySysRegTrap);
          let instr : bits(32) = ThisInstr();
          exception.syndrome[21 .. 20] = 0b1 @ [instr[19]];
          exception.syndrome[19 .. 17] = instr[7 .. 5];
          exception.syndrome[16 .. 14] = instr[18 .. 16];
          exception.syndrome[13 .. 10] = instr[15 .. 12];
          exception.syndrome[9 .. 5] = instr[4 .. 0];
          exception.syndrome[4 .. 1] = instr[11 .. 8];
          exception.syndrome[0 .. 0] = [instr[20]]
      },
      _ => {
          Unreachable()
      }
    };
    return(exception)
}

let EL0 : bits(2) = 0b00

val HaveAArch32EL : bits(2) -> bool

enum ArchVersion = {ARMv8p0, ARMv8p1, ARMv8p2}

val HasArchVersion : ArchVersion -> bool

val HaveVirtHostExt : unit -> bool

function HaveVirtHostExt () = {
    return(HasArchVersion(ARMv8p1))
}

val HighestEL : unit -> bits(2)

function HighestEL () = {
    if HaveEL(EL3) then {
        return(EL3)
    } else if HaveEL(EL2) then {
        return(EL2)
    } else {
        return(EL1)
    }
}

val ELStateUsingAArch32K : forall ('secure : Bool).
  (bits(2), bool('secure)) -> (bool, bool) effect {rreg, undef}

function ELStateUsingAArch32K (el, secure) = {
    if not_bool(HaveAArch32EL(el)) then {
        return((true, false))
    } else if HighestELUsingAArch32() then {
        return((true, true))
    } else if el == HighestEL() then {
        return((true, false))
    } else ();
    aarch32 : bool = __UNKNOWN_boolean();
    known : bool = true;
    let aarch32_below_el3 : bool = HaveEL(EL3) & Slice(SCR_EL3, 10, 1) == 0b0;
    let aarch32_at_el1 : bool = aarch32_below_el3 | ((HaveEL(EL2) & not_bool(secure)) & Slice(HCR_EL2, 31, 1) == 0b0) & not_bool((Slice(HCR_EL2, 34, 1) == 0b1 & Slice(HCR_EL2, 27, 1) == 0b1) & HaveVirtHostExt());
    if el == EL0 & not_bool(aarch32_at_el1) then {
        if PSTATE.EL == EL0 then {
            aarch32 = PSTATE.nRW == 0b1
        } else {
            known = false
        }
    } else {
        aarch32 = aarch32_below_el3 & el != EL3 | aarch32_at_el1 & (el == EL1 | el == EL0)
    };
    if not_bool(known) then {
        aarch32 = __UNKNOWN_boolean()
    } else ();
    return((known, aarch32))
}

val ELStateUsingAArch32 : forall ('secure : Bool).
  (bits(2), bool('secure)) -> bool effect {escape, rreg, undef}

function ELStateUsingAArch32 (el, secure) = {
    aarch32 : bool = undefined;
    known : bool = undefined;
    (known, aarch32) = ELStateUsingAArch32K(el, secure);
    assert(known);
    return(aarch32)
}

val SCR_GEN_read : unit -> bits(64) effect {escape, rreg}

function SCR_GEN_read () = {
    assert(HaveEL(EL3));
    return(ZeroExtend(SCR_EL3))
}

val IsSecureBelowEL3 : unit -> bool effect {escape, rreg}

function IsSecureBelowEL3 () = {
    if HaveEL(EL3) then {
        return([SCR_GEN_read()[0]] == 0b0)
    } else if HaveEL(EL2) then {
        return(false)
    } else {
        return(__IMPDEF_boolean("Secure-only implementation"))
    }
}

val ELUsingAArch32 : bits(2) -> bool effect {escape, rreg, undef}

function ELUsingAArch32 el = {
    return(ELStateUsingAArch32(el, IsSecureBelowEL3()))
}

register _R00 : bits(129)

register _R01 : bits(129)

register _R02 : bits(129)

register _R03 : bits(129)

register _R04 : bits(129)

register _R05 : bits(129)

register _R06 : bits(129)

register _R07 : bits(129)

register _R08 : bits(129)

register _R09 : bits(129)

register _R10 : bits(129)

register _R11 : bits(129)

register _R12 : bits(129)

register _R13 : bits(129)

register _R14 : bits(129)

register _R15 : bits(129)

register _R16 : bits(129)

register _R17 : bits(129)

register _R18 : bits(129)

register _R19 : bits(129)

register _R20 : bits(129)

register _R21 : bits(129)

register _R22 : bits(129)

register _R23 : bits(129)

register _R24 : bits(129)

register _R25 : bits(129)

register _R26 : bits(129)

register _R27 : bits(129)

register _R28 : bits(129)

register _R29 : bits(129)

register _R30 : bits(129)

val _R_read : forall ('idx : Int). int('idx) -> bits(129) effect {escape, rreg}

function _R_read idx = {
    match idx {
      0 => {
          return(_R00)
      },
      1 => {
          return(_R01)
      },
      2 => {
          return(_R02)
      },
      3 => {
          return(_R03)
      },
      4 => {
          return(_R04)
      },
      5 => {
          return(_R05)
      },
      6 => {
          return(_R06)
      },
      7 => {
          return(_R07)
      },
      8 => {
          return(_R08)
      },
      9 => {
          return(_R09)
      },
      10 => {
          return(_R10)
      },
      11 => {
          return(_R11)
      },
      12 => {
          return(_R12)
      },
      13 => {
          return(_R13)
      },
      14 => {
          return(_R14)
      },
      15 => {
          return(_R15)
      },
      16 => {
          return(_R16)
      },
      17 => {
          return(_R17)
      },
      18 => {
          return(_R18)
      },
      19 => {
          return(_R19)
      },
      20 => {
          return(_R20)
      },
      21 => {
          return(_R21)
      },
      22 => {
          return(_R22)
      },
      23 => {
          return(_R23)
      },
      24 => {
          return(_R24)
      },
      25 => {
          return(_R25)
      },
      26 => {
          return(_R26)
      },
      27 => {
          return(_R27)
      },
      28 => {
          return(_R28)
      },
      29 => {
          return(_R29)
      },
      30 => {
          return(_R30)
      },
      _ => {
          assert(false);
          return(undefined : bits(129))
      }
    }
}

val _R_set : forall ('idx : Int).
  (int('idx), bits(129)) -> unit effect {escape, wreg}

function _R_set (idx, c) = {
    match idx {
      0 => {
          _R00 = c
      },
      1 => {
          _R01 = c
      },
      2 => {
          _R02 = c
      },
      3 => {
          _R03 = c
      },
      4 => {
          _R04 = c
      },
      5 => {
          _R05 = c
      },
      6 => {
          _R06 = c
      },
      7 => {
          _R07 = c
      },
      8 => {
          _R08 = c
      },
      9 => {
          _R09 = c
      },
      10 => {
          _R10 = c
      },
      11 => {
          _R11 = c
      },
      12 => {
          _R12 = c
      },
      13 => {
          _R13 = c
      },
      14 => {
          _R14 = c
      },
      15 => {
          _R15 = c
      },
      16 => {
          _R16 = c
      },
      17 => {
          _R17 = c
      },
      18 => {
          _R18 = c
      },
      19 => {
          _R19 = c
      },
      20 => {
          _R20 = c
      },
      21 => {
          _R21 = c
      },
      22 => {
          _R22 = c
      },
      23 => {
          _R23 = c
      },
      24 => {
          _R24 = c
      },
      25 => {
          _R25 = c
      },
      26 => {
          _R26 = c
      },
      27 => {
          _R27 = c
      },
      28 => {
          _R28 = c
      },
      29 => {
          _R29 = c
      },
      30 => {
          _R30 = c
      },
      _ => {
          assert(false)
      }
    }
}

val AArch64_MaybeZeroRegisterUppers : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_MaybeZeroRegisterUppers () = {
    first : {'first, 'first == 0. int('first)} = 0;
    include_R15_name : bool = undefined;
    last : {|14, 30|} = 14;
    assert(UsingAArch32());
    if PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1)) then {
        first = 0;
        last = 14;
        include_R15_name = false
    } else if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2)) then {
        first = 0;
        last = 30;
        include_R15_name = false
    } else {
        first = 0;
        last = 30;
        include_R15_name = true
    };
    let 'last = last;
    let 'first = first;
    foreach (n from first to last by 1 in inc) {
        if (n != 15 | include_R15_name) & ConstrainUnpredictableBool(Unpredictable_ZEROUPPER) then {
            _R_set(n) = [_R_read(n) with 63 .. 32 = Zeros()]
        } else ()
    };
    return()
}

val ThisInstrLength : unit -> int

val AArch64_ExceptionClass : (Exception, bits(2)) -> (int, bits(1)) effect {escape, rreg, undef}

function AArch64_ExceptionClass (exceptype, target_el) = {
    ec : int = undefined;
    il : bits(1) = if ThisInstrLength() == 32 then 0b1 else 0b0;
    let from_32 : bool = UsingAArch32();
    assert(from_32 | il == 0b1);
    match exceptype {
      Exception_Uncategorized => {
          ec = UInt(0x00);
          il = 0b1
      },
      Exception_WFxTrap => {
          ec = UInt(0x01)
      },
      Exception_CP15RTTrap => {
          ec = UInt(0x03);
          assert(from_32)
      },
      Exception_CP15RRTTrap => {
          ec = UInt(0x04);
          assert(from_32)
      },
      Exception_CP14RTTrap => {
          ec = UInt(0x05);
          assert(from_32)
      },
      Exception_CP14DTTrap => {
          ec = UInt(0x06);
          assert(from_32)
      },
      Exception_AdvSIMDFPAccessTrap => {
          ec = UInt(0x07)
      },
      Exception_FPIDTrap => {
          ec = UInt(0x08)
      },
      Exception_CP14RRTTrap => {
          ec = UInt(0x0C);
          assert(from_32)
      },
      Exception_IllegalState => {
          ec = UInt(0x0E);
          il = 0b1
      },
      Exception_SupervisorCall => {
          ec = UInt(0x11)
      },
      Exception_HypervisorCall => {
          ec = UInt(0x12)
      },
      Exception_MonitorCall => {
          ec = UInt(0x13)
      },
      Exception_SystemRegisterTrap => {
          ec = UInt(0x18);
          assert(not_bool(from_32))
      },
      Exception_InstructionAbort => {
          ec = UInt(0x20);
          il = 0b1
      },
      Exception_PCAlignment => {
          ec = UInt(0x22);
          il = 0b1
      },
      Exception_DataAbort => {
          ec = UInt(0x24)
      },
      Exception_SPAlignment => {
          ec = UInt(0x26);
          il = 0b1;
          assert(not_bool(from_32))
      },
      Exception_FPTrappedException => {
          ec = UInt(0x28)
      },
      Exception_CapabilityAccess => {
          ec = UInt(0x29)
      },
      Exception_CapabilitySysRegTrap => {
          ec = UInt(0x2A)
      },
      Exception_SError => {
          ec = UInt(0x2F);
          il = 0b1
      },
      Exception_Breakpoint => {
          ec = UInt(0x30);
          il = 0b1
      },
      Exception_SoftwareStep => {
          ec = UInt(0x32);
          il = 0b1
      },
      Exception_Watchpoint => {
          ec = UInt(0x34);
          il = 0b1
      },
      Exception_SoftwareBreakpoint => {
          ec = UInt(0x38)
      },
      Exception_VectorCatch => {
          ec = UInt(0x3A);
          il = 0b1;
          assert(from_32)
      },
      _ => {
          Unreachable()
      }
    };
    if (ec == UInt(0x20) | ec == UInt(0x24) | ec == UInt(0x30) | ec == UInt(0x32) | ec == UInt(0x34)) & target_el == PSTATE.EL then {
        ec = ec + 1
    } else ();
    if (ec == UInt(0x11) | ec == UInt(0x12) | ec == UInt(0x13) | ec == UInt(0x28) | ec == UInt(0x38)) & not_bool(from_32) then {
        ec = ec + 4
    } else ();
    let 'ec = ec;
    return((ec, il))
}

register ESR_EL1 : bits(32)

register ESR_EL2 : bits(32)

register ESR_EL3 : bits(32)

val ELIsInHost : bits(2) -> bool effect {escape, rreg, undef}

function ELIsInHost el = {
    return((((not_bool(IsSecureBelowEL3()) & HaveVirtHostExt()) & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 34, 1) == 0b1) & (el == EL2 | el == EL0 & Slice(HCR_EL2, 27, 1) == 0b1))
}

val S1TranslationRegime : bits(2) -> bits(2) effect {escape, rreg, undef}

val S1TranslationRegime__1 : unit -> bits(2) effect {escape, rreg, undef}

function S1TranslationRegime el = {
    if el != EL0 then {
        return(el)
    } else if HaveVirtHostExt() & ELIsInHost(el) then {
        return(EL2)
    } else {
        return(EL1)
    }
}

function S1TranslationRegime__1 () = {
    return(S1TranslationRegime(PSTATE.EL))
}

val ESR_set : (bits(2), bits(32)) -> unit effect {escape, rreg, undef, wreg}

val ESR_set__1 : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ESR_set (regime, value_name) = {
    let r : bits(32) = value_name;
    match regime {
      ? if ? == EL1 => {
          ESR_EL1 = r
      },
      ? if ? == EL2 => {
          ESR_EL2 = r
      },
      ? if ? == EL3 => {
          ESR_EL3 = r
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function ESR_set__1 value_name = {
    ESR_set(S1TranslationRegime__1()) = value_name
}

register FAR_EL1 : bits(64)

register FAR_EL2 : bits(64)

register FAR_EL3 : bits(64)

val FAR_set : (bits(2), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FAR_set (regime, value_name) = {
    let r : bits(64) = value_name;
    match regime {
      ? if ? == EL1 => {
          FAR_EL1 = r
      },
      ? if ? == EL2 => {
          FAR_EL2 = r
      },
      ? if ? == EL3 => {
          FAR_EL3 = r
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

register HPFAR_EL2 : bits(64)

val AArch64_ReportException : (ExceptionRecord, bits(2)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ReportException (exception, target_el) = {
    ec : int = undefined;
    il : bits(1) = undefined;
    let exceptype : Exception = exception.exceptype;
    (ec, il) = AArch64_ExceptionClass(exceptype, target_el);
    let 'ec = ec;
    let iss : bits(25) = exception.syndrome;
    if (ec == UInt(0x24) | ec == UInt(0x25)) & [iss[24]] == 0b0 then {
        il = 0b1
    } else ();
    let il = il;
    ESR_set(target_el) = (ec[5 .. 0] @ il) @ iss;
    if exceptype == Exception_InstructionAbort | exceptype == Exception_PCAlignment | exceptype == Exception_DataAbort | exceptype == Exception_Watchpoint then {
        FAR_set(target_el) = exception.vaddress
    } else {
        FAR_set(target_el) = __UNKNOWN_bits(64)
    };
    if target_el == EL2 then {
        if exception.ipavalid then {
            HPFAR_EL2[39 .. 4] = exception.ipaddress[47 .. 12]
        } else {
            HPFAR_EL2[39 .. 4] = __UNKNOWN_bits(36)
        }
    } else ();
    return()
}

register TCR_EL1 : bits(64)

register TCR_EL2 : bits(64)

register TCR_EL3 : bits(32)

val AddrTop : (bits(64), bits(2)) -> {|31, 55, 63|} effect {escape, rreg, undef}

function AddrTop (address, el) = {
    tbi : bits(1) = undefined;
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    if ELUsingAArch32(regime) then {
        return(31)
    } else {
        match regime {
          ? if ? == EL1 => {
              tbi = if [address[55]] == 0b1 then Slice(TCR_EL1, 38, 1) else Slice(TCR_EL1, 37, 1)
          },
          ? if ? == EL2 => {
              if HaveVirtHostExt() & ELIsInHost(el) then {
                  tbi = if [address[55]] == 0b1 then Slice(TCR_EL2, 38, 1) else Slice(TCR_EL2, 37, 1)
              } else {
                  tbi = Slice(TCR_EL2, 20, 1)
              }
          },
          ? if ? == EL3 => {
              tbi = Slice(TCR_EL3, 20, 1)
          },
          _ => ()
        }
    };
    return(if tbi == 0b1 then 55 else 63)
}

val IsInHost : unit -> bool effect {escape, rreg, undef}

function IsInHost () = {
    return(ELIsInHost(PSTATE.EL))
}

val AArch64_BranchAddr : bits(64) -> bits(64) effect {escape, rreg, undef}

function AArch64_BranchAddr vaddress = {
    assert(not_bool(UsingAArch32()));
    let 'msbit = AddrTop(vaddress, PSTATE.EL);
    if msbit == 63 then {
        return(vaddress)
    } else if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) | IsInHost()) & [vaddress[msbit]] == 0b1 then {
        return(SignExtend(vaddress[msbit .. 0]))
    } else {
        return(ZeroExtend(vaddress[msbit .. 0]))
    }
}

enum BranchType = {
  BranchType_DIRCALL,
  BranchType_INDCALL,
  BranchType_ERET,
  BranchType_DBGEXIT,
  BranchType_RET,
  BranchType_DIR,
  BranchType_INDIR,
  BranchType_EXCEPTION,
  BranchType_RESET,
  BranchType_UNKNOWN
}

let CAP_FLAGS_LO_BIT : int(56) = 56

let CAP_VALUE_HI_BIT : int(63) = 63

type CAP_VALUE_HI_BIT : Int = 63

let CAP_VALUE_LO_BIT : int(0) = 0

type CAP_VALUE_LO_BIT : Int = 0

let CAP_VALUE_NUM_BITS : int(CAP_VALUE_HI_BIT - CAP_VALUE_LO_BIT + 1) = CAP_VALUE_HI_BIT - CAP_VALUE_LO_BIT + 1

type CAP_VALUE_NUM_BITS : Int = CAP_VALUE_HI_BIT - CAP_VALUE_LO_BIT + 1

let CAP_BASE_HI_BIT : int(79) = 79

type CAP_BASE_HI_BIT : Int = 79

let CAP_BASE_LO_BIT : int(64) = 64

type CAP_BASE_LO_BIT : Int = 64

let CAP_MW : int(CAP_BASE_HI_BIT - CAP_BASE_LO_BIT + 1) = CAP_BASE_HI_BIT - CAP_BASE_LO_BIT + 1

type CAP_MW : Int = CAP_BASE_HI_BIT - CAP_BASE_LO_BIT + 1

val CapBoundsUsesValue : forall ('exp : Int). int('exp) -> bool

function CapBoundsUsesValue exp = {
    return(exp + CAP_MW < CAP_VALUE_NUM_BITS)
}

let CAP_BASE_EXP_HI_BIT : int(66) = 66

let CAP_LIMIT_EXP_HI_BIT : int(82) = 82

let CAP_LIMIT_LO_BIT : int(80) = 80

let CAP_IE_BIT : int(94) = 94

val CapIsInternalExponent : bits(129) -> bool

function CapIsInternalExponent c = {
    return([c[CAP_IE_BIT]] == 0b0)
}

val CapGetExponent : bits(129) -> range(0, 63)

function CapGetExponent c = {
    if CapIsInternalExponent(c) then {
        let nexp : bits(6) = c[CAP_LIMIT_EXP_HI_BIT .. CAP_LIMIT_LO_BIT] @ c[CAP_BASE_EXP_HI_BIT .. CAP_BASE_LO_BIT];
        return(UInt(not_vec(nexp)))
    } else {
        return(0)
    }
}

val CapGetValue : bits(129) -> bits(CAP_VALUE_NUM_BITS)

function CapGetValue c = {
    return(c[CAP_VALUE_HI_BIT .. CAP_VALUE_LO_BIT])
}

let CAP_BOUND_NUM_BITS : int(CAP_VALUE_NUM_BITS + 1) = CAP_VALUE_NUM_BITS + 1

type CAP_BOUND_NUM_BITS : Int = CAP_VALUE_NUM_BITS + 1

let CAP_BOUND_MAX : bits(CAP_BOUND_NUM_BITS) = Slice((1 << CAP_VALUE_NUM_BITS), 0, CAP_BOUND_NUM_BITS)

let CAP_BOUND_MIN : bits(CAP_BOUND_NUM_BITS) = Slice(UInt(0x0), 0, CAP_BOUND_NUM_BITS)

let CAP_MAX_ENCODEABLE_EXPONENT : int(63) = 63

let CAP_MAX_EXPONENT : int(CAP_VALUE_NUM_BITS - CAP_MW + 2) = CAP_VALUE_NUM_BITS - CAP_MW + 2

val CapBoundsAddress : bits(CAP_VALUE_NUM_BITS) -> bits(CAP_VALUE_NUM_BITS)

function CapBoundsAddress address = {
    return(SignExtend(address[CAP_FLAGS_LO_BIT - 1 .. 0], CAP_VALUE_NUM_BITS))
}

let CAP_BASE_MANTISSA_LO_BIT : int(67) = 67

val CapGetBottom : bits(129) -> bits(CAP_MW)

function CapGetBottom c = {
    if CapIsInternalExponent(c) then {
        return(c[CAP_BASE_HI_BIT .. CAP_BASE_MANTISSA_LO_BIT] @ 0b000)
    } else {
        return(c[CAP_BASE_HI_BIT .. CAP_BASE_LO_BIT])
    }
}

let CAP_LIMIT_HI_BIT : int(93) = 93

let CAP_LIMIT_MANTISSA_LO_BIT : int(83) = 83

val CapUnsignedLessThan : forall ('N : Int). (bits('N), bits('N)) -> bool

function CapUnsignedLessThan (a, b) = {
    return(UInt(a) < UInt(b))
}

val CapGetTop : bits(129) -> bits(CAP_MW) effect {undef}

function CapGetTop c = {
    lmsb : bits(2) = 0b00;
    lcarry : bits(2) = 0b00;
    let b : bits(CAP_MW) = CapGetBottom(c);
    t : bits(CAP_MW) = undefined;
    if CapIsInternalExponent(c) then {
        lmsb = 0b01;
        t = (0b00 @ c[CAP_LIMIT_HI_BIT .. CAP_LIMIT_MANTISSA_LO_BIT]) @ 0b000
    } else {
        t = 0b00 @ c[CAP_LIMIT_HI_BIT .. CAP_LIMIT_LO_BIT]
    };
    if CapUnsignedLessThan(t[CAP_MW - 3 .. 0], b[CAP_MW - 3 .. 0]) then {
        lcarry = 0b01
    } else ();
    t[CAP_MW - 1 .. CAP_MW - 2] = b[CAP_MW - 1 .. CAP_MW - 2] + lmsb + lcarry;
    return(t)
}

val CapIsExponentOutOfRange : bits(129) -> bool

function CapIsExponentOutOfRange c = {
    let 'exp = CapGetExponent(c);
    return(exp > CAP_MAX_EXPONENT & exp < CAP_MAX_ENCODEABLE_EXPONENT)
}

val CapUnsignedGreaterThan : forall ('N : Int). (bits('N), bits('N)) -> bool

function CapUnsignedGreaterThan (a, b) = {
    return(UInt(a) > UInt(b))
}

val CapGetBounds : bits(129) -> (bits(CAP_BOUND_NUM_BITS), bits(CAP_BOUND_NUM_BITS), bool) effect {escape, undef}

function CapGetBounds c = {
    let 'exp = CapGetExponent(c);
    if exp == CAP_MAX_ENCODEABLE_EXPONENT then {
        return((CAP_BOUND_MIN, CAP_BOUND_MAX, true))
    } else ();
    if CapIsExponentOutOfRange(c) then {
        return((CAP_BOUND_MIN, CAP_BOUND_MAX, false))
    } else ();
    base : bits(66) = undefined;
    limit : bits(66) = undefined;
    let bottom : bits(CAP_MW) = CapGetBottom(c);
    let top : bits(CAP_MW) = CapGetTop(c);
    base = SetSlice(exp, base, 0, Zeros(exp));
    limit = SetSlice(exp, limit, 0, Zeros(exp));
    assert(constraint('exp + 16 - 1 < 66));
    base[exp + CAP_MW - 1 .. exp] = bottom;
    limit[exp + CAP_MW - 1 .. exp] = top;
    let a : bits(66) = 0b00 @ CapBoundsAddress(CapGetValue(c));
    let A3 : bits(3) = a[exp + CAP_MW - 1 .. exp + CAP_MW - 3];
    let B3 : bits(3) = bottom[CAP_MW - 1 .. CAP_MW - 3];
    let T3 : bits(3) = top[CAP_MW - 1 .. CAP_MW - 3];
    let R3 : bits(3) = B3 - 0b001;
    aHi : {|0, 1|} = 0;
    if CapUnsignedLessThan(A3, R3) then {
        aHi = 1
    } else {
        aHi = 0
    };
    let 'aHi = aHi;
    bHi : {|0, 1|} = 0;
    if CapUnsignedLessThan(B3, R3) then {
        bHi = 1
    } else {
        bHi = 0
    };
    let 'bHi = bHi;
    tHi : {|0, 1|} = 0;
    if CapUnsignedLessThan(T3, R3) then {
        tHi = 1
    } else {
        tHi = 0
    };
    let 'tHi = tHi;
    let 'correction_base = bHi - aHi;
    let 'correction_limit = tHi - aHi;
    if exp + CAP_MW < CAP_MAX_EXPONENT + CAP_MW then {
        let atop : bits(65 - ('exp + CAP_MW) + 1) = a[65 .. exp + CAP_MW];
        base[65 .. exp + CAP_MW] = atop + correction_base;
        limit[65 .. exp + CAP_MW] = atop + correction_limit
    } else ();
    let l2 : bits(2) = limit[64 .. 63];
    let b2 : bits(2) = 0b0 @ [base[63]];
    if exp < CAP_MAX_EXPONENT - 1 & CapUnsignedGreaterThan(l2 - b2, 0b01) then {
        limit[64] = Bit(not_vec([limit[64]]))
    } else ();
    return((0b0 @ base[63 .. 0], limit[64 .. 0], true))
}

val CapBoundsEqual : (bits(129), bits(129)) -> bool effect {escape, undef}

function CapBoundsEqual (a, b) = {
    abase : bits(CAP_BOUND_NUM_BITS) = undefined;
    alimit : bits(CAP_BOUND_NUM_BITS) = undefined;
    avalid : bool = undefined;
    bbase : bits(CAP_BOUND_NUM_BITS) = undefined;
    blimit : bits(CAP_BOUND_NUM_BITS) = undefined;
    bvalid : bool = undefined;
    (abase, alimit, avalid) = CapGetBounds(a);
    (bbase, blimit, bvalid) = CapGetBounds(b);
    return(((abase == bbase & alimit == blimit) & avalid) & bvalid)
}

val CapIsRepresentable : (bits(129), bits(CAP_VALUE_NUM_BITS)) -> bool effect {escape, undef}

function CapIsRepresentable (c, address) = {
    newc : bits(129) = c;
    newc[CAP_VALUE_HI_BIT .. CAP_VALUE_LO_BIT] = address;
    return(CapBoundsEqual(c, newc))
}

let CAP_TAG_BIT : int(128) = 128

val CapSetTag : (bits(129), bits(64)) -> bits(129)

function CapSetTag (c, t) = {
    r : bits(129) = c;
    r[CAP_TAG_BIT] = Bit([t[0]]);
    return(r)
}

val CapWithTagClear : bits(129) -> bits(129)

function CapWithTagClear c = {
    return(CapSetTag(c, ZeroExtend(0b0, 64)))
}

val CapSetValue : (bits(129), bits(CAP_VALUE_NUM_BITS)) -> bits(129) effect {escape, undef}

function CapSetValue (c__arg, v) = {
    c : bits(129) = c__arg;
    let oldv : bits(CAP_VALUE_NUM_BITS) = CapGetValue(c);
    if not_bool(CapIsRepresentable(c, v)) then {
        c = CapWithTagClear(c)
    } else ();
    c[CAP_VALUE_HI_BIT .. CAP_VALUE_LO_BIT] = v;
    if CapBoundsUsesValue(CapGetExponent(c)) & [v[CAP_FLAGS_LO_BIT - 1]] != [oldv[CAP_FLAGS_LO_BIT - 1]] then {
        c = CapWithTagClear(c)
    } else ();
    return(c)
}

val Hint_Branch : BranchType -> unit

register _PC : bits(64)

register __BranchTaken : bool

val BranchTo : forall ('N : Int).
  (bits('N), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BranchTo (target, branch_type) = {
    Hint_Branch(branch_type);
    if 'N == 32 then {
        assert(UsingAArch32());
        _PC = ZeroExtend(target);
        PCC = CapSetValue(PCC, ZeroExtend(target))
    } else {
        assert('N == 64 & not_bool(UsingAArch32()));
        _PC = AArch64_BranchAddr(target[63 .. 0]);
        PCC = CapSetValue(PCC, AArch64_BranchAddr(target[63 .. 0]))
    };
    __BranchTaken = true;
    return()
}

let CAP_OTYPE_HI_BIT : int(109) = 109

type CAP_OTYPE_HI_BIT : Int = 109

let CAP_OTYPE_LO_BIT : int(95) = 95

type CAP_OTYPE_LO_BIT : Int = 95

val CapGetObjectType : bits(129) -> bits(CAP_VALUE_NUM_BITS)

function CapGetObjectType c = {
    return(ZeroExtend(c[CAP_OTYPE_HI_BIT .. CAP_OTYPE_LO_BIT], CAP_VALUE_NUM_BITS))
}

val CapIsSealed : bits(129) -> bool

function CapIsSealed c = {
    return(CapGetObjectType(c) != Zeros(CAP_VALUE_NUM_BITS))
}

let CAP_FLAGS_HI_BIT : int(63) = 63

val CapSetFlags : (bits(129), bits(CAP_VALUE_NUM_BITS)) -> bits(129)

function CapSetFlags (c__arg, f) = {
    c : bits(129) = c__arg;
    c[CAP_FLAGS_HI_BIT .. CAP_FLAGS_LO_BIT] = f[CAP_FLAGS_HI_BIT .. CAP_FLAGS_LO_BIT];
    return(c)
}

val BranchAddr : (bits(129), bits(2)) -> bits(129) effect {escape, rreg, undef}

function BranchAddr (c__arg, el) = {
    c : bits(129) = c__arg;
    assert(not_bool(UsingAArch32()));
    let cap_value : bits(64) = CapGetValue(c);
    let 'msbit = AddrTop(cap_value, el);
    if CapIsSealed(c) then {
        c = CapWithTagClear(c)
    } else ();
    if msbit == 63 then {
        return(c)
    } else if ((el == EL0 | el == EL1) | IsInHost()) & [cap_value[msbit]] == 0b1 then {
        assert(msbit == 55);
        return(CapSetFlags(c, SignExtend(cap_value[msbit .. 0])))
    } else {
        assert(msbit == 55);
        return(CapSetFlags(c, ZeroExtend(cap_value[msbit .. 0])))
    }
}

val BranchToCapability : (bits(129), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BranchToCapability (target, branch_type) = {
    Hint_Branch(branch_type);
    assert(not_bool(UsingAArch32()));
    _PC = AArch64_BranchAddr(CapGetValue(target));
    PCC = BranchAddr(target, PSTATE.EL);
    __BranchTaken = true;
    return()
}

register CCTLR_EL0 : bits(32)

register CCTLR_EL1 : bits(32)

register CCTLR_EL2 : bits(32)

register CCTLR_EL3 : bits(32)

val CCTLR_read : bits(2) -> bits(32) effect {escape, rreg, undef}

val CCTLR_read__1 : unit -> bits(32) effect {escape, rreg, undef}

function CCTLR_read el = {
    r : bits(32) = undefined;
    match el {
      ? if ? == EL0 => {
          r = CCTLR_EL0
      },
      ? if ? == EL1 => {
          r = CCTLR_EL1
      },
      ? if ? == EL2 => {
          r = CCTLR_EL2
      },
      ? if ? == EL3 => {
          r = CCTLR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function CCTLR_read__1 () = {
    return(CCTLR_read(PSTATE.EL))
}

register ELR_EL1 : bits(129)

register ELR_EL2 : bits(129)

register ELR_EL3 : bits(129)

val CELR_set : (bits(2), bits(129)) -> unit effect {escape, rreg, wreg}

val CELR_set__1 : bits(129) -> unit effect {escape, rreg, wreg}

function CELR_set (el, value_name) = {
    match el {
      ? if ? == EL1 => {
          ELR_EL1 = value_name
      },
      ? if ? == EL2 => {
          ELR_EL2 = value_name
      },
      ? if ? == EL3 => {
          ELR_EL3 = value_name
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function CELR_set__1 value_name = {
    CELR_set(PSTATE.EL) = value_name;
    return()
}

register VBAR_EL1 : bits(129)

register VBAR_EL2 : bits(129)

register VBAR_EL3 : bits(129)

val CVBAR_read : bits(2) -> bits(129) effect {escape, rreg, undef}

val CVBAR_read__1 : unit -> bits(129) effect {escape, rreg, undef}

function CVBAR_read regime = {
    r : bits(129) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = VBAR_EL1
      },
      ? if ? == EL2 => {
          r = VBAR_EL2
      },
      ? if ? == EL3 => {
          r = VBAR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function CVBAR_read__1 () = {
    return(CVBAR_read(PSTATE.EL))
}

val ELR_set : (bits(2), bits(64)) -> unit effect {escape, rreg, wreg}

val ELR_set__1 : bits(64) -> unit effect {escape, rreg, wreg}

function ELR_set (el, value_name) = {
    let r : bits(64) = value_name;
    match el {
      ? if ? == EL1 => {
          ELR_EL1 = ZeroExtend(r)
      },
      ? if ? == EL2 => {
          ELR_EL2 = ZeroExtend(r)
      },
      ? if ? == EL3 => {
          ELR_EL3 = ZeroExtend(r)
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

function ELR_set__1 value_name = {
    assert(PSTATE.EL != EL0);
    ELR_set(PSTATE.EL) = value_name;
    return()
}

val HaveCapabilitiesExt : unit -> bool

function HaveCapabilitiesExt () = {
    return(true)
}

val HavePANExt : unit -> bool

function HavePANExt () = {
    return(HasArchVersion(ARMv8p1))
}

val HaveSSBSExt : unit -> bool

function HaveSSBSExt () = {
    return(__IMPDEF_boolean("Has SSBS extension"))
}

val HaveUAOExt : unit -> bool

function HaveUAOExt () = {
    return(HasArchVersion(ARMv8p2))
}

val GetPSRFromPSTATE : unit -> bits(32) effect {rreg}

function GetPSRFromPSTATE () = {
    spsr : bits(32) = Zeros();
    spsr[31 .. 28] = PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V));
    if HavePANExt() then {
        spsr[22] = Bit(PSTATE.PAN)
    } else ();
    spsr[20] = Bit(PSTATE.IL);
    if HaveCapabilitiesExt() then {
        spsr[26] = Bit(PSTATE.C64)
    } else ();
    if HaveUAOExt() then {
        spsr[23] = Bit(PSTATE.UAO)
    } else ();
    spsr[21] = Bit(PSTATE.SS);
    if HaveSSBSExt() then {
        spsr[12] = Bit(PSTATE.SSBS)
    } else ();
    spsr[9 .. 6] = PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F));
    spsr[4] = Bit(PSTATE.nRW);
    spsr[3 .. 2] = PSTATE.EL;
    spsr[0] = Bit(PSTATE.SP);
    return(spsr)
}

val HaveRASExt : unit -> bool

function HaveRASExt () = {
    return(HasArchVersion(ARMv8p2) | __IMPDEF_boolean("Has RAS extension"))
}

val HaveIESB : unit -> bool

function HaveIESB () = {
    return(HaveRASExt() & __IMPDEF_boolean("Has Implicit Error Synchronization Barrier"))
}

val InsertIESBBeforeException : bits(2) -> bool

register CPACR_EL1 : bits(32)

register CPTR_EL2 : bits(32)

register CPTR_EL3 : bits(32)

val IsAccessToCapabilitiesDisabledAtEL3 : unit -> bool effect {rreg}

function IsAccessToCapabilitiesDisabledAtEL3 () = {
    return(HaveEL(EL3) & Slice(CPTR_EL3, 9, 1) == 0b0)
}

let M32_Monitor : bits(5) = 0b10110

val IsSecure : unit -> bool effect {escape, rreg}

function IsSecure () = {
    if (HaveEL(EL3) & not_bool(UsingAArch32())) & PSTATE.EL == EL3 then {
        return(true)
    } else if (HaveEL(EL3) & UsingAArch32()) & PSTATE.M == M32_Monitor then {
        return(true)
    } else ();
    return(IsSecureBelowEL3())
}

val IsAccessToCapabilitiesDisabledAtEL2 : unit -> bool effect {escape, rreg}

function IsAccessToCapabilitiesDisabledAtEL2 () = {
    if IsAccessToCapabilitiesDisabledAtEL3() then {
        return(true)
    } else if HaveEL(EL2) & not_bool(IsSecure()) then {
        return(Slice(HCR_EL2, 34, 1) == 0b1 & (match Slice(CPTR_EL2, 18, 2) {
          [_, bitzero] => true,
          _ => false
        }) : bool | Slice(HCR_EL2, 34, 1) == 0b0 & Slice(CPTR_EL2, 9, 1) == 0b1)
    } else {
        return(false)
    }
}

val IsAccessToCapabilitiesDisabledAtEL1 : unit -> bool effect {escape, rreg}

function IsAccessToCapabilitiesDisabledAtEL1 () = {
    if IsAccessToCapabilitiesDisabledAtEL2() then {
        return(true)
    } else {
        return(not_bool(((HaveEL(EL2) & not_bool(IsSecure())) & Slice(HCR_EL2, 34, 1) == 0b1) & Slice(HCR_EL2, 27, 1) == 0b1) & (match Slice(CPACR_EL1, 18, 2) {
          [_, bitzero] => true,
          _ => false
        }) : bool)
    }
}

val IsAccessToCapabilitiesDisabledAtEL0 : unit -> bool effect {escape, rreg}

function IsAccessToCapabilitiesDisabledAtEL0 () = {
    if IsAccessToCapabilitiesDisabledAtEL1() then {
        return(true)
    } else if not_bool(((HaveEL(EL2) & not_bool(IsSecure())) & Slice(HCR_EL2, 34, 1) == 0b1) & Slice(HCR_EL2, 27, 1) == 0b1) & Slice(CPACR_EL1, 18, 2) == 0b01 then {
        return(true)
    } else {
        return((((HaveEL(EL2) & not_bool(IsSecure())) & Slice(HCR_EL2, 34, 1) == 0b1) & Slice(HCR_EL2, 27, 1) == 0b1) & Slice(CPTR_EL2, 18, 2) == 0b01)
    }
}

val IsAccessToCapabilitiesEnabledAtEL : bits(2) -> bool effect {escape, rreg, undef}

function IsAccessToCapabilitiesEnabledAtEL el = {
    match el {
      ? if ? == EL3 => {
          return(not_bool(IsAccessToCapabilitiesDisabledAtEL3()))
      },
      ? if ? == EL2 => {
          return(not_bool(IsAccessToCapabilitiesDisabledAtEL2()))
      },
      ? if ? == EL1 => {
          return(not_bool(IsAccessToCapabilitiesDisabledAtEL1()))
      },
      ? if ? == EL0 => {
          return(not_bool(IsAccessToCapabilitiesDisabledAtEL0()))
      },
      _ => {
          return(undefined : bool)
      }
    }
}

let CAP_PERM_EXECUTIVE : bits(64) = ((1 << 1))[63 .. 0]

let CAP_PERMS_HI_BIT : int(127) = 127

type CAP_PERMS_HI_BIT : Int = 127

let CAP_PERMS_LO_BIT : int(110) = 110

type CAP_PERMS_LO_BIT : Int = 110

let CAP_PERMS_NUM_BITS : int(CAP_PERMS_HI_BIT - CAP_PERMS_LO_BIT + 1) = CAP_PERMS_HI_BIT - CAP_PERMS_LO_BIT + 1

type CAP_PERMS_NUM_BITS : Int = CAP_PERMS_HI_BIT - CAP_PERMS_LO_BIT + 1

val CapGetPermissions : bits(129) -> bits(CAP_PERMS_NUM_BITS)

function CapGetPermissions c = {
    return(c[CAP_PERMS_HI_BIT .. CAP_PERMS_LO_BIT])
}

val CapCheckPermissions : (bits(129), bits(64)) -> bool

function CapCheckPermissions (c, mask) = {
    let perms : bits(CAP_PERMS_NUM_BITS) = CapGetPermissions(c);
    return((perms | not_vec(mask[CAP_PERMS_NUM_BITS - 1 .. 0])) == Ones(CAP_PERMS_NUM_BITS))
}

val CapIsExecutive : bits(129) -> bool

function CapIsExecutive c = {
    return(CapCheckPermissions(c, CAP_PERM_EXECUTIVE))
}

register EDSCR : bits(32)

val Halted : unit -> bool effect {rreg}

function Halted () = {
    return(not_bool(Slice(EDSCR, 0, 6) == 0b000001 | Slice(EDSCR, 0, 6) == 0b000010))
}

val PCC_read : unit -> bits(129) effect {rreg}

function PCC_read () = {
    return(PCC)
}

val IsInRestricted : unit -> bool effect {rreg}

function IsInRestricted () = {
    if Halted() then {
        return(false)
    } else {
        return(not_bool(CapIsExecutive(PCC_read())))
    }
}

register SCTLR_EL1 : bits(64)

register SCTLR_EL2 : bits(64)

register SCTLR_EL3 : bits(64)

val SCTLR_read : bits(2) -> bits(64) effect {escape, rreg, undef}

val SCTLR_read__1 : unit -> bits(64) effect {escape, rreg, undef}

function SCTLR_read regime = {
    r : bits(64) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = SCTLR_EL1
      },
      ? if ? == EL2 => {
          r = SCTLR_EL2
      },
      ? if ? == EL3 => {
          r = SCTLR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function SCTLR_read__1 () = {
    return(SCTLR_read(S1TranslationRegime__1()))
}

register SPSR_EL1 : bits(32)

register SPSR_EL2 : bits(32)

register SPSR_EL3 : bits(32)

val SPSR_set : bits(32) -> unit effect {escape, rreg, wreg}

function SPSR_set value_name = {
    match PSTATE.EL {
      ? if ? == EL1 => {
          SPSR_EL1 = value_name
      },
      ? if ? == EL2 => {
          SPSR_EL2 = value_name
      },
      ? if ? == EL3 => {
          SPSR_EL3 = value_name
      },
      _ => {
          Unreachable()
      }
    };
    return()
}

val SynchronizeContext : unit -> unit

val SynchronizeErrors : unit -> unit

val TakeUnmaskedPhysicalSErrorInterrupts : forall ('iesb_req : Bool).
  bool('iesb_req) -> unit

val VBAR_read : bits(2) -> bits(64) effect {escape, rreg, undef}

val VBAR_read__1 : unit -> bits(64) effect {escape, rreg, undef}

function VBAR_read regime = {
    r : bits(64) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = VBAR_EL1[63 .. 0]
      },
      ? if ? == EL2 => {
          r = VBAR_EL2[63 .. 0]
      },
      ? if ? == EL3 => {
          r = VBAR_EL3[63 .. 0]
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function VBAR_read__1 () = {
    return(VBAR_read(S1TranslationRegime__1()))
}

val AArch64_TakeException : forall ('vect_offset : Int).
  (bits(2), ExceptionRecord, bits(64), int('vect_offset)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeException (target_el, exception, preferred_exception_return, vect_offset__arg) = {
    vect_offset : int = vect_offset__arg;
    iesb_req : bool = undefined;
    assert((HaveEL(target_el) & not_bool(ELUsingAArch32(target_el))) & UInt(target_el) >= UInt(PSTATE.EL));
    sync_errors : bool = HaveIESB() & [SCTLR_read__1()[21]] == 0b1;
    if sync_errors & InsertIESBBeforeException(target_el) then {
        SynchronizeErrors();
        iesb_req = false;
        sync_errors = false;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    } else ();
    SynchronizeContext();
    let from_32 : bool = UsingAArch32();
    if from_32 then {
        AArch64_MaybeZeroRegisterUppers()
    } else ();
    if UInt(target_el) > UInt(PSTATE.EL) then {
        lower_32 : bool = undefined;
        if target_el == EL3 then {
            if EL2Enabled() then {
                lower_32 = ELUsingAArch32(EL2)
            } else {
                lower_32 = ELUsingAArch32(EL1)
            }
        } else if (IsInHost() & PSTATE.EL == EL0) & target_el == EL2 then {
            lower_32 = ELUsingAArch32(EL0)
        } else {
            lower_32 = ELUsingAArch32(target_el - 1)
        };
        vect_offset = vect_offset + (if lower_32 then UInt(0x600) else UInt(0x400))
    } else if PSTATE.SP == 0b1 & not_bool(IsInRestricted()) then {
        vect_offset = vect_offset + UInt(0x200)
    } else ();
    let 'vect_offset = vect_offset;
    let spsr : bits(32) = GetPSRFromPSTATE();
    if not_bool(exception.exceptype == Exception_IRQ | exception.exceptype == Exception_FIQ) then {
        AArch64_ReportException(exception, target_el)
    } else ();
    PSTATE.EL = target_el;
    PSTATE.nRW = 0b0;
    PSTATE.SP = 0b1;
    SPSR_set() = spsr;
    if IsAccessToCapabilitiesEnabledAtEL(PSTATE.EL) then {
        CELR_set__1() = CapSetValue(PCC, preferred_exception_return)
    } else {
        ELR_set__1() = preferred_exception_return
    };
    PSTATE.SS = 0b0;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b1111;
    PSTATE.IL = 0b0;
    if from_32 then {
        PSTATE.IT = 0b00000000;
        PSTATE.T = 0b0
    } else ();
    if (HavePANExt() & (PSTATE.EL == EL1 | PSTATE.EL == EL2 & ELIsInHost(EL0))) & [SCTLR_read__1()[23]] == 0b0 then {
        PSTATE.PAN = 0b1
    } else ();
    if HaveUAOExt() then {
        PSTATE.UAO = 0b0
    } else ();
    if HaveSSBSExt() then {
        PSTATE.SSBS = [SCTLR_read__1()[44]]
    } else ();
    if IsAccessToCapabilitiesEnabledAtEL(PSTATE.EL) then {
        PSTATE.C64 = [CCTLR_read__1()[5]];
        c : bits(129) = CVBAR_read__1();
        let v : bits(64) = CapGetValue(c);
        let c : bits(129) = CapSetValue(c, v[63 .. 11] @ vect_offset[10 .. 0]);
        BranchToCapability(c, BranchType_EXCEPTION)
    } else {
        PSTATE.C64 = 0b0;
        BranchTo(VBAR_read__1()[63 .. 11] @ vect_offset[10 .. 0], BranchType_EXCEPTION)
    };
    if sync_errors then {
        SynchronizeErrors();
        let iesb_req : bool = true;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    } else ();
    EndOfInstruction()
}

val ThisInstrAddr : forall ('N : Int), 'N > 0. int('N) -> bits('N)

val AArch64_SystemAccessTrap : forall ('ec : Int).
  (bits(2), int('ec)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SystemAccessTrap (target_el, ec) = {
    assert((HaveEL(target_el) & target_el != EL0) & UInt(target_el) >= UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = AArch64_SystemAccessTrapSyndrome(ThisInstr(), ec);
    AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
}

register ACTLR_EL1 : bits(64)

let CAP_PERM_EXECUTE : bits(64) = ((1 << 15))[63 .. 0]

let CAP_PERM_SYSTEM : bits(64) = ((1 << 9))[63 .. 0]

val CapIsSystemAccessPermitted : bits(129) -> bool

function CapIsSystemAccessPermitted c = {
    return(CapCheckPermissions(c, CAP_PERM_EXECUTE | CAP_PERM_SYSTEM))
}

val CapIsSystemAccessEnabled : unit -> bool effect {rreg}

function CapIsSystemAccessEnabled () = {
    if Halted() then {
        return(true)
    } else {
        return(CapIsSystemAccessPermitted(PCC_read()))
    }
}

val TargetELForCapabilityExceptions : unit -> bits(2) effect {escape, rreg, undef}

function TargetELForCapabilityExceptions () = {
    lowest_el : bits(2) = undefined;
    if HighestEL() == EL1 | not_bool(IsAccessToCapabilitiesDisabledAtEL1()) then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
            lowest_el = EL2
        } else {
            lowest_el = EL1
        }
    } else if HighestEL() == EL2 | not_bool(IsAccessToCapabilitiesDisabledAtEL2()) & EL2Enabled() then {
        lowest_el = EL2
    } else {
        lowest_el = EL3
    };
    if UInt(lowest_el) < UInt(PSTATE.EL) then {
        return(PSTATE.EL)
    } else {
        return(lowest_el)
    }
}

val ACTLR_EL1_SysRegRead_56bd4d0367c16236 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ACTLR_EL1_SysRegRead_56bd4d0367c16236 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TACR : bits(1) = Slice(HCR_EL2, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TACR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ACTLR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ACTLR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ACTLR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ACTLR_EL2 : bits(64)

val ACTLR_EL2_SysRegRead_ff23cef1b670b9c7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ACTLR_EL2_SysRegRead_ff23cef1b670b9c7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ACTLR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ACTLR_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ACTLR_EL3 : bits(64)

val ACTLR_EL3_SysRegRead_397e6c0342e2936b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ACTLR_EL3_SysRegRead_397e6c0342e2936b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ACTLR_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AFSR0_EL1 : bits(64)

val AFSR0_EL12_SysRegRead_2488de32a3f38621 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR0_EL12_SysRegRead_2488de32a3f38621 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(AFSR0_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(AFSR0_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register AFSR0_EL2 : bits(64)

val AFSR0_EL1_SysRegRead_80a4a0472e0b9142 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR0_EL1_SysRegRead_80a4a0472e0b9142 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR0_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(AFSR0_EL2)
        } else {
            return(AFSR0_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR0_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val AFSR0_EL2_SysRegRead_07613e9c4b98061a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR0_EL2_SysRegRead_07613e9c4b98061a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(AFSR0_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR0_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AFSR0_EL3 : bits(64)

val AFSR0_EL3_SysRegRead_d2e69d7912ca200c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR0_EL3_SysRegRead_d2e69d7912ca200c (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR0_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AFSR1_EL1 : bits(64)

val AFSR1_EL12_SysRegRead_39bb62021df07ecc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR1_EL12_SysRegRead_39bb62021df07ecc (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(AFSR1_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(AFSR1_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register AFSR1_EL2 : bits(64)

val AFSR1_EL1_SysRegRead_495927b72173c55f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR1_EL1_SysRegRead_495927b72173c55f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR1_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(AFSR1_EL2)
        } else {
            return(AFSR1_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR1_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val AFSR1_EL2_SysRegRead_f7cb9a59387f268f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR1_EL2_SysRegRead_f7cb9a59387f268f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(AFSR1_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR1_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AFSR1_EL3 : bits(64)

val AFSR1_EL3_SysRegRead_a2ad736ad599f2b2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AFSR1_EL3_SysRegRead_a2ad736ad599f2b2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AFSR1_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AIDR_EL1 : bits(64)

val AIDR_EL1_SysRegRead_74ea31b1dc6f5c6f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AIDR_EL1_SysRegRead_74ea31b1dc6f5c6f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID1 : bits(1) = Slice(HCR_EL2, 16, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AIDR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(AIDR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AIDR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AMAIR_EL1 : bits(64)

val AMAIR_EL12_SysRegRead_87964a33cc1ad0ef : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AMAIR_EL12_SysRegRead_87964a33cc1ad0ef (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(AMAIR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(AMAIR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register AMAIR_EL2 : bits(64)

val AMAIR_EL1_SysRegRead_82d01d3808e04ca3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AMAIR_EL1_SysRegRead_82d01d3808e04ca3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AMAIR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(AMAIR_EL2)
        } else {
            return(AMAIR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AMAIR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val AMAIR_EL2_SysRegRead_3c316bb11b239640 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AMAIR_EL2_SysRegRead_3c316bb11b239640 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(AMAIR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AMAIR_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register AMAIR_EL3 : bits(64)

val AMAIR_EL3_SysRegRead_b1547f511477c529 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AMAIR_EL3_SysRegRead_b1547f511477c529 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(AMAIR_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CCSIDR_EL1 : bits(32)

val CCSIDR_EL1_SysRegRead_210f94b423761d0b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CCSIDR_EL1_SysRegRead_210f94b423761d0b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID2 : bits(1) = Slice(HCR_EL2, 17, 1);
    let __HCR_EL2_TID4 : bits(1) = Slice(HCR_EL2, 49, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID2 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID4 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CCSIDR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CCSIDR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CCSIDR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CCTLR_EL0 : bits(32) -> bits(32)

function __get_CCTLR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 0, 0b00);
    val_name = SetSlice(1, val_name, 5, 0b0);
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val CCTLR_EL0_SysRegRead_3baa7e22d96a4ce4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CCTLR_EL0_SysRegRead_3baa7e22d96a4ce4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL0(CCTLR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL0(CCTLR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL0(CCTLR_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL0(CCTLR_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CCTLR_EL1 : bits(32) -> bits(32)

function __get_CCTLR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val CCTLR_EL12_SysRegRead_e8b17aabd47dc7a1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CCTLR_EL12_SysRegRead_e8b17aabd47dc7a1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
              [_, bitzero] => true,
              _ => false
            }) : bool then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(64))
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CCTLR_EL1(CCTLR_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else if __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CCTLR_EL1(CCTLR_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CCTLR_EL2 : bits(32) -> bits(32)

function __get_CCTLR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val CCTLR_EL1_SysRegRead_de402a061eecb9b9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CCTLR_EL1_SysRegRead_de402a061eecb9b9 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL1(CCTLR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_CCTLR_EL2(CCTLR_EL2)))
        } else {
            return(ZeroExtend(__get_CCTLR_EL1(CCTLR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL1(CCTLR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CCTLR_EL2_SysRegRead_fca4364f27bb9f9b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CCTLR_EL2_SysRegRead_fca4364f27bb9f9b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL2(CCTLR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL2(CCTLR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CCTLR_EL3 : bits(32) -> bits(32)

function __get_CCTLR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 1, 0b0);
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val CCTLR_EL3_SysRegRead_9121a22ebc361586 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CCTLR_EL3_SysRegRead_9121a22ebc361586 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CCTLR_EL3(CCTLR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CHCR_EL2 : bits(32)

val __get_CHCR_EL2 : bits(32) -> bits(32)

function __get_CHCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val CHCR_EL2_SysRegRead_7d3c39a46321f1a2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CHCR_EL2_SysRegRead_7d3c39a46321f1a2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CHCR_EL2(CHCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CHCR_EL2(CHCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CLIDR_EL1 : bits(64)

val __get_CLIDR_EL1 : bits(64) -> bits(64)

function __get_CLIDR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(31, val_name, 33, 0b0000000000000000000000000000000);
    return(val_name)
}

val CLIDR_EL1_SysRegRead_b403ddc99e97c3a8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CLIDR_EL1_SysRegRead_b403ddc99e97c3a8 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID2 : bits(1) = Slice(HCR_EL2, 17, 1);
    let __HCR_EL2_TID4 : bits(1) = Slice(HCR_EL2, 49, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID2 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID4 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_CLIDR_EL1(CLIDR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_CLIDR_EL1(CLIDR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_CLIDR_EL1(CLIDR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTFRQ_EL0 : bits(32)

register CNTHCTL_EL2 : bits(32)

register CNTKCTL_EL1 : bits(32)

val CNTFRQ_EL0_SysRegRead_891ca00adf0c3783 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTFRQ_EL0_SysRegRead_891ca00adf0c3783 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & (Slice(CNTKCTL_EL1, 0, 1) @ Slice(CNTKCTL_EL1, 1, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & (Slice(CNTHCTL_EL2, 0, 1) @ Slice(CNTHCTL_EL2, 1, 1)) == 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTFRQ_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CNTFRQ_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CNTFRQ_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTFRQ_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CNTHCTL_EL2 : bits(32) -> bits(32)

function __get_CNTHCTL_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(20, val_name, 12, 0b00000000000000000000);
    return(val_name)
}

val CNTHCTL_EL2_SysRegRead_5f510d633361c720 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHCTL_EL2_SysRegRead_5f510d633361c720 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_CNTHCTL_EL2(CNTHCTL_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTHCTL_EL2(CNTHCTL_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTHP_CTL_EL2 : bits(32)

val __get_CNTHP_CTL_EL2 : bits(32) -> bits(32)

function __get_CNTHP_CTL_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val CNTHP_CTL_EL2_SysRegRead_7103e47839f2c66b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHP_CTL_EL2_SysRegRead_7103e47839f2c66b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_CNTHP_CTL_EL2(CNTHP_CTL_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTHP_CTL_EL2(CNTHP_CTL_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTHP_CVAL_EL2 : bits(64)

val CNTHP_CVAL_EL2_SysRegRead_e25a0257128c640b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHP_CVAL_EL2_SysRegRead_e25a0257128c640b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTHP_CVAL_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTHP_CVAL_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTHP_TVAL_EL2 : bits(32)

val CNTHP_TVAL_EL2_SysRegRead_d110a1f1616c9f8f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHP_TVAL_EL2_SysRegRead_d110a1f1616c9f8f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CNTHP_TVAL_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTHP_TVAL_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTHV_CTL_EL2 : bits(32)

val __get_CNTHV_CTL_EL2 : bits(32) -> bits(32)

function __get_CNTHV_CTL_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val CNTHV_CTL_EL2_SysRegRead_bc429f3d6b52b800 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHV_CTL_EL2_SysRegRead_bc429f3d6b52b800 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_CNTHV_CTL_EL2(CNTHV_CTL_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTHV_CTL_EL2(CNTHV_CTL_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTHV_CVAL_EL2 : bits(64)

val CNTHV_CVAL_EL2_SysRegRead_2c78392b89702ca9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHV_CVAL_EL2_SysRegRead_2c78392b89702ca9 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTHV_CVAL_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTHV_CVAL_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTHV_TVAL_EL2 : bits(32)

val CNTHV_TVAL_EL2_SysRegRead_2464c0e91db55a22 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTHV_TVAL_EL2_SysRegRead_2464c0e91db55a22 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CNTHV_TVAL_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTHV_TVAL_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CNTKCTL_EL1 : bits(32) -> bits(32)

function __get_CNTKCTL_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(22, val_name, 10, 0b0000000000000000000000);
    return(val_name)
}

val CNTKCTL_EL12_SysRegRead_c23def3111264258 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTKCTL_EL12_SysRegRead_c23def3111264258 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(__get_CNTKCTL_EL1(CNTKCTL_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CNTKCTL_EL1(CNTKCTL_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTKCTL_EL1_SysRegRead_6a6cc900bc3c37df : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTKCTL_EL1_SysRegRead_6a6cc900bc3c37df (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_CNTKCTL_EL1(CNTKCTL_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_CNTHCTL_EL2(CNTHCTL_EL2)))
        } else {
            return(ZeroExtend(__get_CNTKCTL_EL1(CNTKCTL_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTKCTL_EL1(CNTKCTL_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTPCT_EL0 : bits(64)

val CNTPCT_EL0_SysRegRead_579be4c9ef4e6824 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTPCT_EL0_SysRegRead_579be4c9ef4e6824 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PCTEN : bits(1) = Slice(CNTKCTL_EL1, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PCTEN : bits(1) = Slice(CNTHCTL_EL2, if HaveVirtHostExt() & Slice(HCR_EL2, 34, 1) == 0b1 then 10 else 0, 1);
    let __CNTHCTL_EL2_EL0PCTEN : bits(1) = Slice(CNTHCTL_EL2, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PCTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PCTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PCTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTPCT_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __CNTHCTL_EL2_EL1PCTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTPCT_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTPCT_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTPCT_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTPS_CTL_EL1 : bits(32)

val __get_CNTPS_CTL_EL1 : bits(32) -> bits(32)

function __get_CNTPS_CTL_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val CNTPS_CTL_EL1_SysRegRead_e3bc6e5891147388 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTPS_CTL_EL1_SysRegRead_e3bc6e5891147388 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __SCR_EL3_ST : bits(1) = Slice(SCR_EL3, 11, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if HaveEL(EL3) & __SCR_EL3_NS == 0b0 then {
            if __SCR_EL3_ST == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CNTPS_CTL_EL1(CNTPS_CTL_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTPS_CTL_EL1(CNTPS_CTL_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTPS_CVAL_EL1 : bits(64)

val CNTPS_CVAL_EL1_SysRegRead_3e364bd573c45cae : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTPS_CVAL_EL1_SysRegRead_3e364bd573c45cae (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __SCR_EL3_ST : bits(1) = Slice(SCR_EL3, 11, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if HaveEL(EL3) & __SCR_EL3_NS == 0b0 then {
            if __SCR_EL3_ST == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(CNTPS_CVAL_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTPS_CVAL_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTPS_TVAL_EL1 : bits(32)

val CNTPS_TVAL_EL1_SysRegRead_0784a7de0899eff0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTPS_TVAL_EL1_SysRegRead_0784a7de0899eff0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __SCR_EL3_ST : bits(1) = Slice(SCR_EL3, 11, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if HaveEL(EL3) & __SCR_EL3_NS == 0b0 then {
            if __SCR_EL3_ST == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(CNTPS_TVAL_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTPS_TVAL_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTP_CTL_EL0 : bits(32)

val __get_CNTP_CTL_EL0 : bits(32) -> bits(32)

function __get_CNTP_CTL_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val CNTP_CTL_EL02_SysRegRead_9d9930274ff7fc36 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTP_CTL_EL02_SysRegRead_9d9930274ff7fc36 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(__get_CNTP_CTL_EL0(CNTP_CTL_EL0)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CNTP_CTL_EL0(CNTP_CTL_EL0)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTP_CTL_EL0_SysRegRead_47237e002d686ac6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTP_CTL_EL0_SysRegRead_47237e002d686ac6 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PTEN : bits(1) = Slice(CNTKCTL_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PTEN : bits(1) = Slice(CNTHCTL_EL2, 11, 1);
    let __CNTHCTL_EL2_EL0PTEN : bits(1) = Slice(CNTHCTL_EL2, 9, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHPS_CTL_EL2))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(__get_CNTHP_CTL_EL2(CNTHP_CTL_EL2)))
        } else {
            return(ZeroExtend(__get_CNTP_CTL_EL0(CNTP_CTL_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTP_CTL_EL0(CNTP_CTL_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHPS_CTL_EL2))
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(__get_CNTHP_CTL_EL2(CNTHP_CTL_EL2)))
        } else {
            return(ZeroExtend(__get_CNTP_CTL_EL0(CNTP_CTL_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTP_CTL_EL0(CNTP_CTL_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTP_CVAL_EL0 : bits(64)

val CNTP_CVAL_EL02_SysRegRead_8377305437cbebb4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTP_CVAL_EL02_SysRegRead_8377305437cbebb4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(CNTP_CVAL_EL0)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(CNTP_CVAL_EL0)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTP_CVAL_EL0_SysRegRead_4db28ae745612584 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTP_CVAL_EL0_SysRegRead_4db28ae745612584 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PTEN : bits(1) = Slice(CNTKCTL_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PTEN : bits(1) = Slice(CNTHCTL_EL2, 11, 1);
    let __CNTHCTL_EL2_EL0PTEN : bits(1) = Slice(CNTHCTL_EL2, 9, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            return(CNTHPS_CVAL_EL2)
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            return(CNTHP_CVAL_EL2)
        } else {
            return(CNTP_CVAL_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTP_CVAL_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            return(CNTHPS_CVAL_EL2)
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            return(CNTHP_CVAL_EL2)
        } else {
            return(CNTP_CVAL_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTP_CVAL_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTP_TVAL_EL0 : bits(32)

val CNTP_TVAL_EL02_SysRegRead_6539005e4eb68283 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTP_TVAL_EL02_SysRegRead_6539005e4eb68283 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(CNTP_TVAL_EL0))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(CNTP_TVAL_EL0))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTP_TVAL_EL0_SysRegRead_54cebb7fbc71b9db : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTP_TVAL_EL0_SysRegRead_54cebb7fbc71b9db (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PTEN : bits(1) = Slice(CNTKCTL_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PTEN : bits(1) = Slice(CNTHCTL_EL2, 11, 1);
    let __CNTHCTL_EL2_EL0PTEN : bits(1) = Slice(CNTHCTL_EL2, 9, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHPS_TVAL_EL2))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(CNTHP_TVAL_EL2))
        } else {
            return(ZeroExtend(CNTP_TVAL_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTP_TVAL_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHPS_TVAL_EL2))
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(CNTHP_TVAL_EL2))
        } else {
            return(ZeroExtend(CNTP_TVAL_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTP_TVAL_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTVCT_EL0 : bits(64)

val CNTVCT_EL0_SysRegRead_cd7c8aebed2715e6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTVCT_EL0_SysRegRead_cd7c8aebed2715e6 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VCTEN : bits(1) = Slice(CNTKCTL_EL1, 1, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VCTEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    if __PSTATE_EL == EL0 then {
        if ((HaveCapabilitiesExt() & Slice(CCTLR_EL0, 6, 1) == 0b0) & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VCTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VCTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTVCT_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if ((HaveCapabilitiesExt() & Slice(CCTLR_EL1, 6, 1) == 0b0) & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTVCT_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if ((HaveCapabilitiesExt() & Slice(CCTLR_EL2, 6, 1) == 0b0) & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTVCT_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if ((HaveCapabilitiesExt() & Slice(CCTLR_EL3, 6, 1) == 0b0) & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTVCT_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTVOFF_EL2 : bits(64)

val CNTVOFF_EL2_SysRegRead_5ca7336b54f14c06 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTVOFF_EL2_SysRegRead_5ca7336b54f14c06 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTVOFF_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTVOFF_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTV_CTL_EL0 : bits(32)

val __get_CNTV_CTL_EL0 : bits(32) -> bits(32)

function __get_CNTV_CTL_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val CNTV_CTL_EL02_SysRegRead_4188a8e2bc5c07aa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTV_CTL_EL02_SysRegRead_4188a8e2bc5c07aa (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(__get_CNTV_CTL_EL0(CNTV_CTL_EL0)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CNTV_CTL_EL0(CNTV_CTL_EL0)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTV_CTL_EL0_SysRegRead_bcb2d1b80bdb9c23 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTV_CTL_EL0_SysRegRead_bcb2d1b80bdb9c23 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VTEN : bits(1) = Slice(CNTKCTL_EL1, 8, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VTEN : bits(1) = Slice(CNTHCTL_EL2, 8, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHVS_CTL_EL2))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(__get_CNTHV_CTL_EL2(CNTHV_CTL_EL2)))
        } else {
            return(ZeroExtend(__get_CNTV_CTL_EL0(CNTV_CTL_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_CNTV_CTL_EL0(CNTV_CTL_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHVS_CTL_EL2))
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(__get_CNTHV_CTL_EL2(CNTHV_CTL_EL2)))
        } else {
            return(ZeroExtend(__get_CNTV_CTL_EL0(CNTV_CTL_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CNTV_CTL_EL0(CNTV_CTL_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTV_CVAL_EL0 : bits(64)

val CNTV_CVAL_EL02_SysRegRead_abd2b9f314cb85b2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTV_CVAL_EL02_SysRegRead_abd2b9f314cb85b2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(CNTV_CVAL_EL0)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(CNTV_CVAL_EL0)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTV_CVAL_EL0_SysRegRead_54d5eb0bec99456f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTV_CVAL_EL0_SysRegRead_54d5eb0bec99456f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VTEN : bits(1) = Slice(CNTKCTL_EL1, 8, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VTEN : bits(1) = Slice(CNTHCTL_EL2, 8, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            return(CNTHVS_CVAL_EL2)
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            return(CNTHV_CVAL_EL2)
        } else {
            return(CNTV_CVAL_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(CNTV_CVAL_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            return(CNTHVS_CVAL_EL2)
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            return(CNTHV_CVAL_EL2)
        } else {
            return(CNTV_CVAL_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(CNTV_CVAL_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register CNTV_TVAL_EL0 : bits(32)

val CNTV_TVAL_EL02_SysRegRead_f904ccdf39aea128 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTV_TVAL_EL02_SysRegRead_f904ccdf39aea128 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(CNTV_TVAL_EL0))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(CNTV_TVAL_EL0))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CNTV_TVAL_EL0_SysRegRead_919e73a694090e48 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CNTV_TVAL_EL0_SysRegRead_919e73a694090e48 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VTEN : bits(1) = Slice(CNTKCTL_EL1, 8, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VTEN : bits(1) = Slice(CNTHCTL_EL2, 8, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHVS_TVAL_EL2))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(CNTHV_TVAL_EL2))
        } else {
            return(ZeroExtend(CNTV_TVAL_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CNTV_TVAL_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            return(ZeroExtend(CNTHVS_TVAL_EL2))
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            return(ZeroExtend(CNTHV_TVAL_EL2))
        } else {
            return(ZeroExtend(CNTV_TVAL_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CNTV_TVAL_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CONTEXTIDR_EL1 : bits(32)

val CONTEXTIDR_EL12_SysRegRead_2aa676fc0cfd631b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CONTEXTIDR_EL12_SysRegRead_2aa676fc0cfd631b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(CONTEXTIDR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(CONTEXTIDR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CONTEXTIDR_EL2 : bits(32)

val CONTEXTIDR_EL1_SysRegRead_fa54232c55ea14e3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CONTEXTIDR_EL1_SysRegRead_fa54232c55ea14e3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CONTEXTIDR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(CONTEXTIDR_EL2))
        } else {
            return(ZeroExtend(CONTEXTIDR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CONTEXTIDR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CONTEXTIDR_EL2_SysRegRead_f7bf9114ce3113a6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CONTEXTIDR_EL2_SysRegRead_f7bf9114ce3113a6 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(CONTEXTIDR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(CONTEXTIDR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CPACR_EL1 : bits(32) -> bits(32)

function __get_CPACR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 0, 0b0000000000000000);
    val_name = SetSlice(6, val_name, 22, 0b000000);
    val_name = SetSlice(3, val_name, 29, 0b000);
    return(val_name)
}

val CPACR_EL12_SysRegRead_0f7867518c4e8e99 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CPACR_EL12_SysRegRead_0f7867518c4e8e99 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL3_TCPAC : bits(1) = Slice(CPTR_EL3, 31, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CPACR_EL1(CPACR_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_CPACR_EL1(CPACR_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CPTR_EL2 : bits(32) -> bits(32)

function __get_CPTR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 11, 0b0);
    val_name = SetSlice(2, val_name, 14, 0b00);
    val_name = SetSlice(6, val_name, 22, 0b000000);
    val_name = SetSlice(2, val_name, 29, 0b00);
    return(val_name)
}

val CPACR_EL1_SysRegRead_63b8f196f3ebba22 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CPACR_EL1_SysRegRead_63b8f196f3ebba22 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL2_TCPAC : bits(1) = Slice(CPTR_EL2, 31, 1);
    let __CPTR_EL3_TCPAC : bits(1) = Slice(CPTR_EL3, 31, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __CPTR_EL2_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CPACR_EL1(CPACR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_CPTR_EL2(CPTR_EL2)))
        } else {
            return(ZeroExtend(__get_CPACR_EL1(CPACR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CPACR_EL1(CPACR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val CPTR_EL2_SysRegRead_d80843789adc6a43 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CPTR_EL2_SysRegRead_d80843789adc6a43 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_TCPAC : bits(1) = Slice(CPTR_EL3, 31, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CPTR_EL2(CPTR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CPTR_EL2(CPTR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_CPTR_EL3 : bits(32) -> bits(32)

function __get_CPTR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 0, 0b00000000);
    val_name = SetSlice(9, val_name, 11, 0b000000000);
    val_name = SetSlice(10, val_name, 21, 0b0000000000);
    return(val_name)
}

val CPTR_EL3_SysRegRead_33cb1e5ec3c99661 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CPTR_EL3_SysRegRead_33cb1e5ec3c99661 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CPTR_EL3(CPTR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CSCR_EL3 : bits(32)

val __get_CSCR_EL3 : bits(32) -> bits(32)

function __get_CSCR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val CSCR_EL3_SysRegRead_3c6b19768f9cd209 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CSCR_EL3_SysRegRead_3c6b19768f9cd209 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CSCR_EL3(CSCR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CSSELR_EL1 : bits(32)

val __get_CSSELR_EL1 : bits(32) -> bits(32)

function __get_CSSELR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(28, val_name, 4, 0b0000000000000000000000000000);
    return(val_name)
}

val CSSELR_EL1_SysRegRead_102b4cddc07c9121 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CSSELR_EL1_SysRegRead_102b4cddc07c9121 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID2 : bits(1) = Slice(HCR_EL2, 17, 1);
    let __HCR_EL2_TID4 : bits(1) = Slice(HCR_EL2, 49, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID2 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID4 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CSSELR_EL1(CSSELR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_CSSELR_EL1(CSSELR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CSSELR_EL1(CSSELR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CTR_EL0 : bits(32)

val __get_CTR_EL0 : bits(32) -> bits(32)

function __get_CTR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(10, val_name, 4, 0b0000000000);
    val_name = SetSlice(2, val_name, 30, 0b10);
    return(val_name)
}

val CTR_EL0_SysRegRead_54ef8c769c3c6bba : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function CTR_EL0_SysRegRead_54ef8c769c3c6bba (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCT : bits(1) = Slice(SCTLR_EL1, 15, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TID2 : bits(1) = Slice(HCR_EL2, 17, 1);
    let __SCTLR_EL2_UCT : bits(1) = Slice(SCTLR_EL2, 15, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCT == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TID2 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CTR_EL0(CTR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID2 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_CTR_EL0(CTR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_CTR_EL0(CTR_EL0)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_CTR_EL0(CTR_EL0)))
    } else {
        return(undefined : bits(64))
    }
}

val CurrentEL_SysRegRead_ac5b30a86a6a5003 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function CurrentEL_SysRegRead_ac5b30a86a6a5003 (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if PSTATE.EL == EL1 then {
        return((Zeros(60) @ PSTATE.EL) @ Zeros(2))
    } else if PSTATE.EL == EL2 then {
        return((Zeros(60) @ PSTATE.EL) @ Zeros(2))
    } else if PSTATE.EL == EL3 then {
        return((Zeros(60) @ PSTATE.EL) @ Zeros(2))
    } else {
        return(undefined : bits(64))
    }
}

register DACR32_EL2 : bits(32)

val DACR32_EL2_SysRegRead_9571e2946627a596 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DACR32_EL2_SysRegRead_9571e2946627a596 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(DACR32_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DACR32_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val DAIF_SysRegRead_198f3b46fcf6c8f0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DAIF_SysRegRead_198f3b46fcf6c8f0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UMA : bits(1) = Slice(SCTLR_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    if __PSTATE_EL == EL0 then {
        if not_bool(ELUsingAArch32(EL1)) & (EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | __SCTLR_EL1_UMA == 0b0) then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return((Zeros(54) @ (PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F)))) @ Zeros(6))
        }
    } else if __PSTATE_EL == EL1 then {
        return((Zeros(54) @ (PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F)))) @ Zeros(6))
    } else if __PSTATE_EL == EL2 then {
        return((Zeros(54) @ (PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F)))) @ Zeros(6))
    } else if __PSTATE_EL == EL3 then {
        return((Zeros(54) @ (PSTATE.D @ (PSTATE.A @ (PSTATE.I @ PSTATE.F)))) @ Zeros(6))
    } else {
        return(undefined : bits(64))
    }
}

register DBGAUTHSTATUS_EL1 : bits(32)

register MDCR_EL2 : bits(32)

register MDCR_EL3 : bits(32)

val __get_DBGAUTHSTATUS_EL1 : bits(32) -> bits(32)

function __get_DBGAUTHSTATUS_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val DBGAUTHSTATUS_EL1_SysRegRead_6ade6e7a5265bcb7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGAUTHSTATUS_EL1_SysRegRead_6ade6e7a5265bcb7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGAUTHSTATUS_EL1(DBGAUTHSTATUS_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGAUTHSTATUS_EL1(DBGAUTHSTATUS_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGAUTHSTATUS_EL1(DBGAUTHSTATUS_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGBCR_EL1 : vector(16, inc, bits(32))

let DebugHalt_SoftwareAccess : bits(6) = 0b110011

register CDLR_EL0 : bits(129)

enum CrossTriggerIn = {
  CrossTriggerIn_CrossHalt,
  CrossTriggerIn_PMUOverflow,
  CrossTriggerIn_RSVD2,
  CrossTriggerIn_RSVD3,
  CrossTriggerIn_TraceExtOut0,
  CrossTriggerIn_TraceExtOut1,
  CrossTriggerIn_TraceExtOut2,
  CrossTriggerIn_TraceExtOut3
}

val CTI_SignalEvent : CrossTriggerIn -> unit

register DSPSR_EL0 : bits(32)

register DBGEN : signal

val ExternalInvasiveDebugEnabled : unit -> bool effect {rreg}

function ExternalInvasiveDebugEnabled () = {
    return(DBGEN == HIGH)
}

register SPIDEN : signal

val ExternalSecureInvasiveDebugEnabled : unit -> bool effect {escape, rreg}

function ExternalSecureInvasiveDebugEnabled () = {
    if not_bool(HaveEL(EL3)) & not_bool(IsSecure()) then {
        return(false)
    } else ();
    return(ExternalInvasiveDebugEnabled() & SPIDEN == HIGH)
}

val StopInstructionPrefetchAndEnableITR : unit -> unit

val UpdateEDSCRFields : unit -> unit effect {escape, rreg, undef, wreg}

function UpdateEDSCRFields () = {
    if not_bool(Halted()) then {
        EDSCR = SetSlice(2, EDSCR, 8, 0b00);
        EDSCR = SetSlice(1, EDSCR, 18, __UNKNOWN_bits(1));
        EDSCR = SetSlice(4, EDSCR, 10, 0b1111)
    } else {
        EDSCR = SetSlice(2, EDSCR, 8, PSTATE.EL);
        EDSCR = SetSlice(1, EDSCR, 18, if IsSecure() then 0b0 else 0b1);
        RW : bits(4) = undefined;
        RW[1] = Bit(if ELUsingAArch32(EL1) then 0b0 else 0b1);
        if PSTATE.EL != EL0 then {
            RW[0] = Bit([RW[1]])
        } else {
            RW[0] = Bit(if UsingAArch32() then 0b0 else 0b1)
        };
        if not_bool(HaveEL(EL2)) | HaveEL(EL3) & [SCR_GEN_read()[0]] == 0b0 then {
            RW[2] = Bit([RW[1]])
        } else {
            RW[2] = Bit(if ELUsingAArch32(EL2) then 0b0 else 0b1)
        };
        if not_bool(HaveEL(EL3)) then {
            RW[3] = Bit([RW[2]])
        } else {
            RW[3] = Bit(if ELUsingAArch32(EL3) then 0b0 else 0b1)
        };
        if [RW[3]] == 0b0 then {
            RW[2 .. 0] = __UNKNOWN_bits(3)
        } else if [RW[2]] == 0b0 then {
            RW[1 .. 0] = __UNKNOWN_bits(2)
        } else if [RW[1]] == 0b0 then {
            RW[0] = Bit(__UNKNOWN_bits(1))
        } else ();
        EDSCR = SetSlice(4, EDSCR, 10, RW)
    };
    return()
}

val Halt : bits(6) -> unit effect {escape, rreg, undef, wreg}

function Halt reason = {
    CTI_SignalEvent(CrossTriggerIn_CrossHalt);
    let preferred_restart_address : bits(64) = ThisInstrAddr(64);
    let preferred_restart_cap : bits(129) = PCC_read();
    spsr : bits(32) = GetPSRFromPSTATE();
    if UsingAArch32() then {
        spsr[21] = Bit(PSTATE.SS)
    } else ();
    CDLR_EL0 = preferred_restart_cap;
    DSPSR_EL0 = spsr;
    EDSCR = SetSlice(1, EDSCR, 24, 0b1);
    EDSCR = SetSlice(1, EDSCR, 28, 0b0);
    if IsSecure() then {
        EDSCR = SetSlice(1, EDSCR, 16, 0b0)
    } else if HaveEL(EL3) then {
        EDSCR = SetSlice(1, EDSCR, 16, if ExternalSecureInvasiveDebugEnabled() then 0b0 else 0b1)
    } else {
        assert(Slice(EDSCR, 16, 1) == 0b1)
    };
    EDSCR = SetSlice(1, EDSCR, 20, 0b0);
    if UsingAArch32() then {
        (PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(4);
        PSTATE.IT = 0b00000000;
        PSTATE.T = 0b1
    } else {
        (PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(5)
    };
    PSTATE.IL = 0b0;
    StopInstructionPrefetchAndEnableITR();
    EDSCR = SetSlice(6, EDSCR, 0, reason);
    UpdateEDSCRFields();
    return()
}

register DBGPRCR_EL1 : bits(32)

register OSDLR_EL1 : bits(32)

val DoubleLockStatus : unit -> bool effect {escape, rreg, undef}

function DoubleLockStatus () = {
    if ELUsingAArch32(EL1) then {
        Unreachable();
        return(undefined : bool)
    } else {
        return((Slice(OSDLR_EL1, 0, 1) == 0b1 & Slice(DBGPRCR_EL1, 0, 1) == 0b0) & not_bool(Halted()))
    }
}

val HaltingAllowed : unit -> bool effect {escape, rreg, undef}

function HaltingAllowed () = {
    if Halted() | DoubleLockStatus() then {
        return(false)
    } else if IsSecure() then {
        return(ExternalSecureInvasiveDebugEnabled())
    } else {
        return(ExternalInvasiveDebugEnabled())
    }
}

register OSLSR_EL1 : bits(32)

val DBGBCR_EL1_SysRegRead_2d021994672d40d3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGBCR_EL1_SysRegRead_2d021994672d40d3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGBCR_EL1[UInt(CRm[3 .. 0])]))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGBCR_EL1[UInt(CRm[3 .. 0])]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGBCR_EL1[UInt(CRm[3 .. 0])]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGBVR_EL1 : vector(16, inc, bits(64))

val DBGBVR_EL1_SysRegRead_dc4a8f61b400622f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGBVR_EL1_SysRegRead_dc4a8f61b400622f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(DBGBVR_EL1[UInt(CRm[3 .. 0])])
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(DBGBVR_EL1[UInt(CRm[3 .. 0])])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(DBGBVR_EL1[UInt(CRm[3 .. 0])])
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGCLAIMCLR_EL1 : bits(32)

val DBGCLAIMCLR_EL1_SysRegRead_72ae03c1d5f667da : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGCLAIMCLR_EL1_SysRegRead_72ae03c1d5f667da (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGCLAIMCLR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGCLAIMCLR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGCLAIMCLR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGCLAIMSET_EL1 : bits(32)

val DBGCLAIMSET_EL1_SysRegRead_8557cf3b6272a9e8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGCLAIMSET_EL1_SysRegRead_8557cf3b6272a9e8 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGCLAIMSET_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGCLAIMSET_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGCLAIMSET_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGDTRRX_EL0 : bits(32)

register MDSCR_EL1 : bits(32)

val DBGDTRRX_EL0_SysRegRead_e7b48d8296f3b86b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGDTRRX_EL0_SysRegRead_e7b48d8296f3b86b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDSCR_EL1_TDCC : bits(1) = Slice(MDSCR_EL1, 12, 1);
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if Halted() then {
        return(ZeroExtend(DBGDTRRX_EL0))
    } else if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __MDSCR_EL1_TDCC == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 27, 1) == 0b1 | (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGDTRRX_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGDTRRX_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGDTRRX_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGDTRRX_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CDBGDTR_EL0 : bits(129)

val DBGDTR_EL0_read__1 : unit -> bits(64) effect {escape, rreg, undef, wreg}

function DBGDTR_EL0_read__1 () = {
    r : bits(64) = undefined;
    r = SetSlice(64, r, 0, Slice(CDBGDTR_EL0, 0, 64));
    return(r)
}

val DBGDTR_EL0_SysRegRead_537a006eb82c59aa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGDTR_EL0_SysRegRead_537a006eb82c59aa (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDSCR_EL1_TDCC : bits(1) = Slice(MDSCR_EL1, 12, 1);
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if Halted() then {
        return(DBGDTR_EL0_read__1())
    } else if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __MDSCR_EL1_TDCC == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 27, 1) == 0b1 | (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(DBGDTR_EL0_read__1())
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(DBGDTR_EL0_read__1())
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(DBGDTR_EL0_read__1())
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(DBGDTR_EL0_read__1())
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_DBGPRCR_EL1 : bits(32) -> bits(32)

function __get_DBGPRCR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val DBGPRCR_EL1_SysRegRead_6b19d62af9619a21 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGPRCR_EL1_SysRegRead_6b19d62af9619a21 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDOSA : bits(1) = Slice(MDCR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 10, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGPRCR_EL1(DBGPRCR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGPRCR_EL1(DBGPRCR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGPRCR_EL1(DBGPRCR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGVCR32_EL2 : bits(32)

val __get_DBGVCR32_EL2 : bits(32) -> bits(32)

function __get_DBGVCR32_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 0, 0b0);
    val_name = SetSlice(1, val_name, 5, 0b0);
    val_name = SetSlice(17, val_name, 8, 0b00000000000000000);
    val_name = SetSlice(1, val_name, 29, 0b0);
    return(val_name)
}

val DBGVCR32_EL2_SysRegRead_7986b2bdf8df010d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGVCR32_EL2_SysRegRead_7986b2bdf8df010d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGVCR32_EL2(DBGVCR32_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DBGVCR32_EL2(DBGVCR32_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGWCR_EL1 : vector(16, inc, bits(32))

val DBGWCR_EL1_SysRegRead_03139d052b544b2f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGWCR_EL1_SysRegRead_03139d052b544b2f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGWCR_EL1[UInt(CRm[3 .. 0])]))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGWCR_EL1[UInt(CRm[3 .. 0])]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(DBGWCR_EL1[UInt(CRm[3 .. 0])]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register DBGWVR_EL1 : vector(16, inc, bits(64))

val DBGWVR_EL1_SysRegRead_029de1005ef34888 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DBGWVR_EL1_SysRegRead_029de1005ef34888 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(DBGWVR_EL1[UInt(CRm[3 .. 0])])
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(DBGWVR_EL1[UInt(CRm[3 .. 0])])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess);
            return(undefined : bits(64))
        } else {
            return(DBGWVR_EL1[UInt(CRm[3 .. 0])])
        }
    } else {
        return(undefined : bits(64))
    }
}

register DCZID_EL0 : bits(32)

val __get_DCZID_EL0 : bits(32) -> bits(32)

function __get_DCZID_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(27, val_name, 5, 0b000000000000000000000000000);
    return(val_name)
}

val DCZID_EL0_SysRegRead_dedd61ba7cee2913 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {rreg, undef}

function DCZID_EL0_SysRegRead_dedd61ba7cee2913 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        return(ZeroExtend(__get_DCZID_EL0(DCZID_EL0)))
    } else if __PSTATE_EL == EL1 then {
        return(ZeroExtend(__get_DCZID_EL0(DCZID_EL0)))
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_DCZID_EL0(DCZID_EL0)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_DCZID_EL0(DCZID_EL0)))
    } else {
        return(undefined : bits(64))
    }
}

register DISR_EL1 : bits(32)

register VDISR_EL2 : bits(32)

val __get_DISR_EL1 : bits(32) -> bits(32)

function __get_DISR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 25, 0b000000);
    return(val_name)
}

val __get_VDISR_EL2 : bits(32) -> bits(32)

function __get_VDISR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 25, 0b000000);
    return(val_name)
}

val DISR_EL1_SysRegRead_d06ce25101dac895 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function DISR_EL1_SysRegRead_d06ce25101dac895 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_AMO : bits(1) = Slice(HCR_EL2, 5, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_AMO == 0b1 then {
            return(ZeroExtend(__get_VDISR_EL2(VDISR_EL2)))
        } else {
            return(ZeroExtend(__get_DISR_EL1(DISR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_DISR_EL1(DISR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_DISR_EL1(DISR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val DLR_EL0_read : unit -> bits(64) effect {rreg, undef}

function DLR_EL0_read () = {
    r : bits(64) = undefined;
    r = SetSlice(64, r, 0, Slice(CDLR_EL0, 0, 64));
    return(r)
}

val DLR_EL0_SysRegRead_75b9821e3e84ec13 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function DLR_EL0_SysRegRead_75b9821e3e84ec13 (el, op0, op1, CRn, op2, CRm) = {
    if not_bool(Halted()) then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else {
        return(DLR_EL0_read())
    }
}

val __get_DSPSR_EL0 : bits(32) -> bits(32)

function __get_DSPSR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 24, 0b0);
    return(val_name)
}

val DSPSR_EL0_SysRegRead_888dc1fa37424d3d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function DSPSR_EL0_SysRegRead_888dc1fa37424d3d (el, op0, op1, CRn, op2, CRm) = {
    if not_bool(Halted()) then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else {
        return(ZeroExtend(__get_DSPSR_EL0(DSPSR_EL0)))
    }
}

val ELR_EL12_SysRegRead_e8215c0ae79859bb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function ELR_EL12_SysRegRead_e8215c0ae79859bb (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            return(ELR_EL1[63 .. 0])
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            return(ELR_EL1[63 .. 0])
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val ELR_EL1_SysRegRead_0d3f1ad1483e96c2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function ELR_EL1_SysRegRead_0d3f1ad1483e96c2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        return(ELR_EL1[63 .. 0])
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            return(ELR_EL2[63 .. 0])
        } else {
            return(ELR_EL1[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        return(ELR_EL1[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

val ELR_EL2_SysRegRead_00b4dd4251404d91 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function ELR_EL2_SysRegRead_00b4dd4251404d91 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        return(ELR_EL2[63 .. 0])
    } else if __PSTATE_EL == EL3 then {
        return(ELR_EL2[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

val ELR_EL3_SysRegRead_a7a7cd4e7e805396 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function ELR_EL3_SysRegRead_a7a7cd4e7e805396 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        return(ELR_EL3[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

register ERRIDR_EL1 : bits(32)

val __get_ERRIDR_EL1 : bits(32) -> bits(32)

function __get_ERRIDR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 16, 0b0000000000000000);
    return(val_name)
}

val ERRIDR_EL1_SysRegRead_41b56b8d34e51109 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERRIDR_EL1_SysRegRead_41b56b8d34e51109 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ERRIDR_EL1(ERRIDR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ERRIDR_EL1(ERRIDR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ERRIDR_EL1(ERRIDR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERRSELR_EL1 : bits(32)

val __get_ERRSELR_EL1 : bits(32) -> bits(32)

function __get_ERRSELR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 16, 0b0000000000000000);
    return(val_name)
}

val ERRSELR_EL1_SysRegRead_1bcf942400e8d57f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERRSELR_EL1_SysRegRead_1bcf942400e8d57f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ERRSELR_EL1(ERRSELR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ERRSELR_EL1(ERRSELR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ERRSELR_EL1(ERRSELR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERXADDR_EL1 : bits(64)

val ERXADDR_EL1_SysRegRead_7dea05bca757fc1d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERXADDR_EL1_SysRegRead_7dea05bca757fc1d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXADDR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXADDR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXADDR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERXCTLR_EL1 : bits(64)

val ERXCTLR_EL1_SysRegRead_e46ed88d092db048 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERXCTLR_EL1_SysRegRead_e46ed88d092db048 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXCTLR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXCTLR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXCTLR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERXFR_EL1 : bits(64)

val ERXFR_EL1_SysRegRead_ed2a3c237ae67a43 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERXFR_EL1_SysRegRead_ed2a3c237ae67a43 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXFR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXFR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXFR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERXMISC0_EL1 : bits(64)

val ERXMISC0_EL1_SysRegRead_a71a4de5f2444f19 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERXMISC0_EL1_SysRegRead_a71a4de5f2444f19 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXMISC0_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXMISC0_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXMISC0_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERXMISC1_EL1 : bits(64)

val ERXMISC1_EL1_SysRegRead_bda613f8058b1fd8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERXMISC1_EL1_SysRegRead_bda613f8058b1fd8 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXMISC1_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXMISC1_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXMISC1_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register ERXSTATUS_EL1 : bits(64)

val ERXSTATUS_EL1_SysRegRead_0ab2cfe6937b8b64 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ERXSTATUS_EL1_SysRegRead_0ab2cfe6937b8b64 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXSTATUS_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXSTATUS_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ERXSTATUS_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val ESR_EL12_SysRegRead_207d3805d256851a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ESR_EL12_SysRegRead_207d3805d256851a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(ZeroExtend(ESR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(ESR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val ESR_EL1_SysRegRead_4894753806397624 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ESR_EL1_SysRegRead_4894753806397624 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ESR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(ESR_EL2))
        } else {
            return(ZeroExtend(ESR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ESR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val ESR_EL2_SysRegRead_e0558cb255261414 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ESR_EL2_SysRegRead_e0558cb255261414 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ESR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ESR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val ESR_EL3_SysRegRead_e0eabec0b099e366 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ESR_EL3_SysRegRead_e0eabec0b099e366 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ESR_EL3))
        }
    } else {
        return(undefined : bits(64))
    }
}

val FAR_EL12_SysRegRead_061fecffb03f9fc5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FAR_EL12_SysRegRead_061fecffb03f9fc5 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(FAR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(FAR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val FAR_EL1_SysRegRead_136ac0cc65bd5f9d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FAR_EL1_SysRegRead_136ac0cc65bd5f9d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(FAR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(FAR_EL2)
        } else {
            return(FAR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(FAR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val FAR_EL2_SysRegRead_d686d0a5577f0aae : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FAR_EL2_SysRegRead_d686d0a5577f0aae (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(FAR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(FAR_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

val FAR_EL3_SysRegRead_d63ec2764f8ffe40 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FAR_EL3_SysRegRead_d63ec2764f8ffe40 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(FAR_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register FPCR : bits(32)

val __get_FPCR : bits(32) -> bits(32)

function __get_FPCR val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 0, 0b00000000);
    val_name = SetSlice(2, val_name, 13, 0b00);
    val_name = SetSlice(5, val_name, 27, 0b00000);
    return(val_name)
}

val FPCR_SysRegRead_4176e216195c5686 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FPCR_SysRegRead_4176e216195c5686 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_FPEN : bits(2) = Slice(CPACR_EL1, 20, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_FPEN : bits(2) = Slice(CPTR_EL2, 20, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TFP : bits(1) = Slice(CPTR_EL2, 10, 1);
    let __CPTR_EL3_TFP : bits(1) = Slice(CPTR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_FPEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x00));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x07));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_FPEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPCR(FPCR)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPCR(FPCR)))
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPCR(FPCR)))
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPCR(FPCR)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register FPEXC32_EL2 : bits(32)

val __get_FPEXC32_EL2 : bits(32) -> bits(32)

function __get_FPEXC32_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 5, 0b00);
    val_name = SetSlice(15, val_name, 11, 0b000000000000000);
    return(val_name)
}

val FPEXC32_EL2_SysRegRead_7ee503337da57806 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FPEXC32_EL2_SysRegRead_7ee503337da57806 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TFP : bits(1) = Slice(CPTR_EL2, 10, 1);
    let __CPTR_EL2_FPEN : bits(2) = Slice(CPTR_EL2, 20, 2);
    let __CPTR_EL3_TFP : bits(1) = Slice(CPTR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPEXC32_EL2(FPEXC32_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPEXC32_EL2(FPEXC32_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register FPSR : bits(32)

val __get_FPSR : bits(32) -> bits(32)

function __get_FPSR val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 5, 0b00);
    val_name = SetSlice(19, val_name, 8, 0b0000000000000000000);
    return(val_name)
}

val FPSR_SysRegRead_c1fde5c387acaca1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function FPSR_SysRegRead_c1fde5c387acaca1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_FPEN : bits(2) = Slice(CPACR_EL1, 20, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_FPEN : bits(2) = Slice(CPTR_EL2, 20, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TFP : bits(1) = Slice(CPTR_EL2, 10, 1);
    let __CPTR_EL3_TFP : bits(1) = Slice(CPTR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_FPEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x00));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x07));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_FPEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPSR(FPSR)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPSR(FPSR)))
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPSR(FPSR)))
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_FPSR(FPSR)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register HACR_EL2 : bits(64)

val HACR_EL2_SysRegRead_07bc3864e8ed8264 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function HACR_EL2_SysRegRead_07bc3864e8ed8264 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(HACR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(HACR_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_HCR_EL2 : bits(64) -> bits(64)

function __get_HCR_EL2 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(10, val_name, 39, 0b0000000000);
    val_name = SetSlice(1, val_name, 51, 0b0);
    val_name = SetSlice(8, val_name, 56, 0b00000000);
    return(val_name)
}

val HCR_EL2_SysRegRead_f76ecfdc85c5ff7c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function HCR_EL2_SysRegRead_f76ecfdc85c5ff7c (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_HCR_EL2(HCR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_HCR_EL2(HCR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_HPFAR_EL2 : bits(64) -> bits(64)

function __get_HPFAR_EL2 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(4, val_name, 0, 0b0000);
    val_name = SetSlice(20, val_name, 44, 0b00000000000000000000);
    return(val_name)
}

val HPFAR_EL2_SysRegRead_4c322cee424dff18 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function HPFAR_EL2_SysRegRead_4c322cee424dff18 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_HPFAR_EL2(HPFAR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_HPFAR_EL2(HPFAR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

register HSTR_EL2 : bits(32)

val __get_HSTR_EL2 : bits(32) -> bits(32)

function __get_HSTR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 16, 0b0000000000000000);
    return(val_name)
}

val HSTR_EL2_SysRegRead_680380b9028cf399 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function HSTR_EL2_SysRegRead_680380b9028cf399 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_HSTR_EL2(HSTR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_HSTR_EL2(HSTR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_AP0R_EL1 : vector(4, inc, bits(32))

register ICC_SRE_EL1_NS : bits(32)

register ICC_SRE_EL1_S : bits(32)

val ICC_SRE_EL1_read : unit -> bits(32) effect {escape, rreg, undef}

function ICC_SRE_EL1_read () = {
    r : bits(32) = undefined;
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_SRE_EL1_S
    } else {
        r = ICC_SRE_EL1_NS
    };
    return(r)
}

register ICC_SRE_EL2 : bits(32)

register ICC_SRE_EL3 : bits(32)

register ICH_HCR_EL2 : bits(32)

register ICV_AP0R_EL1 : vector(4, inc, bits(32))

val ICC_AP0R_EL1_SysRegRead_cac9b22dc3786a15 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_AP0R_EL1_SysRegRead_cac9b22dc3786a15 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(ICV_AP0R_EL1[UInt(op2[1 .. 0])]))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICC_AP0R_EL1[UInt(op2[1 .. 0])]))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICC_AP0R_EL1[UInt(op2[1 .. 0])]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICC_AP0R_EL1[UInt(op2[1 .. 0])]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_AP1R_EL1 : vector(4, inc, bits(32))

register ICC_AP1R_EL1_NS : vector(4, inc, bits(32))

register ICC_AP1R_EL1_S : vector(4, inc, bits(32))

register ICV_AP1R_EL1 : vector(4, inc, bits(32))

val ICC_AP1R_EL1_SysRegRead_4127418c67790ba3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_AP1R_EL1_SysRegRead_4127418c67790ba3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(ICV_AP1R_EL1[UInt(op2[1 .. 0])]))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(ICC_AP1R_EL1_S[UInt(op2[1 .. 0])]))
            } else {
                return(ZeroExtend(ICC_AP1R_EL1_NS[UInt(op2[1 .. 0])]))
            }
        } else {
            return(ZeroExtend(ICC_AP1R_EL1[UInt(op2[1 .. 0])]))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(ICC_AP1R_EL1_S[UInt(op2[1 .. 0])]))
            } else {
                return(ZeroExtend(ICC_AP1R_EL1_NS[UInt(op2[1 .. 0])]))
            }
        } else {
            return(ZeroExtend(ICC_AP1R_EL1[UInt(op2[1 .. 0])]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(ICC_AP1R_EL1_S[UInt(op2[1 .. 0])]))
            } else {
                return(ZeroExtend(ICC_AP1R_EL1_NS[UInt(op2[1 .. 0])]))
            }
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_BPR0_EL1 : bits(32)

register ICV_BPR0_EL1 : bits(32)

val __get_ICC_BPR0_EL1 : bits(32) -> bits(32)

function __get_ICC_BPR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val __get_ICV_BPR0_EL1 : bits(32) -> bits(32)

function __get_ICV_BPR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val ICC_BPR0_EL1_SysRegRead_6ada10a9051248c2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_BPR0_EL1_SysRegRead_6ada10a9051248c2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_BPR0_EL1(ICV_BPR0_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_BPR0_EL1(ICC_BPR0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_BPR0_EL1(ICC_BPR0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_BPR0_EL1(ICC_BPR0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_BPR1_EL1_NS : bits(32)

register ICC_BPR1_EL1_S : bits(32)

val ICC_BPR1_EL1_read : unit -> bits(32) effect {escape, rreg, undef}

function ICC_BPR1_EL1_read () = {
    r : bits(32) = undefined;
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_BPR1_EL1_S
    } else {
        r = ICC_BPR1_EL1_NS
    };
    return(r)
}

register ICV_BPR1_EL1 : bits(32)

val __get_ICC_BPR1_EL1 : bits(32) -> bits(32)

function __get_ICC_BPR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val __get_ICC_BPR1_EL1_NS : bits(32) -> bits(32)

function __get_ICC_BPR1_EL1_NS val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val __get_ICC_BPR1_EL1_S : bits(32) -> bits(32)

function __get_ICC_BPR1_EL1_S val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val __get_ICV_BPR1_EL1 : bits(32) -> bits(32)

function __get_ICV_BPR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val ICC_BPR1_EL1_SysRegRead_c56bf88f1b4aee37 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_BPR1_EL1_SysRegRead_c56bf88f1b4aee37 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_BPR1_EL1(ICV_BPR1_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_BPR1_EL1_S(ICC_BPR1_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_BPR1_EL1_NS(ICC_BPR1_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_BPR1_EL1(ICC_BPR1_EL1_read())))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_BPR1_EL1_S(ICC_BPR1_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_BPR1_EL1_NS(ICC_BPR1_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_BPR1_EL1(ICC_BPR1_EL1_read())))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_BPR1_EL1_S(ICC_BPR1_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_BPR1_EL1_NS(ICC_BPR1_EL1_NS)))
            }
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_CTLR_EL1_NS : bits(32)

register ICC_CTLR_EL1_S : bits(32)

val ICC_CTLR_EL1_read : unit -> bits(32) effect {escape, rreg, undef}

function ICC_CTLR_EL1_read () = {
    r : bits(32) = undefined;
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_CTLR_EL1_S
    } else {
        r = ICC_CTLR_EL1_NS
    };
    return(r)
}

register ICV_CTLR_EL1 : bits(32)

val __get_ICC_CTLR_EL1 : bits(32) -> bits(32)

function __get_ICC_CTLR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 2, 0b0000);
    val_name = SetSlice(1, val_name, 7, 0b0);
    val_name = SetSlice(2, val_name, 16, 0b00);
    val_name = SetSlice(12, val_name, 20, 0b000000000000);
    return(val_name)
}

val __get_ICC_CTLR_EL1_NS : bits(32) -> bits(32)

function __get_ICC_CTLR_EL1_NS val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 2, 0b0000);
    val_name = SetSlice(1, val_name, 7, 0b0);
    val_name = SetSlice(2, val_name, 16, 0b00);
    val_name = SetSlice(12, val_name, 20, 0b000000000000);
    return(val_name)
}

val __get_ICC_CTLR_EL1_S : bits(32) -> bits(32)

function __get_ICC_CTLR_EL1_S val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 2, 0b0000);
    val_name = SetSlice(1, val_name, 7, 0b0);
    val_name = SetSlice(2, val_name, 16, 0b00);
    val_name = SetSlice(12, val_name, 20, 0b000000000000);
    return(val_name)
}

val __get_ICV_CTLR_EL1 : bits(32) -> bits(32)

function __get_ICV_CTLR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 2, 0b000000);
    val_name = SetSlice(2, val_name, 16, 0b00);
    val_name = SetSlice(12, val_name, 20, 0b000000000000);
    return(val_name)
}

val ICC_CTLR_EL1_SysRegRead_5754830bf787a1e2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_CTLR_EL1_SysRegRead_5754830bf787a1e2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_CTLR_EL1(ICV_CTLR_EL1)))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_CTLR_EL1(ICV_CTLR_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_CTLR_EL1_S(ICC_CTLR_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_CTLR_EL1_NS(ICC_CTLR_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_CTLR_EL1(ICC_CTLR_EL1_read())))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_CTLR_EL1_S(ICC_CTLR_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_CTLR_EL1_NS(ICC_CTLR_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_CTLR_EL1(ICC_CTLR_EL1_read())))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_CTLR_EL1_S(ICC_CTLR_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_CTLR_EL1_NS(ICC_CTLR_EL1_NS)))
            }
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_CTLR_EL3 : bits(32)

val __get_ICC_CTLR_EL3 : bits(32) -> bits(32)

function __get_ICC_CTLR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 7, 0b0);
    val_name = SetSlice(1, val_name, 16, 0b0);
    val_name = SetSlice(12, val_name, 20, 0b000000000000);
    return(val_name)
}

val ICC_CTLR_EL3_SysRegRead_aba1771445e9d51b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_CTLR_EL3_SysRegRead_aba1771445e9d51b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_CTLR_EL3(ICC_CTLR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_HPPIR0_EL1 : bits(32)

register ICV_HPPIR0_EL1 : bits(32)

val __get_ICC_HPPIR0_EL1 : bits(32) -> bits(32)

function __get_ICC_HPPIR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val __get_ICV_HPPIR0_EL1 : bits(32) -> bits(32)

function __get_ICV_HPPIR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val ICC_HPPIR0_EL1_SysRegRead_221f9a6f32464de4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_HPPIR0_EL1_SysRegRead_221f9a6f32464de4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_HPPIR0_EL1(ICV_HPPIR0_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_HPPIR0_EL1(ICC_HPPIR0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_HPPIR0_EL1(ICC_HPPIR0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_HPPIR0_EL1(ICC_HPPIR0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_HPPIR1_EL1 : bits(32)

register ICV_HPPIR1_EL1 : bits(32)

val __get_ICC_HPPIR1_EL1 : bits(32) -> bits(32)

function __get_ICC_HPPIR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val __get_ICV_HPPIR1_EL1 : bits(32) -> bits(32)

function __get_ICV_HPPIR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val ICC_HPPIR1_EL1_SysRegRead_88ed0889f7d5a37a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_HPPIR1_EL1_SysRegRead_88ed0889f7d5a37a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_HPPIR1_EL1(ICV_HPPIR1_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_HPPIR1_EL1(ICC_HPPIR1_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_HPPIR1_EL1(ICC_HPPIR1_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_HPPIR1_EL1(ICC_HPPIR1_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_IAR0_EL1 : bits(32)

register ICV_IAR0_EL1 : bits(32)

val __get_ICC_IAR0_EL1 : bits(32) -> bits(32)

function __get_ICC_IAR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val __get_ICV_IAR0_EL1 : bits(32) -> bits(32)

function __get_ICV_IAR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val ICC_IAR0_EL1_SysRegRead_dcfaf70befc09037 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_IAR0_EL1_SysRegRead_dcfaf70befc09037 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_IAR0_EL1(ICV_IAR0_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IAR0_EL1(ICC_IAR0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IAR0_EL1(ICC_IAR0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IAR0_EL1(ICC_IAR0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_IAR1_EL1 : bits(32)

register ICV_IAR1_EL1 : bits(32)

val __get_ICC_IAR1_EL1 : bits(32) -> bits(32)

function __get_ICC_IAR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val __get_ICV_IAR1_EL1 : bits(32) -> bits(32)

function __get_ICV_IAR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val ICC_IAR1_EL1_SysRegRead_9f370ba68fd3e44f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_IAR1_EL1_SysRegRead_9f370ba68fd3e44f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_IAR1_EL1(ICV_IAR1_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IAR1_EL1(ICC_IAR1_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IAR1_EL1(ICC_IAR1_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IAR1_EL1(ICC_IAR1_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_IGRPEN0_EL1 : bits(32)

register ICV_IGRPEN0_EL1 : bits(32)

val __get_ICC_IGRPEN0_EL1 : bits(32) -> bits(32)

function __get_ICC_IGRPEN0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val __get_ICV_IGRPEN0_EL1 : bits(32) -> bits(32)

function __get_ICV_IGRPEN0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val ICC_IGRPEN0_EL1_SysRegRead_e575448f3c7e7a94 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_IGRPEN0_EL1_SysRegRead_e575448f3c7e7a94 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_IGRPEN0_EL1(ICV_IGRPEN0_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IGRPEN0_EL1(ICC_IGRPEN0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IGRPEN0_EL1(ICC_IGRPEN0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IGRPEN0_EL1(ICC_IGRPEN0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_IGRPEN1_EL1_NS : bits(32)

register ICC_IGRPEN1_EL1_S : bits(32)

val ICC_IGRPEN1_EL1_read : unit -> bits(32) effect {escape, rreg, undef}

function ICC_IGRPEN1_EL1_read () = {
    r : bits(32) = undefined;
    if ELUsingAArch32(EL3) & IsSecure() then {
        r = ICC_IGRPEN1_EL1_S
    } else {
        r = ICC_IGRPEN1_EL1_NS
    };
    return(r)
}

register ICV_IGRPEN1_EL1 : bits(32)

val __get_ICC_IGRPEN1_EL1 : bits(32) -> bits(32)

function __get_ICC_IGRPEN1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val __get_ICC_IGRPEN1_EL1_NS : bits(32) -> bits(32)

function __get_ICC_IGRPEN1_EL1_NS val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val __get_ICC_IGRPEN1_EL1_S : bits(32) -> bits(32)

function __get_ICC_IGRPEN1_EL1_S val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val __get_ICV_IGRPEN1_EL1 : bits(32) -> bits(32)

function __get_ICV_IGRPEN1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val ICC_IGRPEN1_EL1_SysRegRead_3cfd0733ef9b6efa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_IGRPEN1_EL1_SysRegRead_3cfd0733ef9b6efa (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_IGRPEN1_EL1(ICV_IGRPEN1_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_IGRPEN1_EL1_S(ICC_IGRPEN1_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_IGRPEN1_EL1_NS(ICC_IGRPEN1_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_IGRPEN1_EL1(ICC_IGRPEN1_EL1_read())))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_IGRPEN1_EL1_S(ICC_IGRPEN1_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_IGRPEN1_EL1_NS(ICC_IGRPEN1_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_IGRPEN1_EL1(ICC_IGRPEN1_EL1_read())))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_IGRPEN1_EL1_S(ICC_IGRPEN1_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_IGRPEN1_EL1_NS(ICC_IGRPEN1_EL1_NS)))
            }
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_IGRPEN1_EL3 : bits(32)

val __get_ICC_IGRPEN1_EL3 : bits(32) -> bits(32)

function __get_ICC_IGRPEN1_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(30, val_name, 2, 0b000000000000000000000000000000);
    return(val_name)
}

val ICC_IGRPEN1_EL3_SysRegRead_d192d252016b4c8d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_IGRPEN1_EL3_SysRegRead_d192d252016b4c8d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_IGRPEN1_EL3(ICC_IGRPEN1_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_PMR_EL1 : bits(32)

register ICV_PMR_EL1 : bits(32)

val __get_ICC_PMR_EL1 : bits(32) -> bits(32)

function __get_ICC_PMR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val __get_ICV_PMR_EL1 : bits(32) -> bits(32)

function __get_ICV_PMR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val ICC_PMR_EL1_SysRegRead_4ab2c9427488fbf4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_PMR_EL1_SysRegRead_4ab2c9427488fbf4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_PMR_EL1(ICV_PMR_EL1)))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_PMR_EL1(ICV_PMR_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_PMR_EL1(ICC_PMR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_PMR_EL1(ICC_PMR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_PMR_EL1(ICC_PMR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICC_RPR_EL1 : bits(32)

register ICV_RPR_EL1 : bits(32)

val __get_ICC_RPR_EL1 : bits(32) -> bits(32)

function __get_ICC_RPR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val __get_ICV_RPR_EL1 : bits(32) -> bits(32)

function __get_ICV_RPR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val ICC_RPR_EL1_SysRegRead_bea9edc41b26aab0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_RPR_EL1_SysRegRead_bea9edc41b26aab0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            return(ZeroExtend(__get_ICV_RPR_EL1(ICV_RPR_EL1)))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            return(ZeroExtend(__get_ICV_RPR_EL1(ICV_RPR_EL1)))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_RPR_EL1(ICC_RPR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_RPR_EL1(ICC_RPR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_RPR_EL1(ICC_RPR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_ICC_SRE_EL1 : bits(32) -> bits(32)

function __get_ICC_SRE_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val __get_ICC_SRE_EL1_NS : bits(32) -> bits(32)

function __get_ICC_SRE_EL1_NS val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val __get_ICC_SRE_EL1_S : bits(32) -> bits(32)

function __get_ICC_SRE_EL1_S val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 3, 0b00000000000000000000000000000);
    return(val_name)
}

val ICC_SRE_EL1_SysRegRead_7cf0aa9fc619dea4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_SRE_EL1_SysRegRead_7cf0aa9fc619dea4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_Enable : bits(1) = Slice(ICC_SRE_EL2, 3, 1);
    let __ICC_SRE_EL3_Enable : bits(1) = Slice(ICC_SRE_EL3, 3, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICC_SRE_EL2_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __ICC_SRE_EL3_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_SRE_EL1_S(ICC_SRE_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_SRE_EL1_NS(ICC_SRE_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_SRE_EL1(ICC_SRE_EL1_read())))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __ICC_SRE_EL3_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_SRE_EL1_S(ICC_SRE_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_SRE_EL1_NS(ICC_SRE_EL1_NS)))
            }
        } else {
            return(ZeroExtend(__get_ICC_SRE_EL1(ICC_SRE_EL1_read())))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                return(ZeroExtend(__get_ICC_SRE_EL1_S(ICC_SRE_EL1_S)))
            } else {
                return(ZeroExtend(__get_ICC_SRE_EL1_NS(ICC_SRE_EL1_NS)))
            }
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_ICC_SRE_EL2 : bits(32) -> bits(32)

function __get_ICC_SRE_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(28, val_name, 4, 0b0000000000000000000000000000);
    return(val_name)
}

val ICC_SRE_EL2_SysRegRead_35c9349812c986fe : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_SRE_EL2_SysRegRead_35c9349812c986fe (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL3_Enable : bits(1) = Slice(ICC_SRE_EL3, 3, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __ICC_SRE_EL3_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_SRE_EL2(ICC_SRE_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_SRE_EL2(ICC_SRE_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_ICC_SRE_EL3 : bits(32) -> bits(32)

function __get_ICC_SRE_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(28, val_name, 4, 0b0000000000000000000000000000);
    return(val_name)
}

val ICC_SRE_EL3_SysRegRead_c7d421022a5f589d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICC_SRE_EL3_SysRegRead_c7d421022a5f589d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICC_SRE_EL3(ICC_SRE_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_AP0R_EL2 : vector(4, inc, bits(32))

val ICH_AP0R_EL2_SysRegRead_a38114229330a389 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_AP0R_EL2_SysRegRead_a38114229330a389 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICH_AP0R_EL2[UInt(op2[1 .. 0])]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICH_AP0R_EL2[UInt(op2[1 .. 0])]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_AP1R_EL2 : vector(4, inc, bits(32))

val ICH_AP1R_EL2_SysRegRead_3ef1256520a6f18e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_AP1R_EL2_SysRegRead_3ef1256520a6f18e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICH_AP1R_EL2[UInt(op2[1 .. 0])]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ICH_AP1R_EL2[UInt(op2[1 .. 0])]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_EISR_EL2 : bits(32)

val __get_ICH_EISR_EL2 : bits(32) -> bits(32)

function __get_ICH_EISR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 16, 0b0000000000000000);
    return(val_name)
}

val ICH_EISR_EL2_SysRegRead_a45d99ec0ef64804 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_EISR_EL2_SysRegRead_a45d99ec0ef64804 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_EISR_EL2(ICH_EISR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_EISR_EL2(ICH_EISR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_ELRSR_EL2 : bits(32)

val __get_ICH_ELRSR_EL2 : bits(32) -> bits(32)

function __get_ICH_ELRSR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 16, 0b0000000000000000);
    return(val_name)
}

val ICH_ELRSR_EL2_SysRegRead_93859a236e9efe6d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_ELRSR_EL2_SysRegRead_93859a236e9efe6d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_ELRSR_EL2(ICH_ELRSR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_ELRSR_EL2(ICH_ELRSR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_ICH_HCR_EL2 : bits(32) -> bits(32)

function __get_ICH_HCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 8, 0b00);
    val_name = SetSlice(12, val_name, 15, 0b000000000000);
    return(val_name)
}

val ICH_HCR_EL2_SysRegRead_bd436f3e91661e3b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_HCR_EL2_SysRegRead_bd436f3e91661e3b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_HCR_EL2(ICH_HCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_HCR_EL2(ICH_HCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_LR_EL2 : vector(16, inc, bits(64))

val ICH_LR_EL2_SysRegRead_f9d8d38c7064e389 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_LR_EL2_SysRegRead_f9d8d38c7064e389 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ICH_LR_EL2[UInt([CRm[0]] @ op2[2 .. 0])])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ICH_LR_EL2[UInt([CRm[0]] @ op2[2 .. 0])])
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_MISR_EL2 : bits(32)

val __get_ICH_MISR_EL2 : bits(32) -> bits(32)

function __get_ICH_MISR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val ICH_MISR_EL2_SysRegRead_4e46f86d49bd21cd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_MISR_EL2_SysRegRead_4e46f86d49bd21cd (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_MISR_EL2(ICH_MISR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_MISR_EL2(ICH_MISR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_VMCR_EL2 : bits(32)

val __get_ICH_VMCR_EL2 : bits(32) -> bits(32)

function __get_ICH_VMCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 5, 0b0000);
    val_name = SetSlice(8, val_name, 10, 0b00000000);
    return(val_name)
}

val ICH_VMCR_EL2_SysRegRead_3c019711ec735507 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_VMCR_EL2_SysRegRead_3c019711ec735507 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_VMCR_EL2(ICH_VMCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_VMCR_EL2(ICH_VMCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ICH_VTR_EL2 : bits(32)

val __get_ICH_VTR_EL2 : bits(32) -> bits(32)

function __get_ICH_VTR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(14, val_name, 5, 0b00000000000000);
    return(val_name)
}

val ICH_VTR_EL2_SysRegRead_2ed82d00af03b344 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ICH_VTR_EL2_SysRegRead_2ed82d00af03b344 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_VTR_EL2(ICH_VTR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ICH_VTR_EL2(ICH_VTR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64AFR0_EL1 : bits(32)

val ID_AA64AFR0_EL1_SysRegRead_325547f3ac10431a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64AFR0_EL1_SysRegRead_325547f3ac10431a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_AA64AFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_AA64AFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_AA64AFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64AFR1_EL1 : bits(32)

val __get_ID_AA64AFR1_EL1 : bits(32) -> bits(32)

function __get_ID_AA64AFR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(32, val_name, 0, 0b00000000000000000000000000000000);
    return(val_name)
}

val ID_AA64AFR1_EL1_SysRegRead_99b67b76121ee706 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64AFR1_EL1_SysRegRead_99b67b76121ee706 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AA64AFR1_EL1(ID_AA64AFR1_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_AA64AFR1_EL1(ID_AA64AFR1_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AA64AFR1_EL1(ID_AA64AFR1_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64DFR0_EL1 : bits(64)

val __get_ID_AA64DFR0_EL1 : bits(64) -> bits(64)

function __get_ID_AA64DFR0_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(4, val_name, 16, 0b0000);
    val_name = SetSlice(4, val_name, 24, 0b0000);
    val_name = SetSlice(24, val_name, 40, 0b000000000000000000000000);
    return(val_name)
}

val ID_AA64DFR0_EL1_SysRegRead_c3e6b049dd70bbab : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64DFR0_EL1_SysRegRead_c3e6b049dd70bbab (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64DFR0_EL1(ID_AA64DFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64DFR0_EL1(ID_AA64DFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64DFR0_EL1(ID_AA64DFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64DFR1_EL1 : bits(32)

val __get_ID_AA64DFR1_EL1 : bits(32) -> bits(32)

function __get_ID_AA64DFR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(32, val_name, 0, 0b00000000000000000000000000000000);
    return(val_name)
}

val ID_AA64DFR1_EL1_SysRegRead_2f066031859d7035 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64DFR1_EL1_SysRegRead_2f066031859d7035 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AA64DFR1_EL1(ID_AA64DFR1_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_AA64DFR1_EL1(ID_AA64DFR1_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AA64DFR1_EL1(ID_AA64DFR1_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64ISAR0_EL1 : bits(64)

val __get_ID_AA64ISAR0_EL1 : bits(64) -> bits(64)

function __get_ID_AA64ISAR0_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(4, val_name, 0, 0b0000);
    val_name = SetSlice(4, val_name, 24, 0b0000);
    val_name = SetSlice(8, val_name, 56, 0b00000000);
    return(val_name)
}

val ID_AA64ISAR0_EL1_SysRegRead_d35f255c04eaab0f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64ISAR0_EL1_SysRegRead_d35f255c04eaab0f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64ISAR0_EL1(ID_AA64ISAR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64ISAR0_EL1(ID_AA64ISAR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64ISAR0_EL1(ID_AA64ISAR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64ISAR1_EL1 : bits(64)

val __get_ID_AA64ISAR1_EL1 : bits(64) -> bits(64)

function __get_ID_AA64ISAR1_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(32, val_name, 4, 0b00000000000000000000000000000000);
    val_name = SetSlice(4, val_name, 48, 0b0000);
    val_name = SetSlice(8, val_name, 56, 0b00000000);
    return(val_name)
}

val ID_AA64ISAR1_EL1_SysRegRead_1132f371c4707f61 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64ISAR1_EL1_SysRegRead_1132f371c4707f61 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64ISAR1_EL1(ID_AA64ISAR1_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64ISAR1_EL1(ID_AA64ISAR1_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64ISAR1_EL1(ID_AA64ISAR1_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64MMFR0_EL1 : bits(32)

val ID_AA64MMFR0_EL1_SysRegRead_836c46ff67ac3f3d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64MMFR0_EL1_SysRegRead_836c46ff67ac3f3d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_AA64MMFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_AA64MMFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_AA64MMFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64MMFR1_EL1 : bits(64)

val __get_ID_AA64MMFR1_EL1 : bits(64) -> bits(64)

function __get_ID_AA64MMFR1_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(4, val_name, 32, 0b0000);
    val_name = SetSlice(24, val_name, 40, 0b000000000000000000000000);
    return(val_name)
}

val ID_AA64MMFR1_EL1_SysRegRead_3abbf4d2af8dd3be : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64MMFR1_EL1_SysRegRead_3abbf4d2af8dd3be (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64MMFR1_EL1(ID_AA64MMFR1_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64MMFR1_EL1(ID_AA64MMFR1_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64MMFR1_EL1(ID_AA64MMFR1_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64MMFR2_EL1 : bits(64)

val __get_ID_AA64MMFR2_EL1 : bits(64) -> bits(64)

function __get_ID_AA64MMFR2_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(36, val_name, 20, 0b000000000000000000000000000000000000);
    val_name = SetSlice(4, val_name, 60, 0b0000);
    return(val_name)
}

val ID_AA64MMFR2_EL1_SysRegRead_1443648da3ca79dd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64MMFR2_EL1_SysRegRead_1443648da3ca79dd (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (not_bool(IsZero(ID_AA64MMFR2_EL1)) | __IMPDEF_boolean("ID_AA64MMFR2 trapped by __HCR_EL2_TID3"))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64MMFR2_EL1(ID_AA64MMFR2_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64MMFR2_EL1(ID_AA64MMFR2_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64MMFR2_EL1(ID_AA64MMFR2_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64PFR0_EL1 : bits(64)

val __get_ID_AA64PFR0_EL1 : bits(64) -> bits(64)

function __get_ID_AA64PFR0_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(4, val_name, 36, 0b0000);
    val_name = SetSlice(20, val_name, 44, 0b00000000000000000000);
    return(val_name)
}

val ID_AA64PFR0_EL1_SysRegRead_fe78f914579c8717 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64PFR0_EL1_SysRegRead_fe78f914579c8717 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64PFR0_EL1(ID_AA64PFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64PFR0_EL1(ID_AA64PFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64PFR0_EL1(ID_AA64PFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64PFR1_EL1 : bits(32)

val __get_ID_AA64PFR1_EL1 : bits(32) -> bits(32)

function __get_ID_AA64PFR1_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(20, val_name, 0, 0b00000000000000000000);
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val ID_AA64PFR1_EL1_SysRegRead_3be470f3d1bff138 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64PFR1_EL1_SysRegRead_3be470f3d1bff138 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AA64PFR1_EL1(ID_AA64PFR1_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_AA64PFR1_EL1(ID_AA64PFR1_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AA64PFR1_EL1(ID_AA64PFR1_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AA64ZFR0_EL1 : bits(64)

val __get_ID_AA64ZFR0_EL1 : bits(64) -> bits(64)

function __get_ID_AA64ZFR0_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(16, val_name, 4, 0b0000000000000000);
    val_name = SetSlice(20, val_name, 24, 0b00000000000000000000);
    val_name = SetSlice(4, val_name, 48, 0b0000);
    val_name = SetSlice(4, val_name, 60, 0b0000);
    return(val_name)
}

val ID_AA64ZFR0_EL1_SysRegRead_70425f5143f66c9f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AA64ZFR0_EL1_SysRegRead_70425f5143f66c9f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (not_bool(IsZero(ID_AA64ZFR0_EL1)) | __IMPDEF_boolean("ID_AA64ZFR0_EL1 trapped by __HCR_EL2_TID3"))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64ZFR0_EL1(ID_AA64ZFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_ID_AA64ZFR0_EL1(ID_AA64ZFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_ID_AA64ZFR0_EL1(ID_AA64ZFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_AFR0_EL1 : bits(32)

val __get_ID_AFR0_EL1 : bits(32) -> bits(32)

function __get_ID_AFR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(16, val_name, 16, 0b0000000000000000);
    return(val_name)
}

val ID_AFR0_EL1_SysRegRead_019e5ec822653217 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_AFR0_EL1_SysRegRead_019e5ec822653217 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AFR0_EL1(ID_AFR0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_AFR0_EL1(ID_AFR0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_AFR0_EL1(ID_AFR0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_DFR0_EL1 : bits(32)

val ID_DFR0_EL1_SysRegRead_12146217191b4fee : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_DFR0_EL1_SysRegRead_12146217191b4fee (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_DFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_DFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_DFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR0_EL1 : bits(32)

val __get_ID_ISAR0_EL1 : bits(32) -> bits(32)

function __get_ID_ISAR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 28, 0b0000);
    return(val_name)
}

val ID_ISAR0_EL1_SysRegRead_4e2f04c3a26dddb3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR0_EL1_SysRegRead_4e2f04c3a26dddb3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_ISAR0_EL1(ID_ISAR0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_ISAR0_EL1(ID_ISAR0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_ISAR0_EL1(ID_ISAR0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR1_EL1 : bits(32)

val ID_ISAR1_EL1_SysRegRead_2f4500748023e22b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR1_EL1_SysRegRead_2f4500748023e22b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR1_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_ISAR1_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR1_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR2_EL1 : bits(32)

val ID_ISAR2_EL1_SysRegRead_1e8edaee6a0e9ef9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR2_EL1_SysRegRead_1e8edaee6a0e9ef9 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR2_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_ISAR2_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR2_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR3_EL1 : bits(32)

val ID_ISAR3_EL1_SysRegRead_cf9a1aae39d73bdd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR3_EL1_SysRegRead_cf9a1aae39d73bdd (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR3_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_ISAR3_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR3_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR4_EL1 : bits(32)

val ID_ISAR4_EL1_SysRegRead_9bffd9dcf4dd4ef4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR4_EL1_SysRegRead_9bffd9dcf4dd4ef4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR4_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_ISAR4_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_ISAR4_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR5_EL1 : bits(32)

val __get_ID_ISAR5_EL1 : bits(32) -> bits(32)

function __get_ID_ISAR5_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 20, 0b0000);
    val_name = SetSlice(4, val_name, 28, 0b0000);
    return(val_name)
}

val ID_ISAR5_EL1_SysRegRead_f70928ed2f55c1f0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR5_EL1_SysRegRead_f70928ed2f55c1f0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_ISAR5_EL1(ID_ISAR5_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_ISAR5_EL1(ID_ISAR5_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_ISAR5_EL1(ID_ISAR5_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_ISAR6_EL1 : bits(32)

val __get_ID_ISAR6_EL1 : bits(32) -> bits(32)

function __get_ID_ISAR6_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 0, 0b0000);
    val_name = SetSlice(4, val_name, 28, 0b0000);
    return(val_name)
}

val ID_ISAR6_EL1_SysRegRead_6ce3605912a2db6d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_ISAR6_EL1_SysRegRead_6ce3605912a2db6d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (not_bool(IsZero(ID_ISAR6_EL1)) | __IMPDEF_boolean("ID_ISAR6_EL1 trapped by __HCR_EL2_TID3"))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_ISAR6_EL1(ID_ISAR6_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_ISAR6_EL1(ID_ISAR6_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_ISAR6_EL1(ID_ISAR6_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_MMFR0_EL1 : bits(32)

val ID_MMFR0_EL1_SysRegRead_b31c5faa39841084 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_MMFR0_EL1_SysRegRead_b31c5faa39841084 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_MMFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_MMFR1_EL1 : bits(32)

val ID_MMFR1_EL1_SysRegRead_b0f4bc0d71c9af14 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_MMFR1_EL1_SysRegRead_b0f4bc0d71c9af14 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR1_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_MMFR1_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR1_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_MMFR2_EL1 : bits(32)

val ID_MMFR2_EL1_SysRegRead_b60501193094f759 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_MMFR2_EL1_SysRegRead_b60501193094f759 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR2_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_MMFR2_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR2_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_MMFR3_EL1 : bits(32)

val ID_MMFR3_EL1_SysRegRead_dc45af19c356c392 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_MMFR3_EL1_SysRegRead_dc45af19c356c392 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR3_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_MMFR3_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR3_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_MMFR4_EL1 : bits(32)

val ID_MMFR4_EL1_SysRegRead_237ae4b6fb487f3e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_MMFR4_EL1_SysRegRead_237ae4b6fb487f3e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (not_bool(IsZero(ID_MMFR4_EL1)) | __IMPDEF_boolean("ID_MMFR4_EL1 trapped by __HCR_EL2_TID3"))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR4_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_MMFR4_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_MMFR4_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_MMFR5_EL1 : bits(32)

val __get_ID_MMFR5_EL1 : bits(32) -> bits(32)

function __get_ID_MMFR5_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(28, val_name, 4, 0b0000000000000000000000000000);
    return(val_name)
}

val ID_MMFR5_EL1_SysRegRead_00dc6140c3593f6a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_MMFR5_EL1_SysRegRead_00dc6140c3593f6a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (not_bool(IsZero(ID_MMFR5_EL1)) | __IMPDEF_boolean("ID_MMFR5_EL1 trapped by __HCR_EL2_TID3"))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_MMFR5_EL1(ID_MMFR5_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_MMFR5_EL1(ID_MMFR5_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_MMFR5_EL1(ID_MMFR5_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_PFR0_EL1 : bits(32)

val __get_ID_PFR0_EL1 : bits(32) -> bits(32)

function __get_ID_PFR0_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(12, val_name, 16, 0b000000000000);
    return(val_name)
}

val ID_PFR0_EL1_SysRegRead_ab73eb91d66cfece : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_PFR0_EL1_SysRegRead_ab73eb91d66cfece (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_PFR0_EL1(ID_PFR0_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_PFR0_EL1(ID_PFR0_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_PFR0_EL1(ID_PFR0_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_PFR1_EL1 : bits(32)

val ID_PFR1_EL1_SysRegRead_264075958e26856b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_PFR1_EL1_SysRegRead_264075958e26856b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_PFR1_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(ID_PFR1_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(ID_PFR1_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ID_PFR2_EL1 : bits(32)

val __get_ID_PFR2_EL1 : bits(32) -> bits(32)

function __get_ID_PFR2_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(32, val_name, 0, 0b00000000000000000000000000000000);
    return(val_name)
}

val ID_PFR2_EL1_SysRegRead_8561b575e8dfcee0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ID_PFR2_EL1_SysRegRead_8561b575e8dfcee0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_PFR2_EL1(ID_PFR2_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ID_PFR2_EL1(ID_PFR2_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ID_PFR2_EL1(ID_PFR2_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register IFSR32_EL2 : bits(32)

val __get_IFSR32_EL2 : bits(32) -> bits(32)

function __get_IFSR32_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(3, val_name, 6, 0b000);
    val_name = SetSlice(1, val_name, 11, 0b0);
    val_name = SetSlice(3, val_name, 13, 0b000);
    val_name = SetSlice(15, val_name, 17, 0b000000000000000);
    return(val_name)
}

val IFSR32_EL2_SysRegRead_3b41290786c143ba : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function IFSR32_EL2_SysRegRead_3b41290786c143ba (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_IFSR32_EL2(IFSR32_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_IFSR32_EL2(IFSR32_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register ISR_EL1 : bits(32)

val __get_ISR_EL1 : bits(32) -> bits(32)

function __get_ISR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 0, 0b000000);
    val_name = SetSlice(23, val_name, 9, 0b00000000000000000000000);
    return(val_name)
}

val ISR_EL1_SysRegRead_41b7dbf26b89e726 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function ISR_EL1_SysRegRead_41b7dbf26b89e726 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ISR_EL1(ISR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_ISR_EL1(ISR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_ISR_EL1(ISR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register LORC_EL1 : bits(32)

val __get_LORC_EL1 : bits(32) -> bits(32)

function __get_LORC_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 1, 0b0);
    val_name = SetSlice(22, val_name, 10, 0b0000000000000000000000);
    return(val_name)
}

val LORC_EL1_SysRegRead_0067e90ee116c26f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function LORC_EL1_SysRegRead_0067e90ee116c26f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORC_EL1(LORC_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORC_EL1(LORC_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORC_EL1(LORC_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register LOREA_EL1 : bits(64)

val __get_LOREA_EL1 : bits(64) -> bits(64)

function __get_LOREA_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(16, val_name, 0, 0b0000000000000000);
    val_name = SetSlice(12, val_name, 52, 0b000000000000);
    return(val_name)
}

val LOREA_EL1_SysRegRead_ec495c3c15ed4dbe : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function LOREA_EL1_SysRegRead_ec495c3c15ed4dbe (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_LOREA_EL1(LOREA_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_LOREA_EL1(LOREA_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_LOREA_EL1(LOREA_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register LORID_EL1 : bits(32)

val __get_LORID_EL1 : bits(32) -> bits(32)

function __get_LORID_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(8, val_name, 8, 0b00000000);
    val_name = SetSlice(8, val_name, 24, 0b00000000);
    return(val_name)
}

val LORID_EL1_SysRegRead_a063108cc96d4baa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function LORID_EL1_SysRegRead_a063108cc96d4baa (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORID_EL1(LORID_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORID_EL1(LORID_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORID_EL1(LORID_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register LORN_EL1 : bits(32)

val __get_LORN_EL1 : bits(32) -> bits(32)

function __get_LORN_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val LORN_EL1_SysRegRead_da981b495b21c400 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function LORN_EL1_SysRegRead_da981b495b21c400 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORN_EL1(LORN_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORN_EL1(LORN_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_LORN_EL1(LORN_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register LORSA_EL1 : bits(64)

val __get_LORSA_EL1 : bits(64) -> bits(64)

function __get_LORSA_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(15, val_name, 1, 0b000000000000000);
    val_name = SetSlice(12, val_name, 52, 0b000000000000);
    return(val_name)
}

val LORSA_EL1_SysRegRead_cdc08dda4115abc7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function LORSA_EL1_SysRegRead_cdc08dda4115abc7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_LORSA_EL1(LORSA_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_LORSA_EL1(LORSA_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_LORSA_EL1(LORSA_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MAIR_EL1 : bits(64)

val MAIR_EL12_SysRegRead_ac3327848e47dda6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MAIR_EL12_SysRegRead_ac3327848e47dda6 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(MAIR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(MAIR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MAIR_EL2 : bits(64)

val MAIR_EL1_SysRegRead_ee00b1441fc4a50d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MAIR_EL1_SysRegRead_ee00b1441fc4a50d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MAIR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(MAIR_EL2)
        } else {
            return(MAIR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MAIR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val MAIR_EL2_SysRegRead_66c03f7cb594c1bd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MAIR_EL2_SysRegRead_66c03f7cb594c1bd (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(MAIR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MAIR_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MAIR_EL3 : bits(64)

val MAIR_EL3_SysRegRead_0eb4af28a4f9b45a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MAIR_EL3_SysRegRead_0eb4af28a4f9b45a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MAIR_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MDCCINT_EL1 : bits(32)

val __get_MDCCINT_EL1 : bits(32) -> bits(32)

function __get_MDCCINT_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(29, val_name, 0, 0b00000000000000000000000000000);
    val_name = SetSlice(1, val_name, 31, 0b0);
    return(val_name)
}

val MDCCINT_EL1_SysRegRead_12f1a0397d5a3729 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MDCCINT_EL1_SysRegRead_12f1a0397d5a3729 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCINT_EL1(MDCCINT_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCINT_EL1(MDCCINT_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCINT_EL1(MDCCINT_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MDCCSR_EL0 : bits(32)

val __get_MDCCSR_EL0 : bits(32) -> bits(32)

function __get_MDCCSR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 0, 0b00);
    val_name = SetSlice(6, val_name, 6, 0b000000);
    val_name = SetSlice(2, val_name, 13, 0b00);
    val_name = SetSlice(10, val_name, 19, 0b0000000000);
    val_name = SetSlice(1, val_name, 31, 0b0);
    return(val_name)
}

val MDCCSR_EL0_SysRegRead_1ca0d9105cd616c5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MDCCSR_EL0_SysRegRead_1ca0d9105cd616c5 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDSCR_EL1_TDCC : bits(1) = Slice(MDSCR_EL1, 12, 1);
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __MDSCR_EL1_TDCC == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 27, 1) == 0b1 | (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCSR_EL0(MDCCSR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCSR_EL0(MDCCSR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCSR_EL0(MDCCSR_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCCSR_EL0(MDCCSR_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_MDCR_EL2 : bits(32) -> bits(32)

function __get_MDCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 15, 0b00);
    val_name = SetSlice(14, val_name, 18, 0b00000000000000);
    return(val_name)
}

val MDCR_EL2_SysRegRead_f2181c815a998208 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MDCR_EL2_SysRegRead_f2181c815a998208 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCR_EL2(MDCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCR_EL2(MDCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_MDCR_EL3 : bits(32) -> bits(32)

function __get_MDCR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 0, 0b000000);
    val_name = SetSlice(2, val_name, 7, 0b00);
    val_name = SetSlice(1, val_name, 11, 0b0);
    val_name = SetSlice(2, val_name, 18, 0b00);
    val_name = SetSlice(10, val_name, 22, 0b0000000000);
    return(val_name)
}

val MDCR_EL3_SysRegRead_229d5ee95c6e9850 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MDCR_EL3_SysRegRead_229d5ee95c6e9850 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDCR_EL3(MDCR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MDRAR_EL1 : bits(64)

val __get_MDRAR_EL1 : bits(64) -> bits(64)

function __get_MDRAR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(10, val_name, 2, 0b0000000000);
    val_name = SetSlice(12, val_name, 52, 0b000000000000);
    return(val_name)
}

val MDRAR_EL1_SysRegRead_4c6f0d270d3fe56e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MDRAR_EL1_SysRegRead_4c6f0d270d3fe56e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 11, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MDRAR_EL1(MDRAR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MDRAR_EL1(MDRAR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MDRAR_EL1(MDRAR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_MDSCR_EL1 : bits(32) -> bits(32)

function __get_MDSCR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(5, val_name, 1, 0b00000);
    val_name = SetSlice(5, val_name, 7, 0b00000);
    val_name = SetSlice(3, val_name, 16, 0b000);
    val_name = SetSlice(1, val_name, 20, 0b0);
    val_name = SetSlice(2, val_name, 24, 0b00);
    val_name = SetSlice(1, val_name, 28, 0b0);
    val_name = SetSlice(1, val_name, 31, 0b0);
    return(val_name)
}

val MDSCR_EL1_SysRegRead_5184636ced539526 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MDSCR_EL1_SysRegRead_5184636ced539526 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDSCR_EL1(MDSCR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDSCR_EL1(MDSCR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MDSCR_EL1(MDSCR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MIDR_EL1 : bits(32)

register VPIDR_EL2 : bits(32)

val MIDR_EL1_SysRegRead_d49cc5f604ad167e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MIDR_EL1_SysRegRead_d49cc5f604ad167e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if EL2Enabled() & not_bool(ELUsingAArch32(EL2)) then {
            return(ZeroExtend(VPIDR_EL2))
        } else {
            return(ZeroExtend(MIDR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(MIDR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MIDR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAM0_EL1 : bits(64)

register MPAM3_EL3 : bits(64)

register _MPAM2_EL2_0_62 : bits(63)

val MPAM2_EL2_read : unit -> bits(64) effect {rreg, undef}

function MPAM2_EL2_read () = {
    r : bits(64) = undefined;
    r = SetSlice(1, r, 63, Slice(MPAM3_EL3, 63, 1));
    r = SetSlice(63, r, 0, _MPAM2_EL2_0_62);
    return(r)
}

val __get_MPAM0_EL1 : bits(64) -> bits(64)

function __get_MPAM0_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(16, val_name, 48, 0b0000000000000000);
    return(val_name)
}

val MPAM0_EL1_SysRegRead_87af318fd5c9f9f7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAM0_EL1_SysRegRead_87af318fd5c9f9f7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    let __MPAM2_EL2_TRAPMPAM0EL1 : bits(1) = Slice(MPAM2_EL2_read(), 49, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MPAM2_EL2_TRAPMPAM0EL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM0_EL1(MPAM0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM0_EL1(MPAM0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM0_EL1(MPAM0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register _MPAM1_EL1_0_62 : bits(63)

val MPAM1_EL1_read : unit -> bits(64) effect {rreg, undef}

function MPAM1_EL1_read () = {
    r : bits(64) = undefined;
    if HaveEL(EL3) then {
        r = SetSlice(1, r, 63, Slice(MPAM3_EL3, 63, 1))
    } else {
        r = SetSlice(1, r, 63, Slice(MPAM2_EL2_read(), 63, 1))
    };
    r = SetSlice(63, r, 0, _MPAM1_EL1_0_62);
    return(r)
}

val __get_MPAM1_EL1 : bits(64) -> bits(64)

function __get_MPAM1_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(15, val_name, 48, 0b000000000000000);
    return(val_name)
}

val MPAM1_EL12_SysRegRead_229a253b730e26d9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAM1_EL12_SysRegRead_229a253b730e26d9 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(__get_MPAM1_EL1(MPAM1_EL1_read()))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(__get_MPAM1_EL1(MPAM1_EL1_read()))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_MPAM2_EL2 : bits(64) -> bits(64)

function __get_MPAM2_EL2 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(13, val_name, 50, 0b0000000000000);
    return(val_name)
}

val MPAM1_EL1_SysRegRead_770ea23b87b18d99 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAM1_EL1_SysRegRead_770ea23b87b18d99 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    let __MPAM2_EL2_TRAPMPAM1EL1 : bits(1) = Slice(MPAM2_EL2_read(), 48, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MPAM2_EL2_TRAPMPAM1EL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM1_EL1(MPAM1_EL1_read()))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(__get_MPAM2_EL2(MPAM2_EL2_read()))
        } else {
            return(__get_MPAM1_EL1(MPAM1_EL1_read()))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM1_EL1(MPAM1_EL1_read()))
        }
    } else {
        return(undefined : bits(64))
    }
}

val MPAM2_EL2_SysRegRead_10b60646fb381bea : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAM2_EL2_SysRegRead_10b60646fb381bea (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM2_EL2(MPAM2_EL2_read()))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM2_EL2(MPAM2_EL2_read()))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_MPAM3_EL3 : bits(64) -> bits(64)

function __get_MPAM3_EL3 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(14, val_name, 48, 0b00000000000000);
    return(val_name)
}

val MPAM3_EL3_SysRegRead_989f38b07d8b4265 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAM3_EL3_SysRegRead_989f38b07d8b4265 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAM3_EL3(MPAM3_EL3))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMHCR_EL2 : bits(32)

val __get_MPAMHCR_EL2 : bits(32) -> bits(32)

function __get_MPAMHCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 2, 0b000000);
    val_name = SetSlice(22, val_name, 9, 0b0000000000000000000000);
    return(val_name)
}

val MPAMHCR_EL2_SysRegRead_6ee5f61be808e32e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMHCR_EL2_SysRegRead_6ee5f61be808e32e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MPAMHCR_EL2(MPAMHCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MPAMHCR_EL2(MPAMHCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMIDR_EL1 : bits(64)

val __get_MPAMIDR_EL1 : bits(64) -> bits(64)

function __get_MPAMIDR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 16, 0b0);
    val_name = SetSlice(11, val_name, 21, 0b00000000000);
    val_name = SetSlice(24, val_name, 40, 0b000000000000000000000000);
    return(val_name)
}

val MPAMIDR_EL1_SysRegRead_df4c57d831354b3c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMIDR_EL1_SysRegRead_df4c57d831354b3c (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    let __MPAMIDR_EL1_HAS_HCR : bits(1) = Slice(MPAMIDR_EL1, 17, 1);
    let __MPAMHCR_EL2_TRAP_MPAMIDR_EL1 : bits(1) = Slice(MPAMHCR_EL2, 31, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MPAMIDR_EL1_HAS_HCR == 0b1) & __MPAMHCR_EL2_TRAP_MPAMIDR_EL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAMIDR_EL1(MPAMIDR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAMIDR_EL1(MPAMIDR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPAMIDR_EL1(MPAMIDR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM0_EL2 : bits(64)

val MPAMVPM0_EL2_SysRegRead_d878a15f2ea1751d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM0_EL2_SysRegRead_d878a15f2ea1751d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM0_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM0_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM1_EL2 : bits(64)

val MPAMVPM1_EL2_SysRegRead_78ba55a3ef5fc5ba : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM1_EL2_SysRegRead_78ba55a3ef5fc5ba (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM1_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM1_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM2_EL2 : bits(64)

val MPAMVPM2_EL2_SysRegRead_590d1577b5eb780d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM2_EL2_SysRegRead_590d1577b5eb780d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM2_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM2_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM3_EL2 : bits(64)

val MPAMVPM3_EL2_SysRegRead_3d93a30deb34ea81 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM3_EL2_SysRegRead_3d93a30deb34ea81 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM3_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM3_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM4_EL2 : bits(64)

val MPAMVPM4_EL2_SysRegRead_c4fa65dba541d8f3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM4_EL2_SysRegRead_c4fa65dba541d8f3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM4_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM4_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM5_EL2 : bits(64)

val MPAMVPM5_EL2_SysRegRead_0f596cf6a35cf124 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM5_EL2_SysRegRead_0f596cf6a35cf124 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM5_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM5_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM6_EL2 : bits(64)

val MPAMVPM6_EL2_SysRegRead_c93ffeb6ea409c71 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM6_EL2_SysRegRead_c93ffeb6ea409c71 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM6_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM6_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPM7_EL2 : bits(64)

val MPAMVPM7_EL2_SysRegRead_ef19c89f1fa31f3e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPM7_EL2_SysRegRead_ef19c89f1fa31f3e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM7_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(MPAMVPM7_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPAMVPMV_EL2 : bits(32)

val MPAMVPMV_EL2_SysRegRead_6de5731367257b91 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPAMVPMV_EL2_SysRegRead_6de5731367257b91 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MPAMVPMV_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MPAMVPMV_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MPIDR_EL1 : bits(64)

register VMPIDR_EL2 : bits(64)

val __get_MPIDR_EL1 : bits(64) -> bits(64)

function __get_MPIDR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(5, val_name, 25, 0b00000);
    val_name = SetSlice(1, val_name, 31, 0b1);
    val_name = SetSlice(24, val_name, 40, 0b000000000000000000000000);
    return(val_name)
}

val __get_VMPIDR_EL2 : bits(64) -> bits(64)

function __get_VMPIDR_EL2 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(5, val_name, 25, 0b00000);
    val_name = SetSlice(1, val_name, 31, 0b1);
    val_name = SetSlice(24, val_name, 40, 0b000000000000000000000000);
    return(val_name)
}

val MPIDR_EL1_SysRegRead_1a44c237fc7e90a0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MPIDR_EL1_SysRegRead_1a44c237fc7e90a0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if EL2Enabled() & not_bool(ELUsingAArch32(EL2)) then {
            return(__get_VMPIDR_EL2(VMPIDR_EL2))
        } else {
            return(__get_MPIDR_EL1(MPIDR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_MPIDR_EL1(MPIDR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_MPIDR_EL1(MPIDR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MVFR0_EL1 : bits(32)

val MVFR0_EL1_SysRegRead_982614cb681cfbbf : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MVFR0_EL1_SysRegRead_982614cb681cfbbf (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MVFR0_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(MVFR0_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MVFR0_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MVFR1_EL1 : bits(32)

val MVFR1_EL1_SysRegRead_1964a95566ab0fcd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MVFR1_EL1_SysRegRead_1964a95566ab0fcd (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MVFR1_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(MVFR1_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(MVFR1_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register MVFR2_EL1 : bits(32)

val __get_MVFR2_EL1 : bits(32) -> bits(32)

function __get_MVFR2_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val MVFR2_EL1_SysRegRead_f6245ffc535897f2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function MVFR2_EL1_SysRegRead_f6245ffc535897f2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID3 : bits(1) = Slice(HCR_EL2, 18, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID3 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MVFR2_EL1(MVFR2_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_MVFR2_EL1(MVFR2_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_MVFR2_EL1(MVFR2_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val NZCV_SysRegRead_00499c04100376d9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {rreg, undef}

function NZCV_SysRegRead_00499c04100376d9 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        return((Zeros(32) @ (PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V)))) @ Zeros(28))
    } else if __PSTATE_EL == EL1 then {
        return((Zeros(32) @ (PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V)))) @ Zeros(28))
    } else if __PSTATE_EL == EL2 then {
        return((Zeros(32) @ (PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V)))) @ Zeros(28))
    } else if __PSTATE_EL == EL3 then {
        return((Zeros(32) @ (PSTATE.N @ (PSTATE.Z @ (PSTATE.C @ PSTATE.V)))) @ Zeros(28))
    } else {
        return(undefined : bits(64))
    }
}

val HaveDoubleLock : unit -> bool

function HaveDoubleLock () = {
    return(__IMPDEF_boolean("OS Double Lock is implemented"))
}

val __get_OSDLR_EL1 : bits(32) -> bits(32)

function __get_OSDLR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(31, val_name, 1, 0b0000000000000000000000000000000);
    return(val_name)
}

val OSDLR_EL1_SysRegRead_4cb80c508c4cced4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function OSDLR_EL1_SysRegRead_4cb80c508c4cced4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    __MDCR_EL2_TDOSA = Slice(MDCR_EL2, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 10, 1)) != 0b00) & (HaveDoubleLock() | __IMPDEF_boolean("Trapped by __MDCR_EL2_TDOSA")) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & Slice(MDCR_EL3, 10, 1) == 0b1) & (HaveDoubleLock() | __IMPDEF_boolean("Trapped by MDCR_EL3.TDOSA")) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_OSDLR_EL1(OSDLR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & Slice(MDCR_EL3, 10, 1) == 0b1) & (HaveDoubleLock() | __IMPDEF_boolean("Trapped by MDCR_EL3.TDOSA")) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_OSDLR_EL1(OSDLR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_OSDLR_EL1(OSDLR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register OSDTRRX_EL1 : bits(32)

val OSDTRRX_EL1_SysRegRead_d4eb07360bc69d28 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function OSDTRRX_EL1_SysRegRead_d4eb07360bc69d28 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSDTRRX_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSDTRRX_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSDTRRX_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register OSDTRTX_EL1 : bits(32)

val OSDTRTX_EL1_SysRegRead_008c22058272684f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function OSDTRTX_EL1_SysRegRead_008c22058272684f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSDTRTX_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSDTRTX_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSDTRTX_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register OSECCR_EL1 : bits(32)

val OSECCR_EL1_SysRegRead_264ab12a32fecc30 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function OSECCR_EL1_SysRegRead_264ab12a32fecc30 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSECCR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSECCR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(OSECCR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_OSLSR_EL1 : bits(32) -> bits(32)

function __get_OSLSR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(28, val_name, 4, 0b0000000000000000000000000000);
    return(val_name)
}

val OSLSR_EL1_SysRegRead_d99062033a35ccbf : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function OSLSR_EL1_SysRegRead_d99062033a35ccbf (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDOSA : bits(1) = Slice(MDCR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 10, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_OSLSR_EL1(OSLSR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_OSLSR_EL1(OSLSR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_OSLSR_EL1(OSLSR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val PAN_SysRegRead_36ab36abf6da91e0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function PAN_SysRegRead_36ab36abf6da91e0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        return((Zeros(41) @ PSTATE.PAN) @ Zeros(22))
    } else if __PSTATE_EL == EL2 then {
        return((Zeros(41) @ PSTATE.PAN) @ Zeros(22))
    } else if __PSTATE_EL == EL3 then {
        return((Zeros(41) @ PSTATE.PAN) @ Zeros(22))
    } else {
        return(undefined : bits(64))
    }
}

register PAR_EL1 : bits(64)

val __get_PAR_EL1 : bits(64) -> bits(64)

function __get_PAR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 11, 0b1);
    return(val_name)
}

val PAR_EL1_SysRegRead_888e7c84935ebac7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PAR_EL1_SysRegRead_888e7c84935ebac7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_PAR_EL1(PAR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_PAR_EL1(PAR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PAR_EL1(PAR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMBIDR_EL1 : bits(32)

val __get_PMBIDR_EL1 : bits(32) -> bits(32)

function __get_PMBIDR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(26, val_name, 6, 0b00000000000000000000000000);
    return(val_name)
}

val PMBIDR_EL1_SysRegRead_306c3f68e41521a3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMBIDR_EL1_SysRegRead_306c3f68e41521a3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_PMBIDR_EL1(PMBIDR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_PMBIDR_EL1(PMBIDR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMBIDR_EL1(PMBIDR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMBLIMITR_EL1 : bits(64)

val __get_PMBLIMITR_EL1 : bits(64) -> bits(64)

function __get_PMBLIMITR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(9, val_name, 3, 0b000000000);
    return(val_name)
}

val PMBLIMITR_EL1_SysRegRead_b7c18938ab0566dc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMBLIMITR_EL1_SysRegRead_b7c18938ab0566dc (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_E2PB : bits(2) = Slice(MDCR_EL2, 12, 2);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (match __MDCR_EL2_E2PB {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMBLIMITR_EL1(PMBLIMITR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMBLIMITR_EL1(PMBLIMITR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMBLIMITR_EL1(PMBLIMITR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMBPTR_EL1 : bits(64)

val PMBPTR_EL1_SysRegRead_fb82e1b6e480bd0a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMBPTR_EL1_SysRegRead_fb82e1b6e480bd0a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_E2PB : bits(2) = Slice(MDCR_EL2, 12, 2);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (match __MDCR_EL2_E2PB {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMBPTR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMBPTR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMBPTR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMBSR_EL1 : bits(32)

val __get_PMBSR_EL1 : bits(32) -> bits(32)

function __get_PMBSR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(6, val_name, 20, 0b000000);
    return(val_name)
}

val PMBSR_EL1_SysRegRead_87628bec330b9f53 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMBSR_EL1_SysRegRead_87628bec330b9f53 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_E2PB : bits(2) = Slice(MDCR_EL2, 12, 2);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (match __MDCR_EL2_E2PB {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMBSR_EL1(PMBSR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMBSR_EL1(PMBSR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMBSR_EL1(PMBSR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCCFILTR_EL0 : bits(32)

register PMUSERENR_EL0 : bits(32)

val __get_PMCCFILTR_EL0 : bits(32) -> bits(32)

function __get_PMCCFILTR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(26, val_name, 0, 0b00000000000000000000000000);
    return(val_name)
}

val PMCCFILTR_EL0_SysRegRead_349918c2333bfc1e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCCFILTR_EL0_SysRegRead_349918c2333bfc1e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCCFILTR_EL0(PMCCFILTR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCCFILTR_EL0(PMCCFILTR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCCFILTR_EL0(PMCCFILTR_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCCFILTR_EL0(PMCCFILTR_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCCNTR_EL0 : bits(64)

val PMCCNTR_EL0_SysRegRead_45fc425eff298404 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCCNTR_EL0_SysRegRead_45fc425eff298404 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & (Slice(PMUSERENR_EL0, 2, 1) @ Slice(PMUSERENR_EL0, 0, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCCNTR_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCCNTR_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCCNTR_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCCNTR_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCEID0_EL0 : bits(64)

val PMCEID0_EL0_SysRegRead_1364a10a0c913d82 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCEID0_EL0_SysRegRead_1364a10a0c913d82 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID0_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID0_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID0_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID0_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCEID1_EL0 : bits(64)

val PMCEID1_EL0_SysRegRead_2db7a3b96735d30a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCEID1_EL0_SysRegRead_2db7a3b96735d30a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID1_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID1_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID1_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(PMCEID1_EL0)
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCNTENCLR_EL0 : bits(32)

val PMCNTENCLR_EL0_SysRegRead_5ac431b885c9c5e4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCNTENCLR_EL0_SysRegRead_5ac431b885c9c5e4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENCLR_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENCLR_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENCLR_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENCLR_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCNTENSET_EL0 : bits(32)

val PMCNTENSET_EL0_SysRegRead_848c3aa603193fb7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCNTENSET_EL0_SysRegRead_848c3aa603193fb7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENSET_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENSET_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENSET_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMCNTENSET_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMCR_EL0 : bits(32)

val __get_PMCR_EL0 : bits(32) -> bits(32)

function __get_PMCR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(4, val_name, 7, 0b0000);
    return(val_name)
}

val PMCR_EL0_SysRegRead_9a03e454327a1718 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMCR_EL0_SysRegRead_9a03e454327a1718 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL2_TPMCR : bits(1) = Slice(MDCR_EL2, 5, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMCR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCR_EL0(PMCR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMCR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCR_EL0(PMCR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCR_EL0(PMCR_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMCR_EL0(PMCR_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMEVCNTR_EL0 : vector(31, inc, bits(32))

val PMEVCNTR_EL0_SysRegRead_e0380ad70bc25a0c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMEVCNTR_EL0_SysRegRead_e0380ad70bc25a0c (el, op0, op1, CRn, op2, CRm) = {
    let 'idx = UInt(CRm[1 .. 0] @ op2[2 .. 0]);
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & (Slice(PMUSERENR_EL0, 3, 1) @ Slice(PMUSERENR_EL0, 0, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVCNTR_EL0[idx]))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVCNTR_EL0[idx]))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVCNTR_EL0[idx]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVCNTR_EL0[idx]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMEVTYPER_EL0 : vector(31, inc, bits(32))

val PMEVTYPER_EL0_SysRegRead_b05172ff9d10dad4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMEVTYPER_EL0_SysRegRead_b05172ff9d10dad4 (el, op0, op1, CRn, op2, CRm) = {
    let 'idx = UInt(CRm[1 .. 0] @ op2[2 .. 0]);
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVTYPER_EL0[idx]))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVTYPER_EL0[idx]))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVTYPER_EL0[idx]))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            assert(constraint('idx < 31));
            return(ZeroExtend(PMEVTYPER_EL0[idx]))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMINTENCLR_EL1 : bits(32)

val PMINTENCLR_EL1_SysRegRead_43b8f4d9b40b2620 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMINTENCLR_EL1_SysRegRead_43b8f4d9b40b2620 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMINTENCLR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMINTENCLR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMINTENCLR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMINTENSET_EL1 : bits(32)

val PMINTENSET_EL1_SysRegRead_a3d4464c2051ff23 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMINTENSET_EL1_SysRegRead_a3d4464c2051ff23 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMINTENSET_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMINTENSET_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMINTENSET_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMOVSCLR_EL0 : bits(32)

val PMOVSCLR_EL0_SysRegRead_300e5dfb491e58fa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMOVSCLR_EL0_SysRegRead_300e5dfb491e58fa (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSCLR_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSCLR_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSCLR_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSCLR_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMOVSSET_EL0 : bits(32)

val PMOVSSET_EL0_SysRegRead_e3c0657a6c8b11c8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMOVSSET_EL0_SysRegRead_e3c0657a6c8b11c8 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSSET_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSSET_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSSET_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMOVSSET_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSCR_EL1 : bits(32)

val __get_PMSCR_EL1 : bits(32) -> bits(32)

function __get_PMSCR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 2, 0b0);
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val PMSCR_EL12_SysRegRead_624c386ea3cce853 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSCR_EL12_SysRegRead_624c386ea3cce853 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_PMSCR_EL1(PMSCR_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(ZeroExtend(__get_PMSCR_EL1(PMSCR_EL1)))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSCR_EL2 : bits(32)

val __get_PMSCR_EL2 : bits(32) -> bits(32)

function __get_PMSCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 2, 0b0);
    val_name = SetSlice(24, val_name, 8, 0b000000000000000000000000);
    return(val_name)
}

val PMSCR_EL1_SysRegRead_39ffc554ca37b155 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSCR_EL1_SysRegRead_39ffc554ca37b155 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSCR_EL1(PMSCR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_PMSCR_EL2(PMSCR_EL2)))
        } else {
            return(ZeroExtend(__get_PMSCR_EL1(PMSCR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSCR_EL1(PMSCR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val PMSCR_EL2_SysRegRead_11330bd80566814a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSCR_EL2_SysRegRead_11330bd80566814a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSCR_EL2(PMSCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSCR_EL2(PMSCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSELR_EL0 : bits(32)

val __get_PMSELR_EL0 : bits(32) -> bits(32)

function __get_PMSELR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(27, val_name, 5, 0b000000000000000000000000000);
    return(val_name)
}

val PMSELR_EL0_SysRegRead_540b592cb875b32f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSELR_EL0_SysRegRead_540b592cb875b32f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & (Slice(PMUSERENR_EL0, 3, 1) @ Slice(PMUSERENR_EL0, 0, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSELR_EL0(PMSELR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSELR_EL0(PMSELR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSELR_EL0(PMSELR_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSELR_EL0(PMSELR_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSEVFR_EL1 : bits(64)

val __get_PMSEVFR_EL1 : bits(64) -> bits(64)

function __get_PMSEVFR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 0, 0b0);
    val_name = SetSlice(1, val_name, 2, 0b0);
    val_name = SetSlice(1, val_name, 4, 0b0);
    val_name = SetSlice(1, val_name, 6, 0b0);
    val_name = SetSlice(4, val_name, 8, 0b0000);
    val_name = SetSlice(8, val_name, 16, 0b00000000);
    val_name = SetSlice(16, val_name, 32, 0b0000000000000000);
    return(val_name)
}

val PMSEVFR_EL1_SysRegRead_9e9a58f73d629d59 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSEVFR_EL1_SysRegRead_9e9a58f73d629d59 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMSEVFR_EL1(PMSEVFR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMSEVFR_EL1(PMSEVFR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMSEVFR_EL1(PMSEVFR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSFCR_EL1 : bits(32)

val __get_PMSFCR_EL1 : bits(32) -> bits(32)

function __get_PMSFCR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(13, val_name, 3, 0b0000000000000);
    val_name = SetSlice(13, val_name, 19, 0b0000000000000);
    return(val_name)
}

val PMSFCR_EL1_SysRegRead_30b07ff27088a488 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSFCR_EL1_SysRegRead_30b07ff27088a488 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSFCR_EL1(PMSFCR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSFCR_EL1(PMSFCR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSFCR_EL1(PMSFCR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSICR_EL1 : bits(64)

val __get_PMSICR_EL1 : bits(64) -> bits(64)

function __get_PMSICR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(24, val_name, 32, 0b000000000000000000000000);
    return(val_name)
}

val PMSICR_EL1_SysRegRead_1b4bf4bb07470e4c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSICR_EL1_SysRegRead_1b4bf4bb07470e4c (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMSICR_EL1(PMSICR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMSICR_EL1(PMSICR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_PMSICR_EL1(PMSICR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSIDR_EL1 : bits(32)

val __get_PMSIDR_EL1 : bits(32) -> bits(32)

function __get_PMSIDR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 6, 0b00);
    val_name = SetSlice(12, val_name, 20, 0b000000000000);
    return(val_name)
}

val PMSIDR_EL1_SysRegRead_062cecff79d24b4d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSIDR_EL1_SysRegRead_062cecff79d24b4d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSIDR_EL1(PMSIDR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSIDR_EL1(PMSIDR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSIDR_EL1(PMSIDR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSIRR_EL1 : bits(32)

val __get_PMSIRR_EL1 : bits(32) -> bits(32)

function __get_PMSIRR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(7, val_name, 1, 0b0000000);
    return(val_name)
}

val PMSIRR_EL1_SysRegRead_b565329ce30ac491 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSIRR_EL1_SysRegRead_b565329ce30ac491 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSIRR_EL1(PMSIRR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSIRR_EL1(PMSIRR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSIRR_EL1(PMSIRR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMSLATFR_EL1 : bits(32)

val __get_PMSLATFR_EL1 : bits(32) -> bits(32)

function __get_PMSLATFR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(20, val_name, 12, 0b00000000000000000000);
    return(val_name)
}

val PMSLATFR_EL1_SysRegRead_f82542fec2521a41 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMSLATFR_EL1_SysRegRead_f82542fec2521a41 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSLATFR_EL1(PMSLATFR_EL1)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSLATFR_EL1(PMSLATFR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMSLATFR_EL1(PMSLATFR_EL1)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_PMUSERENR_EL0 : bits(32) -> bits(32)

function __get_PMUSERENR_EL0 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(28, val_name, 4, 0b0000000000000000000000000000);
    return(val_name)
}

val PMUSERENR_EL0_SysRegRead_7efca1a4be376eb7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMUSERENR_EL0_SysRegRead_7efca1a4be376eb7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMUSERENR_EL0(PMUSERENR_EL0)))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMUSERENR_EL0(PMUSERENR_EL0)))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMUSERENR_EL0(PMUSERENR_EL0)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_PMUSERENR_EL0(PMUSERENR_EL0)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMXEVCNTR_EL0 : bits(32)

val PMXEVCNTR_EL0_SysRegRead_193921f886161922 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMXEVCNTR_EL0_SysRegRead_193921f886161922 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & (Slice(PMUSERENR_EL0, 3, 1) @ Slice(PMUSERENR_EL0, 0, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVCNTR_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVCNTR_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVCNTR_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVCNTR_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register PMXEVTYPER_EL0 : bits(32)

val PMXEVTYPER_EL0_SysRegRead_a34d7cb6f32074c5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function PMXEVTYPER_EL0_SysRegRead_a34d7cb6f32074c5 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVTYPER_EL0))
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVTYPER_EL0))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVTYPER_EL0))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(PMXEVTYPER_EL0))
        }
    } else {
        return(undefined : bits(64))
    }
}

register REVIDR_EL1 : bits(64)

val REVIDR_EL1_SysRegRead_06ac796f098a1e84 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function REVIDR_EL1_SysRegRead_06ac796f098a1e84 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID1 : bits(1) = Slice(HCR_EL2, 16, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(REVIDR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(REVIDR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(REVIDR_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val IsHighestEL : bits(2) -> bool

function IsHighestEL el = {
    return(HighestEL() == el)
}

register RMR_EL1 : bits(32)

val __get_RMR_EL1 : bits(32) -> bits(32)

function __get_RMR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(30, val_name, 2, 0b000000000000000000000000000000);
    return(val_name)
}

val RMR_EL1_SysRegRead_69f4933c1a574580 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RMR_EL1_SysRegRead_69f4933c1a574580 (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL1 & IsHighestEL(EL1) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_RMR_EL1(RMR_EL1)))
        }
    } else {
        throw(Error_Undefined());
        return(undefined : bits(64))
    }
}

register RMR_EL2 : bits(32)

val __get_RMR_EL2 : bits(32) -> bits(32)

function __get_RMR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(30, val_name, 2, 0b000000000000000000000000000000);
    return(val_name)
}

val RMR_EL2_SysRegRead_75749340e0828f00 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RMR_EL2_SysRegRead_75749340e0828f00 (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL2 & IsHighestEL(EL2) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_RMR_EL2(RMR_EL2)))
        }
    } else {
        throw(Error_Undefined());
        return(undefined : bits(64))
    }
}

register RMR_EL3 : bits(32)

val __get_RMR_EL3 : bits(32) -> bits(32)

function __get_RMR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(30, val_name, 2, 0b000000000000000000000000000000);
    return(val_name)
}

val RMR_EL3_SysRegRead_fa5f18c3b20f8894 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RMR_EL3_SysRegRead_fa5f18c3b20f8894 (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL3 & IsHighestEL(EL3) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_RMR_EL3(RMR_EL3)))
        }
    } else {
        throw(Error_Undefined());
        return(undefined : bits(64))
    }
}

register RSP_EL0 : bits(129)

val RSP_EL0_SysRegRead_b64c62bd96d973e3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RSP_EL0_SysRegRead_b64c62bd96d973e3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RSP_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RSP_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RSP_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RSP_EL0[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

register RTPIDR_EL0 : bits(129)

val RTPIDR_EL0_SysRegRead_0ce5a74dba936523 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RTPIDR_EL0_SysRegRead_0ce5a74dba936523 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RTPIDR_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RTPIDR_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RTPIDR_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(64))
        } else {
            return(RTPIDR_EL0[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

register RVBAR_EL1 : bits(64)

val RVBAR_EL1_SysRegRead_48a958c9250293d1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RVBAR_EL1_SysRegRead_48a958c9250293d1 (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL1 & IsHighestEL(EL1) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(RVBAR_EL1)
        }
    } else {
        throw(Error_Undefined());
        return(undefined : bits(64))
    }
}

register RVBAR_EL2 : bits(64)

val RVBAR_EL2_SysRegRead_2fb802203150f4cc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RVBAR_EL2_SysRegRead_2fb802203150f4cc (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL2 & IsHighestEL(EL2) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(RVBAR_EL2)
        }
    } else {
        throw(Error_Undefined());
        return(undefined : bits(64))
    }
}

register RVBAR_EL3 : bits(64)

val RVBAR_EL3_SysRegRead_000d1ea4b77ffa21 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function RVBAR_EL3_SysRegRead_000d1ea4b77ffa21 (el, op0, op1, CRn, op2, CRm) = {
    if PSTATE.EL == EL3 & IsHighestEL(EL3) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(RVBAR_EL3)
        }
    } else {
        throw(Error_Undefined());
        return(undefined : bits(64))
    }
}

register S3_op1_Cn_Cm_op2 : bits(64)

val S3_op1_CCn_CCm_op2_SysRegRead_d72a7245384bbc0e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function S3_op1_CCn_CCm_op2_SysRegRead_d72a7245384bbc0e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TIDCP : bits(1) = Slice(HCR_EL2, 20, 1);
    if __PSTATE_EL == EL1 then {
        if EL2Enabled() & __HCR_EL2_TIDCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(S3_op1_Cn_Cm_op2)
        }
    } else {
        return(S3_op1_Cn_Cm_op2)
    }
}

val __get_SCR_EL3 : bits(32) -> bits(32)

function __get_SCR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(3, val_name, 4, 0b011);
    val_name = SetSlice(9, val_name, 16, 0b000000000);
    val_name = SetSlice(6, val_name, 26, 0b000000);
    return(val_name)
}

val SCR_EL3_SysRegRead_082a69b26890132d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCR_EL3_SysRegRead_082a69b26890132d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_SCR_EL3(SCR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_SCTLR_EL1 : bits(64) -> bits(64)

function __get_SCTLR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 6, 0b0);
    val_name = SetSlice(1, val_name, 11, 0b1);
    val_name = SetSlice(1, val_name, 13, 0b0);
    val_name = SetSlice(1, val_name, 17, 0b0);
    val_name = SetSlice(1, val_name, 22, 0b1);
    val_name = SetSlice(1, val_name, 27, 0b0);
    val_name = SetSlice(14, val_name, 30, 0b00000000000000);
    val_name = SetSlice(19, val_name, 45, 0b0000000000000000000);
    return(val_name)
}

val SCTLR_EL12_SysRegRead_81ba00bca4ce39dc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCTLR_EL12_SysRegRead_81ba00bca4ce39dc (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(__get_SCTLR_EL1(SCTLR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(__get_SCTLR_EL1(SCTLR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_SCTLR_EL2 : bits(64) -> bits(64)

function __get_SCTLR_EL2 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 6, 0b0);
    val_name = SetSlice(1, val_name, 9, 0b0);
    val_name = SetSlice(1, val_name, 11, 0b1);
    val_name = SetSlice(1, val_name, 13, 0b0);
    val_name = SetSlice(1, val_name, 17, 0b0);
    val_name = SetSlice(1, val_name, 22, 0b1);
    val_name = SetSlice(1, val_name, 27, 0b0);
    val_name = SetSlice(14, val_name, 30, 0b00000000000000);
    val_name = SetSlice(19, val_name, 45, 0b0000000000000000000);
    return(val_name)
}

val SCTLR_EL1_SysRegRead_cc5fb072b0cb85eb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCTLR_EL1_SysRegRead_cc5fb072b0cb85eb (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_SCTLR_EL1(SCTLR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(__get_SCTLR_EL2(SCTLR_EL2))
        } else {
            return(__get_SCTLR_EL1(SCTLR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_SCTLR_EL1(SCTLR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val SCTLR_EL2_SysRegRead_3cc208f3abf97e34 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCTLR_EL2_SysRegRead_3cc208f3abf97e34 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_SCTLR_EL2(SCTLR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_SCTLR_EL2(SCTLR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_SCTLR_EL3 : bits(64) -> bits(64)

function __get_SCTLR_EL3 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(8, val_name, 4, 0b10000011);
    val_name = SetSlice(6, val_name, 13, 0b101000);
    val_name = SetSlice(1, val_name, 20, 0b0);
    val_name = SetSlice(3, val_name, 22, 0b011);
    val_name = SetSlice(18, val_name, 26, 0b000000000000001100);
    val_name = SetSlice(19, val_name, 45, 0b0000000000000000000);
    return(val_name)
}

val SCTLR_EL3_SysRegRead_9c537c9c01007c3e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCTLR_EL3_SysRegRead_9c537c9c01007c3e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_SCTLR_EL3(SCTLR_EL3))
        }
    } else {
        return(undefined : bits(64))
    }
}

register CID_EL0 : bits(129)

val SCXTNUM_EL0_read : unit -> bits(64) effect {rreg, undef}

function SCXTNUM_EL0_read () = {
    r : bits(64) = undefined;
    r = SetSlice(64, r, 0, Slice(CID_EL0, 0, 64));
    return(r)
}

val SCXTNUM_EL0_SysRegRead_ee5b769fc7f044cc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCXTNUM_EL0_SysRegRead_ee5b769fc7f044cc (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_TSCXT : bits(1) = Slice(SCTLR_EL1, 20, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_EnSCXT : bits(1) = Slice(HCR_EL2, 53, 1);
    let __SCTLR_EL2_TSCXT : bits(1) = Slice(SCTLR_EL2, 20, 1);
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_TSCXT == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_TSCXT == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL0_read())
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL0_read())
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL0_read())
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL0_read())
        }
    } else {
        return(undefined : bits(64))
    }
}

register SCXTNUM_EL1 : bits(64)

val SCXTNUM_EL12_SysRegRead_d31f345333a78d48 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCXTNUM_EL12_SysRegRead_d31f345333a78d48 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(SCXTNUM_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(SCXTNUM_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register SCXTNUM_EL2 : bits(64)

val SCXTNUM_EL1_SysRegRead_dd27b7ad05ded1ab : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCXTNUM_EL1_SysRegRead_dd27b7ad05ded1ab (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_EnSCXT : bits(1) = Slice(HCR_EL2, 53, 1);
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(SCXTNUM_EL2)
        } else {
            return(SCXTNUM_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val SCXTNUM_EL2_SysRegRead_421b17f19f5fdd2a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCXTNUM_EL2_SysRegRead_421b17f19f5fdd2a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register SCXTNUM_EL3 : bits(64)

val SCXTNUM_EL3_SysRegRead_5f15a3b4da1bd4bb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SCXTNUM_EL3_SysRegRead_5f15a3b4da1bd4bb (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(SCXTNUM_EL3)
        }
    } else {
        return(undefined : bits(64))
    }
}

register SDER32_EL3 : bits(32)

val __get_SDER32_EL3 : bits(32) -> bits(32)

function __get_SDER32_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(30, val_name, 2, 0b000000000000000000000000000000);
    return(val_name)
}

val SDER32_EL3_SysRegRead_e21f871563c7e34e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function SDER32_EL3_SysRegRead_e21f871563c7e34e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_SDER32_EL3(SDER32_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_SPSR_EL1 : bits(32) -> bits(32)

function __get_SPSR_EL1 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 24, 0b0);
    return(val_name)
}

val SPSR_EL12_SysRegRead_a8511792ae31e865 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_EL12_SysRegRead_a8511792ae31e865 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_SPSR_EL1(SPSR_EL1)))
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_SPSR_EL1(SPSR_EL1)))
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_SPSR_EL2 : bits(32) -> bits(32)

function __get_SPSR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 24, 0b0);
    return(val_name)
}

val SPSR_EL1_SysRegRead_32354aa2884c2edd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_EL1_SysRegRead_32354aa2884c2edd (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        return(ZeroExtend(__get_SPSR_EL1(SPSR_EL1)))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            return(ZeroExtend(__get_SPSR_EL2(SPSR_EL2)))
        } else {
            return(ZeroExtend(__get_SPSR_EL1(SPSR_EL1)))
        }
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_EL1(SPSR_EL1)))
    } else {
        return(undefined : bits(64))
    }
}

val SPSR_EL2_SysRegRead_63ec64f2f805090d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_EL2_SysRegRead_63ec64f2f805090d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_SPSR_EL2(SPSR_EL2)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_EL2(SPSR_EL2)))
    } else {
        return(undefined : bits(64))
    }
}

val __get_SPSR_EL3 : bits(32) -> bits(32)

function __get_SPSR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 24, 0b0);
    return(val_name)
}

val SPSR_EL3_SysRegRead_fca96fc0dc593061 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_EL3_SysRegRead_fca96fc0dc593061 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_EL3(SPSR_EL3)))
    } else {
        return(undefined : bits(64))
    }
}

register SPSR_abt : bits(32)

val __get_SPSR_abt : bits(32) -> bits(32)

function __get_SPSR_abt val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 21, 0b0);
    return(val_name)
}

val SPSR_abt_SysRegRead_7ed396e0808f79f6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_abt_SysRegRead_7ed396e0808f79f6 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_SPSR_abt(SPSR_abt)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_abt(SPSR_abt)))
    } else {
        return(undefined : bits(64))
    }
}

register SPSR_fiq : bits(32)

val __get_SPSR_fiq : bits(32) -> bits(32)

function __get_SPSR_fiq val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 21, 0b0);
    return(val_name)
}

val SPSR_fiq_SysRegRead_390457aa85161af4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_fiq_SysRegRead_390457aa85161af4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_SPSR_fiq(SPSR_fiq)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_fiq(SPSR_fiq)))
    } else {
        return(undefined : bits(64))
    }
}

register SPSR_irq : bits(32)

val __get_SPSR_irq : bits(32) -> bits(32)

function __get_SPSR_irq val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 21, 0b0);
    return(val_name)
}

val SPSR_irq_SysRegRead_8593f29eadca9d64 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_irq_SysRegRead_8593f29eadca9d64 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_SPSR_irq(SPSR_irq)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_irq(SPSR_irq)))
    } else {
        return(undefined : bits(64))
    }
}

register SPSR_und : bits(32)

val __get_SPSR_und : bits(32) -> bits(32)

function __get_SPSR_und val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 21, 0b0);
    return(val_name)
}

val SPSR_und_SysRegRead_89a3b7c63cd43460 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSR_und_SysRegRead_89a3b7c63cd43460 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        return(ZeroExtend(__get_SPSR_und(SPSR_und)))
    } else if __PSTATE_EL == EL3 then {
        return(ZeroExtend(__get_SPSR_und(SPSR_und)))
    } else {
        return(undefined : bits(64))
    }
}

val SPSel_SysRegRead_ac7632fd1580b15b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SPSel_SysRegRead_ac7632fd1580b15b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(Zeros())
        } else {
            return(Zeros(63) @ __PSTATE_SP)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(Zeros())
        } else {
            return(Zeros(63) @ __PSTATE_SP)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(Zeros())
        } else {
            return(Zeros(63) @ __PSTATE_SP)
        }
    } else {
        return(undefined : bits(64))
    }
}

register SP_EL0 : bits(129)

val SP_EL0_SysRegRead_4b07157e43cd0456 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SP_EL0_SysRegRead_4b07157e43cd0456 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            return(SP_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL2 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            return(SP_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            return(SP_EL0[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

register SP_EL1 : bits(129)

val SP_EL1_SysRegRead_44ac23d2a7608550 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SP_EL1_SysRegRead_44ac23d2a7608550 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            return(SP_EL1[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            return(SP_EL1[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

register SP_EL2 : bits(129)

val SP_EL2_SysRegRead_9c4b7d596526b300 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function SP_EL2_SysRegRead_9c4b7d596526b300 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(64))
        } else {
            return(SP_EL2[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

val SSBS_SysRegRead_05419031832511d1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {rreg, undef}

function SSBS_SysRegRead_05419031832511d1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        return((Zeros(51) @ PSTATE.SSBS) @ Zeros(12))
    } else if __PSTATE_EL == EL1 then {
        return((Zeros(51) @ PSTATE.SSBS) @ Zeros(12))
    } else if __PSTATE_EL == EL2 then {
        return((Zeros(51) @ PSTATE.SSBS) @ Zeros(12))
    } else if __PSTATE_EL == EL3 then {
        return((Zeros(51) @ PSTATE.SSBS) @ Zeros(12))
    } else {
        return(undefined : bits(64))
    }
}

val __get_TCR_EL1 : bits(64) -> bits(64)

function __get_TCR_EL1 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 6, 0b0);
    val_name = SetSlice(1, val_name, 35, 0b0);
    val_name = SetSlice(2, val_name, 51, 0b00);
    val_name = SetSlice(9, val_name, 55, 0b000000000);
    return(val_name)
}

val TCR_EL12_SysRegRead_cefcc3f131a70a7f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TCR_EL12_SysRegRead_cefcc3f131a70a7f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(__get_TCR_EL1(TCR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(__get_TCR_EL1(TCR_EL1))
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_TCR_EL2 : bits(64) -> bits(64)

function __get_TCR_EL2 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(1, val_name, 6, 0b0);
    val_name = SetSlice(1, val_name, 35, 0b0);
    val_name = SetSlice(2, val_name, 51, 0b00);
    val_name = SetSlice(9, val_name, 55, 0b000000000);
    return(val_name)
}

val TCR_EL1_SysRegRead_fbe255888fba9865 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TCR_EL1_SysRegRead_fbe255888fba9865 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_TCR_EL1(TCR_EL1))
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(__get_TCR_EL2(TCR_EL2))
        } else {
            return(__get_TCR_EL1(TCR_EL1))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_TCR_EL1(TCR_EL1))
        }
    } else {
        return(undefined : bits(64))
    }
}

val TCR_EL2_SysRegRead_3467687df9c2aec1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TCR_EL2_SysRegRead_3467687df9c2aec1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_TCR_EL2(TCR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_TCR_EL2(TCR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val __get_TCR_EL3 : bits(32) -> bits(32)

function __get_TCR_EL3 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(2, val_name, 6, 0b00);
    val_name = SetSlice(1, val_name, 19, 0b0);
    val_name = SetSlice(1, val_name, 23, 0b1);
    val_name = SetSlice(3, val_name, 29, 0b100);
    return(val_name)
}

val TCR_EL3_SysRegRead_7da88d4a232f9451 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TCR_EL3_SysRegRead_7da88d4a232f9451 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_TCR_EL3(TCR_EL3)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register TPIDRRO_EL0 : bits(129)

val TPIDRRO_EL0_SysRegRead_3dc5dc323922fcfa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {rreg, undef}

function TPIDRRO_EL0_SysRegRead_3dc5dc323922fcfa (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        return(TPIDRRO_EL0[63 .. 0])
    } else if __PSTATE_EL == EL1 then {
        return(TPIDRRO_EL0[63 .. 0])
    } else if __PSTATE_EL == EL2 then {
        return(TPIDRRO_EL0[63 .. 0])
    } else if __PSTATE_EL == EL3 then {
        return(TPIDRRO_EL0[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

register TPIDR_EL0 : bits(129)

val TPIDR_EL0_SysRegRead_7b944c4fc3d3f60f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {rreg, undef}

function TPIDR_EL0_SysRegRead_7b944c4fc3d3f60f (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0[63 .. 0])
        } else {
            return(TPIDR_EL0[63 .. 0])
        }
    } else if __PSTATE_EL == EL1 then {
        return(TPIDR_EL0[63 .. 0])
    } else if __PSTATE_EL == EL2 then {
        return(TPIDR_EL0[63 .. 0])
    } else if __PSTATE_EL == EL3 then {
        return(TPIDR_EL0[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

register TPIDR_EL1 : bits(129)

val TPIDR_EL1_SysRegRead_8db91ea8b9abc411 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function TPIDR_EL1_SysRegRead_8db91ea8b9abc411 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0[63 .. 0])
        } else {
            return(TPIDR_EL1[63 .. 0])
        }
    } else if __PSTATE_EL == EL2 then {
        return(TPIDR_EL1[63 .. 0])
    } else if __PSTATE_EL == EL3 then {
        return(TPIDR_EL1[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

register TPIDR_EL2 : bits(129)

val TPIDR_EL2_SysRegRead_fc4633f7449b5b4a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function TPIDR_EL2_SysRegRead_fc4633f7449b5b4a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0[63 .. 0])
        } else {
            return(TPIDR_EL2[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        return(TPIDR_EL2[63 .. 0])
    } else {
        return(undefined : bits(64))
    }
}

register TPIDR_EL3 : bits(129)

val TPIDR_EL3_SysRegRead_c6069d62b310a137 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function TPIDR_EL3_SysRegRead_c6069d62b310a137 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0[63 .. 0])
        } else {
            return(TPIDR_EL3[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

register TTBR0_EL1 : bits(64)

val TTBR0_EL12_SysRegRead_73f9bd4d027badee : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR0_EL12_SysRegRead_73f9bd4d027badee (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(TTBR0_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(TTBR0_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register TTBR0_EL2 : bits(64)

val TTBR0_EL1_SysRegRead_2e8a6c25b2e4759a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR0_EL1_SysRegRead_2e8a6c25b2e4759a (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(TTBR0_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(TTBR0_EL2)
        } else {
            return(TTBR0_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(TTBR0_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val TTBR0_EL2_SysRegRead_8d4de9e080477354 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR0_EL2_SysRegRead_8d4de9e080477354 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(TTBR0_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(TTBR0_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

register TTBR0_EL3 : bits(64)

val __get_TTBR0_EL3 : bits(64) -> bits(64)

function __get_TTBR0_EL3 val_name__arg = {
    val_name : bits(64) = val_name__arg;
    val_name = SetSlice(16, val_name, 48, 0b0000000000000000);
    return(val_name)
}

val TTBR0_EL3_SysRegRead_a46e35edfe45a273 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR0_EL3_SysRegRead_a46e35edfe45a273 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_TTBR0_EL3(TTBR0_EL3))
        }
    } else {
        return(undefined : bits(64))
    }
}

register TTBR1_EL1 : bits(64)

val TTBR1_EL12_SysRegRead_bfbc2899eb278d2b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR1_EL12_SysRegRead_bfbc2899eb278d2b (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(TTBR1_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(TTBR1_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

register TTBR1_EL2 : bits(64)

val TTBR1_EL1_SysRegRead_2cb2fb59089165c5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR1_EL1_SysRegRead_2cb2fb59089165c5 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TRVM : bits(1) = Slice(HCR_EL2, 30, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TRVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(TTBR1_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(TTBR1_EL2)
        } else {
            return(TTBR1_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(TTBR1_EL1)
        }
    } else {
        return(undefined : bits(64))
    }
}

val TTBR1_EL2_SysRegRead_08cd28a9b17bc317 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function TTBR1_EL2_SysRegRead_08cd28a9b17bc317 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(TTBR1_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(TTBR1_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

val UAO_SysRegRead_297f45f7f70ec250 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef}

function UAO_SysRegRead_297f45f7f70ec250 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        return((Zeros(40) @ PSTATE.UAO) @ Zeros(23))
    } else if __PSTATE_EL == EL2 then {
        return((Zeros(40) @ PSTATE.UAO) @ Zeros(23))
    } else if __PSTATE_EL == EL3 then {
        return((Zeros(40) @ PSTATE.UAO) @ Zeros(23))
    } else {
        return(undefined : bits(64))
    }
}

val VBAR_EL12_SysRegRead_2ad4e02fbe99cf3d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VBAR_EL12_SysRegRead_2ad4e02fbe99cf3d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18));
                    return(undefined : bits(64))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18));
                    return(undefined : bits(64))
                }
            } else {
                return(VBAR_EL1[63 .. 0])
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            } else {
                return(VBAR_EL1[63 .. 0])
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(64))
        }
    } else {
        return(undefined : bits(64))
    }
}

val VBAR_EL1_SysRegRead_4d14cb3b6fe16ab6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VBAR_EL1_SysRegRead_4d14cb3b6fe16ab6 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18));
                return(undefined : bits(64))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(VBAR_EL1[63 .. 0])
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            return(VBAR_EL2[63 .. 0])
        } else {
            return(VBAR_EL1[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(VBAR_EL1[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

val VBAR_EL2_SysRegRead_1f6b3c94ccfecacf : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VBAR_EL2_SysRegRead_1f6b3c94ccfecacf (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(VBAR_EL2[63 .. 0])
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(VBAR_EL2[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

val VBAR_EL3_SysRegRead_32f42cb574998654 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VBAR_EL3_SysRegRead_32f42cb574998654 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(VBAR_EL3[63 .. 0])
        }
    } else {
        return(undefined : bits(64))
    }
}

val VDISR_EL2_SysRegRead_14dff4ad4ae8c3a2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VDISR_EL2_SysRegRead_14dff4ad4ae8c3a2 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_VDISR_EL2(VDISR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_VDISR_EL2(VDISR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

val VMPIDR_EL2_SysRegRead_49b7c13dd1b0804c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VMPIDR_EL2_SysRegRead_49b7c13dd1b0804c (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(__get_VMPIDR_EL2(VMPIDR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(HaveEL(EL2)) then {
            return(__get_MPIDR_EL1(MPIDR_EL1))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(__get_VMPIDR_EL2(VMPIDR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

val VPIDR_EL2_SysRegRead_f6520cd6a1f62bd8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VPIDR_EL2_SysRegRead_f6520cd6a1f62bd8 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(VPIDR_EL2))
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(HaveEL(EL2)) then {
            return(ZeroExtend(MIDR_EL1))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(VPIDR_EL2))
        }
    } else {
        return(undefined : bits(64))
    }
}

register VSESR_EL2 : bits(32)

val __get_VSESR_EL2 : bits(32) -> bits(32)

function __get_VSESR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(7, val_name, 25, 0b0000000);
    return(val_name)
}

val VSESR_EL2_SysRegRead_401c063e57574698 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VSESR_EL2_SysRegRead_401c063e57574698 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_VSESR_EL2(VSESR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_VSESR_EL2(VSESR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register VTCR_EL2 : bits(32)

val __get_VTCR_EL2 : bits(32) -> bits(32)

function __get_VTCR_EL2 val_name__arg = {
    val_name : bits(32) = val_name__arg;
    val_name = SetSlice(1, val_name, 20, 0b0);
    val_name = SetSlice(2, val_name, 23, 0b00);
    val_name = SetSlice(3, val_name, 29, 0b100);
    return(val_name)
}

val VTCR_EL2_SysRegRead_5c8ea980dc5cc1d1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VTCR_EL2_SysRegRead_5c8ea980dc5cc1d1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(ZeroExtend(__get_VTCR_EL2(VTCR_EL2)))
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(ZeroExtend(__get_VTCR_EL2(VTCR_EL2)))
        }
    } else {
        return(undefined : bits(64))
    }
}

register VTTBR_EL2 : bits(64)

val VTTBR_EL2_SysRegRead_2fbbdccc9485564d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function VTTBR_EL2_SysRegRead_2fbbdccc9485564d (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(64))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18));
                return(undefined : bits(64))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18));
                return(undefined : bits(64))
            }
        } else {
            return(VTTBR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18));
            return(undefined : bits(64))
        } else {
            return(VTTBR_EL2)
        }
    } else {
        return(undefined : bits(64))
    }
}

val AArch64_AutoGen_SysRegRead : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(64) effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_SysRegRead (el, op0, op1, CRn, op2, CRm) = {
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(TPIDR_EL1_SysRegRead_8db91ea8b9abc411(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(SP_EL2_SysRegRead_9c4b7d596526b300(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(ELR_EL2_SysRegRead_00b4dd4251404d91(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ELR_EL1_SysRegRead_0d3f1ad1483e96c2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        return(TPIDRRO_EL0_SysRegRead_3dc5dc323922fcfa(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(TPIDR_EL2_SysRegRead_fc4633f7449b5b4a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(TPIDR_EL0_SysRegRead_7b944c4fc3d3f60f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(SP_EL1_SysRegRead_44ac23d2a7608550(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(ELR_EL3_SysRegRead_a7a7cd4e7e805396(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(SP_EL0_SysRegRead_4b07157e43cd0456(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        return(TPIDR_EL3_SysRegRead_c6069d62b310a137(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(VBAR_EL2_SysRegRead_1f6b3c94ccfecacf(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(VBAR_EL1_SysRegRead_4d14cb3b6fe16ab6(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(VBAR_EL3_SysRegRead_32f42cb574998654(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(VBAR_EL12_SysRegRead_2ad4e02fbe99cf3d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(ELR_EL12_SysRegRead_e8215c0ae79859bb(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b100 then {
        return(RTPIDR_EL0_SysRegRead_0ce5a74dba936523(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b111) & op2 == 0b011 then {
        return(RSP_EL0_SysRegRead_b64c62bd96d973e3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(HCR_EL2_SysRegRead_f76ecfdc85c5ff7c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0111 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(ID_AA64MMFR2_EL1_SysRegRead_1443648da3ca79dd(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0111) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(PAR_EL1_SysRegRead_888e7c84935ebac7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(CNTVOFF_EL2_SysRegRead_5ca7336b54f14c06(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & (match CRn {
      [bitone, _, bitone, bitone] => true,
      _ => false
    }) : bool) & op0 == 0b11) & (match op1 {
      [_, _, _] => true,
      _ => false
    }) : bool) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        return(S3_op1_CCn_CCm_op2_SysRegRead_d72a7245384bbc0e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [bitone, bitone, bitzero, _] => true,
      _ => false
    }) : bool & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        return(ICH_LR_EL2_SysRegRead_f9d8d38c7064e389(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b000 then {
        return(MDRAR_EL1_SysRegRead_4c6f0d270d3fe56e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(MAIR_EL2_SysRegRead_66c03f7cb594c1bd(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(MAIR_EL1_SysRegRead_ee00b1441fc4a50d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b001) & op2 == 0b111 then {
        return(AIDR_EL1_SysRegRead_74ea31b1dc6f5c6f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(ACTLR_EL3_SysRegRead_397e6c0342e2936b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(AMAIR_EL2_SysRegRead_3c316bb11b239640(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(AMAIR_EL1_SysRegRead_82d01d3808e04ca3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(FAR_EL1_SysRegRead_136ac0cc65bd5f9d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(FAR_EL12_SysRegRead_061fecffb03f9fc5(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(AMAIR_EL3_SysRegRead_b1547f511477c529(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(SCXTNUM_EL1_SysRegRead_dd27b7ad05ded1ab(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b111 then {
        return(SCXTNUM_EL12_SysRegRead_d31f345333a78d48(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(TCR_EL2_SysRegRead_3467687df9c2aec1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(TCR_EL1_SysRegRead_fbe255888fba9865(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        return(HACR_EL2_SysRegRead_07bc3864e8ed8264(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(CNTP_CVAL_EL0_SysRegRead_4db28ae745612584(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        return(CNTP_CVAL_EL02_SysRegRead_8377305437cbebb4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(SCTLR_EL1_SysRegRead_cc5fb072b0cb85eb(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(SCTLR_EL12_SysRegRead_81ba00bca4ce39dc(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(AMAIR_EL12_SysRegRead_87964a33cc1ad0ef(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        return(SCXTNUM_EL0_SysRegRead_ee5b769fc7f044cc(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ACTLR_EL1_SysRegRead_56bd4d0367c16236(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        return(VMPIDR_EL2_SysRegRead_49b7c13dd1b0804c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        return(MPIDR_EL1_SysRegRead_1a44c237fc7e90a0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ID_AA64ISAR1_EL1_SysRegRead_1132f371c4707f61(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(ACTLR_EL2_SysRegRead_ff23cef1b670b9c7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(FAR_EL3_SysRegRead_d63ec2764f8ffe40(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ID_AA64DFR0_EL1_SysRegRead_c3e6b049dd70bbab(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ID_AA64PFR0_EL1_SysRegRead_fe78f914579c8717(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(RVBAR_EL3_SysRegRead_000d1ea4b77ffa21(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ID_AA64ISAR0_EL1_SysRegRead_d35f255c04eaab0f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(TTBR1_EL2_SysRegRead_08cd28a9b17bc317(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(TTBR1_EL1_SysRegRead_2cb2fb59089165c5(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        return(DBGDTR_EL0_SysRegRead_537a006eb82c59aa(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0111 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ID_AA64MMFR1_EL1_SysRegRead_3abbf4d2af8dd3be(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(CNTPCT_EL0_SysRegRead_579be4c9ef4e6824(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b001) & op2 == 0b001 then {
        return(CLIDR_EL1_SysRegRead_b403ddc99e97c3a8(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(DLR_EL0_SysRegRead_75b9821e3e84ec13(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        return(DBGBVR_EL1_SysRegRead_dc4a8f61b400622f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(AFSR1_EL3_SysRegRead_a2ad736ad599f2b2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        return(REVIDR_EL1_SysRegRead_06ac796f098a1e84(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        return(PMCEID1_EL0_SysRegRead_2db7a3b96735d30a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b111) & op2 == 0b010 then {
        return(CNTPS_CVAL_EL1_SysRegRead_3e364bd573c45cae(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(LOREA_EL1_SysRegRead_ec495c3c15ed4dbe(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(MAIR_EL12_SysRegRead_ac3327848e47dda6(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b110 then {
        return(PMCEID0_EL0_SysRegRead_1364a10a0c913d82(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        return(DBGWVR_EL1_SysRegRead_029de1005ef34888(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(TTBR0_EL3_SysRegRead_a46e35edfe45a273(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(CNTV_CVAL_EL0_SysRegRead_54d5eb0bec99456f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        return(CNTV_CVAL_EL02_SysRegRead_abd2b9f314cb85b2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(CNTHP_CVAL_EL2_SysRegRead_e25a0257128c640b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        return(TCR_EL12_SysRegRead_cefcc3f131a70a7f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(RVBAR_EL2_SysRegRead_2fb802203150f4cc(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b100 then {
        return(HPFAR_EL2_SysRegRead_4c322cee424dff18(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b111 then {
        return(SCXTNUM_EL3_SysRegRead_5f15a3b4da1bd4bb(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(TTBR1_EL12_SysRegRead_bfbc2899eb278d2b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(SCTLR_EL3_SysRegRead_9c537c9c01007c3e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(AFSR0_EL3_SysRegRead_d2e69d7912ca200c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(RVBAR_EL1_SysRegRead_48a958c9250293d1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(AFSR1_EL2_SysRegRead_f7cb9a59387f268f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(AFSR1_EL1_SysRegRead_495927b72173c55f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(MAIR_EL3_SysRegRead_0eb4af28a4f9b45a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1101 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(PMCCNTR_EL0_SysRegRead_45fc425eff298404(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(AFSR0_EL2_SysRegRead_07613e9c4b98061a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(AFSR0_EL1_SysRegRead_80a4a0472e0b9142(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(SCTLR_EL2_SysRegRead_3cc208f3abf97e34(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(CNTVCT_EL0_SysRegRead_cd7c8aebed2715e6(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(TTBR0_EL2_SysRegRead_8d4de9e080477354(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(TTBR0_EL1_SysRegRead_2e8a6c25b2e4759a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(AFSR1_EL12_SysRegRead_39bb62021df07ecc(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(FAR_EL2_SysRegRead_d686d0a5577f0aae(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(AFSR0_EL12_SysRegRead_2488de32a3f38621(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(CNTHV_CVAL_EL2_SysRegRead_2c78392b89702ca9(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(LORSA_EL1_SysRegRead_cdc08dda4115abc7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        return(SCXTNUM_EL2_SysRegRead_421b17f19f5fdd2a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(VTTBR_EL2_SysRegRead_2fbbdccc9485564d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(TTBR0_EL12_SysRegRead_73f9bd4d027badee(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(ID_AA64ZFR0_EL1_SysRegRead_70425f5143f66c9f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(MPAM3_EL3_SysRegRead_989f38b07d8b4265(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(MPAMVPM2_EL2_SysRegRead_590d1577b5eb780d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        return(MPAMVPM5_EL2_SysRegRead_0f596cf6a35cf124(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b110 then {
        return(MPAMVPM6_EL2_SysRegRead_c93ffeb6ea409c71(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(MPAMIDR_EL1_SysRegRead_df4c57d831354b3c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        return(MPAMVPM7_EL2_SysRegRead_ef19c89f1fa31f3e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(MPAMVPM0_EL2_SysRegRead_d878a15f2ea1751d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(MPAMVPM3_EL2_SysRegRead_3d93a30deb34ea81(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(MPAM2_EL2_SysRegRead_10b60646fb381bea(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(MPAM1_EL1_SysRegRead_770ea23b87b18d99(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(MPAM0_EL1_SysRegRead_87af318fd5c9f9f7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(MPAMVPM1_EL2_SysRegRead_78ba55a3ef5fc5ba(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b100 then {
        return(MPAMVPM4_EL2_SysRegRead_c4fa65dba541d8f3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(MPAM1_EL12_SysRegRead_229a253b730e26d9(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(PMBPTR_EL1_SysRegRead_fb82e1b6e480bd0a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(PMSICR_EL1_SysRegRead_1b4bf4bb07470e4c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        return(PMSEVFR_EL1_SysRegRead_9e9a58f73d629d59(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(PMBLIMITR_EL1_SysRegRead_b7c18938ab0566dc(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(ERXADDR_EL1_SysRegRead_7dea05bca757fc1d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ERXMISC0_EL1_SysRegRead_a71a4de5f2444f19(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ERXMISC1_EL1_SysRegRead_bda613f8058b1fd8(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ERXCTLR_EL1_SysRegRead_e46ed88d092db048(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ERXFR_EL1_SysRegRead_ed2a3c237ae67a43(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(ERXSTATUS_EL1_SysRegRead_0ab2cfe6937b8b64(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        return(ID_MMFR2_EL1_SysRegRead_b60501193094f759(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        return(ID_MMFR4_EL1_SysRegRead_237ae4b6fb487f3e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(CONTEXTIDR_EL1_SysRegRead_fa54232c55ea14e3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(CONTEXTIDR_EL12_SysRegRead_2aa676fc0cfd631b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(ID_ISAR4_EL1_SysRegRead_9bffd9dcf4dd4ef4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(DSPSR_EL0_SysRegRead_888dc1fa37424d3d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(MVFR1_EL1_SysRegRead_1964a95566ab0fcd(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b101 then {
        return(PMSELR_EL0_SysRegRead_540b592cb875b32f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(ICC_CTLR_EL1_SysRegRead_5754830bf787a1e2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & (match op2 {
      [bitzero, _, _] => true,
      _ => false
    }) : bool then {
        return(ICC_AP1R_EL1_SysRegRead_4127418c67790ba3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(DAIF_SysRegRead_198f3b46fcf6c8f0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(CNTP_CTL_EL0_SysRegRead_47237e002d686ac6(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(CNTP_CTL_EL02_SysRegRead_9d9930274ff7fc36(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [bitone, bitzero, _, _] => true,
      _ => false
    }) : bool & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        return(PMEVCNTR_EL0_SysRegRead_e0380ad70bc25a0c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(CNTHV_TVAL_EL2_SysRegRead_2464c0e91db55a22(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(CNTV_TVAL_EL0_SysRegRead_919e73a694090e48(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0111 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ID_AA64MMFR0_EL1_SysRegRead_836c46ff67ac3f3d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(SPSR_irq_SysRegRead_8593f29eadca9d64(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(SPSR_abt_SysRegRead_7ed396e0808f79f6(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(MVFR0_EL1_SysRegRead_982614cb681cfbbf(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(ICC_HPPIR1_EL1_SysRegRead_88ed0889f7d5a37a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & (match op2 {
      [bitone, _, _] => true,
      _ => false
    }) : bool then {
        return(ICC_AP0R_EL1_SysRegRead_cac9b22dc3786a15(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ESR_EL1_SysRegRead_4894753806397624(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(ESR_EL12_SysRegRead_207d3805d256851a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(ICC_BPR1_EL1_SysRegRead_c56bf88f1b4aee37(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        return(TCR_EL3_SysRegRead_7da88d4a232f9451(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(ID_ISAR2_EL1_SysRegRead_1e8edaee6a0e9ef9(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ICC_PMR_EL1_SysRegRead_4ab2c9427488fbf4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(ESR_EL2_SysRegRead_e0558cb255261414(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(RMR_EL1_SysRegRead_69f4933c1a574580(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        return(OSLSR_EL1_SysRegRead_d99062033a35ccbf(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(ICC_HPPIR0_EL1_SysRegRead_221f9a6f32464de4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(ICH_EISR_EL2_SysRegRead_a45d99ec0ef64804(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(LORN_EL1_SysRegRead_da981b495b21c400(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(HSTR_EL2_SysRegRead_680380b9028cf399(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b100 then {
        return(ICC_CTLR_EL3_SysRegRead_aba1771445e9d51b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        return(ICH_VMCR_EL2_SysRegRead_3c019711ec735507(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b001) & op2 == 0b000 then {
        return(CCSIDR_EL1_SysRegRead_210f94b423761d0b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(PMCNTENCLR_EL0_SysRegRead_5ac431b885c9c5e4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(MDCR_EL3_SysRegRead_229d5ee95c6e9850(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        return(ICC_SRE_EL2_SysRegRead_35c9349812c986fe(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b111) & op2 == 0b001 then {
        return(CNTPS_CTL_EL1_SysRegRead_e3bc6e5891147388(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0011) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(DACR32_EL2_SysRegRead_9571e2946627a596(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(LORC_EL1_SysRegRead_0067e90ee116c26f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(SPSR_und_SysRegRead_89a3b7c63cd43460(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b110 then {
        return(SSBS_SysRegRead_05419031832511d1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(CTR_EL0_SysRegRead_54ef8c769c3c6bba(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        return(ID_ISAR5_EL1_SysRegRead_f70928ed2f55c1f0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(ICH_HCR_EL2_SysRegRead_bd436f3e91661e3b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        return(ICC_IGRPEN0_EL1_SysRegRead_e575448f3c7e7a94(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(FPCR_SysRegRead_4176e216195c5686(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(PMCR_EL0_SysRegRead_9a03e454327a1718(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        return(DBGPRCR_EL1_SysRegRead_6b19d62af9619a21(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ID_ISAR1_EL1_SysRegRead_2f4500748023e22b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(ICC_BPR0_EL1_SysRegRead_6ada10a9051248c2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ID_AA64PFR1_EL1_SysRegRead_3be470f3d1bff138(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(PAN_SysRegRead_36ab36abf6da91e0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(MDCR_EL2_SysRegRead_f2181c815a998208(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(LORID_EL1_SysRegRead_a063108cc96d4baa(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(CONTEXTIDR_EL2_SysRegRead_f7bf9114ce3113a6(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(FPSR_SysRegRead_c1fde5c387acaca1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(CNTP_TVAL_EL0_SysRegRead_54cebb7fbc71b9db(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(CNTP_TVAL_EL02_SysRegRead_6539005e4eb68283(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(MIDR_EL1_SysRegRead_d49cc5f604ad167e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(ICC_RPR_EL1_SysRegRead_bea9edc41b26aab0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        return(ICH_ELRSR_EL2_SysRegRead_93859a236e9efe6d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ID_AA64DFR1_EL1_SysRegRead_2f066031859d7035(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & (match op2 {
      [bitzero, _, _] => true,
      _ => false
    }) : bool then {
        return(ICH_AP1R_EL2_SysRegRead_3ef1256520a6f18e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0111 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b100) & op2 == 0b000 then {
        return(DBGVCR32_EL2_SysRegRead_7986b2bdf8df010d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(ICC_IGRPEN1_EL1_SysRegRead_3cfd0733ef9b6efa(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        return(ID_MMFR5_EL1_SysRegRead_00dc6140c3593f6a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b101 then {
        return(DBGBCR_EL1_SysRegRead_2d021994672d40d3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1111 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        return(PMCCFILTR_EL0_SysRegRead_349918c2333bfc1e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        return(ICC_SRE_EL1_SysRegRead_7cf0aa9fc619dea4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        return(DBGCLAIMSET_EL1_SysRegRead_8557cf3b6272a9e8(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(ID_AA64AFR0_EL1_SysRegRead_325547f3ac10431a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(CPTR_EL2_SysRegRead_d80843789adc6a43(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(CPACR_EL1_SysRegRead_63b8f196f3ebba22(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & (match op2 {
      [bitzero, _, _] => true,
      _ => false
    }) : bool then {
        return(ICH_AP0R_EL2_SysRegRead_a38114229330a389(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(ICH_VTR_EL2_SysRegRead_2ed82d00af03b344(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        return(RMR_EL3_SysRegRead_fa5f18c3b20f8894(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b010) & op2 == 0b000 then {
        return(CSSELR_EL1_SysRegRead_102b4cddc07c9121(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(ID_ISAR6_EL1_SysRegRead_6ce3605912a2db6d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b000 then {
        return(MDCCINT_EL1_SysRegRead_12f1a0397d5a3729(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(ID_AFR0_EL1_SysRegRead_019e5ec822653217(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(UAO_SysRegRead_297f45f7f70ec250(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(CNTKCTL_EL1_SysRegRead_6a6cc900bc3c37df(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(CNTKCTL_EL12_SysRegRead_c23def3111264258(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(PMINTENCLR_EL1_SysRegRead_43b8f4d9b40b2620(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(SPSR_EL3_SysRegRead_fca96fc0dc593061(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        return(OSECCR_EL1_SysRegRead_264ab12a32fecc30(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(ID_DFR0_EL1_SysRegRead_12146217191b4fee(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        return(MDCCSR_EL0_SysRegRead_1ca0d9105cd616c5(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1101 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(PMXEVCNTR_EL0_SysRegRead_193921f886161922(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(MVFR2_EL1_SysRegRead_f6245ffc535897f2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1110 & CRn == 0b0111) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        return(DBGAUTHSTATUS_EL1_SysRegRead_6ade6e7a5265bcb7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ICC_IAR0_EL1_SysRegRead_dcfaf70befc09037(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(SCR_EL3_SysRegRead_082a69b26890132d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(ID_MMFR3_EL1_SysRegRead_dc45af19c356c392(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(PMUSERENR_EL0_SysRegRead_7efca1a4be376eb7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b111) & op2 == 0b000 then {
        return(CNTPS_TVAL_EL1_SysRegRead_0784a7de0899eff0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        return(ID_AA64AFR1_EL1_SysRegRead_99b67b76121ee706(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        return(OSDLR_EL1_SysRegRead_4cb80c508c4cced4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(CNTV_TVAL_EL02_SysRegRead_f904ccdf39aea128(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(PMCNTENSET_EL0_SysRegRead_848c3aa603193fb7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(VTCR_EL2_SysRegRead_5c8ea980dc5cc1d1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ICC_IAR1_EL1_SysRegRead_9f370ba68fd3e44f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b0111) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        return(DBGCLAIMCLR_EL1_SysRegRead_72ae03c1d5f667da(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(RMR_EL2_SysRegRead_75749340e0828f00(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(ID_PFR2_EL1_SysRegRead_8561b575e8dfcee0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(CurrentEL_SysRegRead_ac5b30a86a6a5003(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(CNTHV_CTL_EL2_SysRegRead_bc429f3d6b52b800(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(CNTV_CTL_EL0_SysRegRead_bcb2d1b80bdb9c23(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(ICH_MISR_EL2_SysRegRead_4e46f86d49bd21cd(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(SPSR_EL2_SysRegRead_63ec64f2f805090d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(SPSR_EL1_SysRegRead_32354aa2884c2edd(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ISR_EL1_SysRegRead_41b7dbf26b89e726(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(NZCV_SysRegRead_00499c04100376d9(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(ID_ISAR3_EL1_SysRegRead_cf9a1aae39d73bdd(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(PMINTENSET_EL1_SysRegRead_a3d4464c2051ff23(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        return(PMOVSSET_EL0_SysRegRead_e3c0657a6c8b11c8(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ID_PFR1_EL1_SysRegRead_264075958e26856b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        return(CNTFRQ_EL0_SysRegRead_891ca00adf0c3783(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        return(CPACR_EL12_SysRegRead_0f7867518c4e8e99(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        return(DBGDTRRX_EL0_SysRegRead_e7b48d8296f3b86b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(SPSR_EL12_SysRegRead_a8511792ae31e865(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(FPEXC32_EL2_SysRegRead_7ee503337da57806(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        return(MDSCR_EL1_SysRegRead_5184636ced539526(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(SPSel_SysRegRead_ac7632fd1580b15b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(SPSR_fiq_SysRegRead_390457aa85161af4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ID_PFR0_EL1_SysRegRead_ab73eb91d66cfece(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(SDER32_EL3_SysRegRead_e21f871563c7e34e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ID_ISAR0_EL1_SysRegRead_4e2f04c3a26dddb3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        return(DCZID_EL0_SysRegRead_dedd61ba7cee2913(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        return(PMOVSCLR_EL0_SysRegRead_300e5dfb491e58fa(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(CNTHP_CTL_EL2_SysRegRead_7103e47839f2c66b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(CNTHP_TVAL_EL2_SysRegRead_d110a1f1616c9f8f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(CNTHCTL_EL2_SysRegRead_5f510d633361c720(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        return(OSDTRRX_EL1_SysRegRead_d4eb07360bc69d28(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(IFSR32_EL2_SysRegRead_3b41290786c143ba(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b111 then {
        return(ICC_IGRPEN1_EL3_SysRegRead_d192d252016b4c8d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        return(ID_MMFR1_EL1_SysRegRead_b0f4bc0d71c9af14(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1101 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(PMXEVTYPER_EL0_SysRegRead_a34d7cb6f32074c5(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b111 then {
        return(DBGWCR_EL1_SysRegRead_03139d052b544b2f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        return(CPTR_EL3_SysRegRead_33cb1e5ec3c99661(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(ESR_EL3_SysRegRead_e0eabec0b099e366(el, op0, op1, CRn, op2, CRm))
    } else ();
    if ((((match CRm {
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        return(PMEVTYPER_EL0_SysRegRead_b05172ff9d10dad4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(CNTV_CTL_EL02_SysRegRead_4188a8e2bc5c07aa(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b101 then {
        return(ICC_SRE_EL3_SysRegRead_c7d421022a5f589d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(ID_MMFR0_EL1_SysRegRead_b31c5faa39841084(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        return(OSDTRTX_EL1_SysRegRead_008c22058272684f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(VPIDR_EL2_SysRegRead_f6520cd6a1f62bd8(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(MPAMHCR_EL2_SysRegRead_6ee5f61be808e32e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(MPAMVPMV_EL2_SysRegRead_6de5731367257b91(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(PMSCR_EL2_SysRegRead_11330bd80566814a(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(PMSCR_EL1_SysRegRead_39ffc554ca37b155(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(PMSIRR_EL1_SysRegRead_b565329ce30ac491(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(PMSFCR_EL1_SysRegRead_30b07ff27088a488(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        return(PMBSR_EL1_SysRegRead_87628bec330b9f53(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(PMSCR_EL12_SysRegRead_624c386ea3cce853(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(PMSIDR_EL1_SysRegRead_062cecff79d24b4d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        return(PMBIDR_EL1_SysRegRead_306c3f68e41521a3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        return(PMSLATFR_EL1_SysRegRead_f82542fec2521a41(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(VDISR_EL2_SysRegRead_14dff4ad4ae8c3a2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(DISR_EL1_SysRegRead_d06ce25101dac895(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(ERRIDR_EL1_SysRegRead_41b56b8d34e51109(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(VSESR_EL2_SysRegRead_401c063e57574698(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(ERRSELR_EL1_SysRegRead_1bcf942400e8d57f(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        return(CHCR_EL2_SysRegRead_7d3c39a46321f1a2(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(CCTLR_EL0_SysRegRead_3baa7e22d96a4ce4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        return(CCTLR_EL3_SysRegRead_9121a22ebc361586(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        return(CCTLR_EL1_SysRegRead_de402a061eecb9b9(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        return(CCTLR_EL12_SysRegRead_e8b17aabd47dc7a1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(CCTLR_EL2_SysRegRead_fca4364f27bb9f9b(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b011 then {
        return(CSCR_EL3_SysRegRead_3c6b19768f9cd209(el, op0, op1, CRn, op2, CRm))
    } else ();
    throw(Error_Undefined());
    return(undefined : bits(64))
}

val AArch64_SysRegRead : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(64) effect {escape, rreg, undef, wreg}

function AArch64_SysRegRead (op0, op1, crn, crm, op2) = {
    value_name : bits(64) = AArch64_AutoGen_SysRegRead(PSTATE.EL, op0[1 .. 0], op1[2 .. 0], crn[3 .. 0], op2[2 .. 0], crm[3 .. 0]);
    if (((op0 == 3 & crn == UInt(0xc)) & op1 == 0) & op2 == 0) & crm == 1 then {
        return(ZeroExtend(getISR()))
    } else ();
    if (((op0 == 3 & crn == 0) & op1 == 0) & op2 == 5) & crm == 0 then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            return(VMPIDR_EL2)
        } else ()
    } else ();
    if (((op0 == 3 & crn == 0) & op1 == 0) & op2 == 0) & crm == 0 then {
        if PSTATE.EL == EL1 & EL2Enabled() then {
            return(ZeroExtend(VPIDR_EL2))
        } else ()
    } else ();
    if (((op0 == 3 & crn == 0) & op1 == 3) & op2 == 7) & crm == 0 then {
        if PSTATE.EL == EL0 & (Slice(SCTLR_EL1, 14, 1) == 0b0 | Slice(HCR_EL2, 28, 1) == 0b1) | PSTATE.EL == EL1 & Slice(HCR_EL2, 28, 1) == 0b1 then {
            value_name = ZeroExtend(DCZID_EL0[31 .. 0]);
            value_name[4] = Bit(0b1);
            return(value_name)
        } else ()
    } else ();
    return(value_name)
}

val CDBGDTR_EL0_CapSysRegRead_8e23daae0e60af34 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CDBGDTR_EL0_CapSysRegRead_8e23daae0e60af34 (el, op0, op1, CRn, op2, CRm) = {
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if not_bool(Halted()) then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if (((PSTATE.EL == EL1 | PSTATE.EL == EL0) & not_bool(ELUsingAArch32(EL1))) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        }
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
        AArch64_SystemAccessTrap(EL3, UInt(0x29));
        return(undefined : bits(129))
    } else {
        return(CDBGDTR_EL0)
    }
}

val CDLR_EL0_CapSysRegRead_619c852c71c0978d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CDLR_EL0_CapSysRegRead_619c852c71c0978d (el, op0, op1, CRn, op2, CRm) = {
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if not_bool(Halted()) then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if (((PSTATE.EL == EL1 | PSTATE.EL == EL0) & not_bool(ELUsingAArch32(EL1))) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        }
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
        AArch64_SystemAccessTrap(EL3, UInt(0x29));
        return(undefined : bits(129))
    } else {
        return(CDLR_EL0)
    }
}

val CELR_EL12_CapSysRegRead_4bf271777fe55d1c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CELR_EL12_CapSysRegRead_4bf271777fe55d1c (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
              [_, bitzero] => true,
              _ => false
            }) : bool then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29));
                return(undefined : bits(129))
            } else {
                return(ELR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(129))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29));
                return(undefined : bits(129))
            } else {
                return(ELR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(129))
        }
    } else {
        return(undefined : bits(129))
    }
}

val CELR_EL1_CapSysRegRead_da9869d2314a30d5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CELR_EL1_CapSysRegRead_da9869d2314a30d5 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(ELR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(ELR_EL2)
        } else {
            return(ELR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(ELR_EL1)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CELR_EL2_CapSysRegRead_a9e9661da428a6d4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CELR_EL2_CapSysRegRead_a9e9661da428a6d4 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(ELR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(ELR_EL2)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CELR_EL3_CapSysRegRead_d0424a232c45967e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CELR_EL3_CapSysRegRead_d0424a232c45967e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(ELR_EL3)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CID_EL0_CapSysRegRead_d560f6b1104266f1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CID_EL0_CapSysRegRead_d560f6b1104266f1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(129))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(CID_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(CID_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(CID_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(CID_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CSP_EL0_CapSysRegRead_e5b1ba121f8be4da : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CSP_EL0_CapSysRegRead_e5b1ba121f8be4da (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(SP_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(SP_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(SP_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CSP_EL1_CapSysRegRead_bb8b6c0ba689eafb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CSP_EL1_CapSysRegRead_bb8b6c0ba689eafb (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(SP_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(SP_EL1)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CSP_EL2_CapSysRegRead_9b50d2f92d5520da : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CSP_EL2_CapSysRegRead_9b50d2f92d5520da (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(SP_EL2)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CTPIDRRO_EL0_CapSysRegRead_2def4a85803ae7cc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CTPIDRRO_EL0_CapSysRegRead_2def4a85803ae7cc (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(129))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDRRO_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDRRO_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDRRO_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDRRO_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CTPIDR_EL0_CapSysRegRead_84b933ea55a77369 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CTPIDR_EL0_CapSysRegRead_84b933ea55a77369 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(129))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0)
        } else {
            return(TPIDR_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDR_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDR_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDR_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CTPIDR_EL1_CapSysRegRead_016308c12b886084 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CTPIDR_EL1_CapSysRegRead_016308c12b886084 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0)
        } else {
            return(TPIDR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDR_EL1)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CTPIDR_EL2_CapSysRegRead_b7d4714a1ce62544 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CTPIDR_EL2_CapSysRegRead_b7d4714a1ce62544 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0)
        } else {
            return(TPIDR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(TPIDR_EL2)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CTPIDR_EL3_CapSysRegRead_c1307a9bc7bc1449 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CTPIDR_EL3_CapSysRegRead_c1307a9bc7bc1449 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return(RTPIDR_EL0)
        } else {
            return(TPIDR_EL3)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CVBAR_EL12_CapSysRegRead_845c94ac498ff593 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CVBAR_EL12_CapSysRegRead_845c94ac498ff593 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x2A));
                    return(undefined : bits(129))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x2A));
                    return(undefined : bits(129))
                }
            } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
              [_, bitzero] => true,
              _ => false
            }) : bool then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29));
                return(undefined : bits(129))
            } else {
                return(VBAR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(129))
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A));
                return(undefined : bits(129))
            } else if __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29));
                return(undefined : bits(129))
            } else {
                return(VBAR_EL1)
            }
        } else {
            throw(Error_Undefined());
            return(undefined : bits(129))
        }
    } else {
        return(undefined : bits(129))
    }
}

val CVBAR_EL1_CapSysRegRead_c42109445741a0d0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CVBAR_EL1_CapSysRegRead_c42109445741a0d0 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x2A));
                return(undefined : bits(129))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x2A));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A));
                return(undefined : bits(129))
            }
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(VBAR_EL1)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x2A));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A));
                return(undefined : bits(129))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 then {
            return(VBAR_EL2)
        } else {
            return(VBAR_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x2A));
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(VBAR_EL1)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CVBAR_EL2_CapSysRegRead_537232bbd7d69e00 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CVBAR_EL2_CapSysRegRead_537232bbd7d69e00 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x2A));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A));
                return(undefined : bits(129))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(VBAR_EL2)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x2A));
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(VBAR_EL2)
        }
    } else {
        return(undefined : bits(129))
    }
}

val CVBAR_EL3_CapSysRegRead_587d4a028f8f0ef1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function CVBAR_EL3_CapSysRegRead_587d4a028f8f0ef1 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x2A));
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(VBAR_EL3)
        }
    } else {
        return(undefined : bits(129))
    }
}

register DDC_EL0 : bits(129)

register DDC_EL1 : bits(129)

register DDC_EL2 : bits(129)

register DDC_EL3 : bits(129)

register RDDC_EL0 : bits(129)

val DDC_CapSysRegRead_eabc4ea34a10a962 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function DDC_CapSysRegRead_eabc4ea34a10a962 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    if ((__PSTATE_EL == EL0 & not_bool(ELUsingAArch32(EL1))) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
        if EL2Enabled() & __HCR_EL2_TGE == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        }
    } else if __PSTATE_EL == EL1 & (match __CPACR_EL1_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL1, UInt(0x29));
        return(undefined : bits(129))
    } else if ((((__PSTATE_EL == EL1 | __PSTATE_EL == EL0 | __PSTATE_EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if ((((__PSTATE_EL == EL1 | __PSTATE_EL == EL0 | __PSTATE_EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if ((((__PSTATE_EL == EL1 | __PSTATE_EL == EL0 | __PSTATE_EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29));
        return(undefined : bits(129))
    } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
        AArch64_SystemAccessTrap(EL3, UInt(0x29));
        return(undefined : bits(129))
    } else if IsInRestricted() then {
        return(RDDC_EL0)
    } else if __PSTATE_SP == 0b0 then {
        return(DDC_EL0)
    } else if __PSTATE_EL == EL0 then {
        return(DDC_EL0)
    } else if __PSTATE_EL == EL1 then {
        return(DDC_EL1)
    } else if __PSTATE_EL == EL2 then {
        return(DDC_EL2)
    } else if __PSTATE_EL == EL3 then {
        return(DDC_EL3)
    } else {
        return(undefined : bits(129))
    }
}

val DDC_EL0_CapSysRegRead_e02bc676dce7fb51 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function DDC_EL0_CapSysRegRead_e02bc676dce7fb51 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(DDC_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(DDC_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(DDC_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val DDC_EL1_CapSysRegRead_08f46354e9afc01e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function DDC_EL1_CapSysRegRead_08f46354e9afc01e (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(DDC_EL1)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(DDC_EL1)
        }
    } else {
        return(undefined : bits(129))
    }
}

val DDC_EL2_CapSysRegRead_6d2409222a719403 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function DDC_EL2_CapSysRegRead_6d2409222a719403 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined());
        return(undefined : bits(129))
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(DDC_EL2)
        }
    } else {
        return(undefined : bits(129))
    }
}

val RCSP_EL0_CapSysRegRead_6a9b29b9027548c3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function RCSP_EL0_CapSysRegRead_6a9b29b9027548c3 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(129))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RSP_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RSP_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RSP_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RSP_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val RCTPIDR_EL0_CapSysRegRead_0a3ce9d2144ddba7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function RCTPIDR_EL0_CapSysRegRead_0a3ce9d2144ddba7 (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(129))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RTPIDR_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RTPIDR_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RTPIDR_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RTPIDR_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val RDDC_EL0_CapSysRegRead_c188e736aa7b9beb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function RDDC_EL0_CapSysRegRead_c188e736aa7b9beb (el, op0, op1, CRn, op2, CRm) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29));
                return(undefined : bits(129))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29));
                return(undefined : bits(129))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RDDC_EL0)
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RDDC_EL0)
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29));
            return(undefined : bits(129))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RDDC_EL0)
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined());
            return(undefined : bits(129))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29));
            return(undefined : bits(129))
        } else {
            return(RDDC_EL0)
        }
    } else {
        return(undefined : bits(129))
    }
}

val AArch64_AutoGen_CapSysRegRead : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4)) -> bits(129) effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_CapSysRegRead (el, op0, op1, CRn, op2, CRm) = {
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        return(CTPIDR_EL1_CapSysRegRead_016308c12b886084(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(CSP_EL2_CapSysRegRead_9b50d2f92d5520da(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(CELR_EL2_CapSysRegRead_a9e9661da428a6d4(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(CELR_EL1_CapSysRegRead_da9869d2314a30d5(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        return(CTPIDRRO_EL0_CapSysRegRead_2def4a85803ae7cc(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        return(CTPIDR_EL2_CapSysRegRead_b7d4714a1ce62544(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        return(CTPIDR_EL0_CapSysRegRead_84b933ea55a77369(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(CSP_EL1_CapSysRegRead_bb8b6c0ba689eafb(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(CELR_EL3_CapSysRegRead_d0424a232c45967e(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(CSP_EL0_CapSysRegRead_e5b1ba121f8be4da(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        return(CTPIDR_EL3_CapSysRegRead_c1307a9bc7bc1449(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        return(CVBAR_EL2_CapSysRegRead_537232bbd7d69e00(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        return(CVBAR_EL1_CapSysRegRead_c42109445741a0d0(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        return(CVBAR_EL3_CapSysRegRead_587d4a028f8f0ef1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        return(CVBAR_EL12_CapSysRegRead_845c94ac498ff593(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        return(CELR_EL12_CapSysRegRead_4bf271777fe55d1c(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        return(DDC_EL2_CapSysRegRead_6d2409222a719403(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(DDC_CapSysRegRead_eabc4ea34a10a962(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b100 then {
        return(RCTPIDR_EL0_CapSysRegRead_0a3ce9d2144ddba7(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        return(CID_EL0_CapSysRegRead_d560f6b1104266f1(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(CDLR_EL0_CapSysRegRead_619c852c71c0978d(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b111) & op2 == 0b011 then {
        return(RCSP_EL0_CapSysRegRead_6a9b29b9027548c3(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        return(RDDC_EL0_CapSysRegRead_c188e736aa7b9beb(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        return(DDC_EL0_CapSysRegRead_e02bc676dce7fb51(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        return(CDBGDTR_EL0_CapSysRegRead_8e23daae0e60af34(el, op0, op1, CRn, op2, CRm))
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        return(DDC_EL1_CapSysRegRead_08f46354e9afc01e(el, op0, op1, CRn, op2, CRm))
    } else ();
    throw(Error_Undefined());
    return(undefined : bits(129))
}

val DDC_read : unit -> bits(129) effect {rreg, undef}

function DDC_read () = {
    if IsInRestricted() then {
        return(RDDC_EL0)
    } else if PSTATE.SP == 0b0 then {
        return(DDC_EL0)
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              return(DDC_EL0)
          },
          ? if ? == EL1 => {
              return(DDC_EL1)
          },
          ? if ? == EL2 => {
              return(DDC_EL2)
          },
          ? if ? == EL3 => {
              return(DDC_EL3)
          },
          _ => {
              return(undefined : bits(129))
          }
        }
    }
}

val AArch64_CapSysRegRead : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(129) effect {escape, rreg, undef, wreg}

function AArch64_CapSysRegRead (op0, op1, crn, crm, op2) = {
    let is_ddc : bool = (((op0 == 3 & op1 == 3) & crn == 4) & crm == 1) & op2 == 1;
    if is_ddc then {
        return(DDC_read())
    } else ();
    let value_name : bits(129) = AArch64_AutoGen_CapSysRegRead(PSTATE.EL, op0[1 .. 0], op1[2 .. 0], crn[3 .. 0], op2[2 .. 0], crm[3 .. 0]);
    return(value_name)
}

val ACTLR_EL1_SysRegWrite_338051dbe9bdf650 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ACTLR_EL1_SysRegWrite_338051dbe9bdf650 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TACR : bits(1) = Slice(HCR_EL2, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TACR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ACTLR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            ACTLR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ACTLR_EL1 = val_name;
            return()
        }
    } else ()
}

val ACTLR_EL2_SysRegWrite_416ec7c6fadd122d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ACTLR_EL2_SysRegWrite_416ec7c6fadd122d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            ACTLR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ACTLR_EL2 = val_name;
            return()
        }
    } else ()
}

val ACTLR_EL3_SysRegWrite_c797d5a80525afa4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ACTLR_EL3_SysRegWrite_c797d5a80525afa4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ACTLR_EL3 = val_name;
            return()
        }
    } else ()
}

val AFSR0_EL12_SysRegWrite_9fafb4f6dbddd904 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR0_EL12_SysRegWrite_9fafb4f6dbddd904 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                AFSR0_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                AFSR0_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val AFSR0_EL1_SysRegWrite_04474930979e1c86 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR0_EL1_SysRegWrite_04474930979e1c86 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            AFSR0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            AFSR0_EL2 = val_name;
            return()
        } else {
            AFSR0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AFSR0_EL1 = val_name;
            return()
        }
    } else ()
}

val AFSR0_EL2_SysRegWrite_2f9da4789f5b4073 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR0_EL2_SysRegWrite_2f9da4789f5b4073 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AFSR0_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AFSR0_EL2 = val_name;
            return()
        }
    } else ()
}

val AFSR0_EL3_SysRegWrite_e615501306210a25 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR0_EL3_SysRegWrite_e615501306210a25 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AFSR0_EL3 = val_name;
            return()
        }
    } else ()
}

val AFSR1_EL12_SysRegWrite_9dbf207cccd92d9d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR1_EL12_SysRegWrite_9dbf207cccd92d9d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                AFSR1_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                AFSR1_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val AFSR1_EL1_SysRegWrite_6690138c9fdd136c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR1_EL1_SysRegWrite_6690138c9fdd136c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            AFSR1_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            AFSR1_EL2 = val_name;
            return()
        } else {
            AFSR1_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AFSR1_EL1 = val_name;
            return()
        }
    } else ()
}

val AFSR1_EL2_SysRegWrite_c0ebc4cc65472544 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR1_EL2_SysRegWrite_c0ebc4cc65472544 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AFSR1_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AFSR1_EL2 = val_name;
            return()
        }
    } else ()
}

val AFSR1_EL3_SysRegWrite_d776cc264803f49e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AFSR1_EL3_SysRegWrite_d776cc264803f49e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AFSR1_EL3 = val_name;
            return()
        }
    } else ()
}

val AMAIR_EL12_SysRegWrite_9c44aba2de7c2ff8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AMAIR_EL12_SysRegWrite_9c44aba2de7c2ff8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                AMAIR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                AMAIR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val AMAIR_EL1_SysRegWrite_0d9c3d92d9a71703 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AMAIR_EL1_SysRegWrite_0d9c3d92d9a71703 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            AMAIR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            AMAIR_EL2 = val_name;
            return()
        } else {
            AMAIR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AMAIR_EL1 = val_name;
            return()
        }
    } else ()
}

val AMAIR_EL2_SysRegWrite_9345da970d78b298 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AMAIR_EL2_SysRegWrite_9345da970d78b298 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AMAIR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AMAIR_EL2 = val_name;
            return()
        }
    } else ()
}

val AMAIR_EL3_SysRegWrite_622c473bfedac80a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AMAIR_EL3_SysRegWrite_622c473bfedac80a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AMAIR_EL3 = val_name;
            return()
        }
    } else ()
}

val CCTLR_EL0_SysRegWrite_a4d8c57cb436292b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CCTLR_EL0_SysRegWrite_a4d8c57cb436292b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CCTLR_EL12_SysRegWrite_c7d9d6463096d910 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CCTLR_EL12_SysRegWrite_c7d9d6463096d910 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
              [_, bitzero] => true,
              _ => false
            }) : bool then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29))
            } else {
                CCTLR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else if __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29))
            } else {
                CCTLR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CCTLR_EL1_SysRegWrite_dc20ad2a867ac9bf : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CCTLR_EL1_SysRegWrite_dc20ad2a867ac9bf (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 then {
            CCTLR_EL2 = val_name[31 .. 0];
            return()
        } else {
            CCTLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CCTLR_EL2_SysRegWrite_65620c8ccb1113a5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CCTLR_EL2_SysRegWrite_65620c8ccb1113a5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CCTLR_EL3_SysRegWrite_f5e936c8846e6fc7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CCTLR_EL3_SysRegWrite_f5e936c8846e6fc7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CCTLR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CHCR_EL2_SysRegWrite_dadda8ecf053e448 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CHCR_EL2_SysRegWrite_dadda8ecf053e448 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CHCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CHCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTFRQ_EL0_SysRegWrite_0fac77f077759456 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTFRQ_EL0_SysRegWrite_0fac77f077759456 (el, op0, op1, CRn, op2, CRm, val_name) = {
    if IsHighestEL(PSTATE.EL) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTFRQ_EL0 = val_name[31 .. 0];
            return()
        }
    } else {
        throw(Error_Undefined())
    }
}

val CNTHCTL_EL2_SysRegWrite_eb0cbec9f9398e0e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHCTL_EL2_SysRegWrite_eb0cbec9f9398e0e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHCTL_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHCTL_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTHP_CTL_EL2_SysRegWrite_92034fc54290a7b8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHP_CTL_EL2_SysRegWrite_92034fc54290a7b8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHP_CTL_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHP_CTL_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTHP_CVAL_EL2_SysRegWrite_36de219faded7cbc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHP_CVAL_EL2_SysRegWrite_36de219faded7cbc (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHP_CVAL_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHP_CVAL_EL2 = val_name;
            return()
        }
    } else ()
}

val CNTHP_TVAL_EL2_SysRegWrite_877bbf4f78f810b9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHP_TVAL_EL2_SysRegWrite_877bbf4f78f810b9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHP_TVAL_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHP_TVAL_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTHV_CTL_EL2_SysRegWrite_ecc786a588fc8ab9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHV_CTL_EL2_SysRegWrite_ecc786a588fc8ab9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHV_CTL_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHV_CTL_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTHV_CVAL_EL2_SysRegWrite_b3d7c631e2b3eaab : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHV_CVAL_EL2_SysRegWrite_b3d7c631e2b3eaab (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHV_CVAL_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHV_CVAL_EL2 = val_name;
            return()
        }
    } else ()
}

val CNTHV_TVAL_EL2_SysRegWrite_e215d12d330397f1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTHV_TVAL_EL2_SysRegWrite_e215d12d330397f1 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTHV_TVAL_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTHV_TVAL_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTKCTL_EL12_SysRegWrite_518123f17a6402e4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTKCTL_EL12_SysRegWrite_518123f17a6402e4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTKCTL_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTKCTL_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTKCTL_EL1_SysRegWrite_9a7be69aa33bb9c2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTKCTL_EL1_SysRegWrite_9a7be69aa33bb9c2 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTKCTL_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            CNTHCTL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTKCTL_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTKCTL_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTPS_CTL_EL1_SysRegWrite_a0625fd9f7b035a8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTPS_CTL_EL1_SysRegWrite_a0625fd9f7b035a8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __SCR_EL3_ST : bits(1) = Slice(SCR_EL3, 11, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if HaveEL(EL3) & __SCR_EL3_NS == 0b0 then {
            if __SCR_EL3_ST == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTPS_CTL_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTPS_CTL_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTPS_CVAL_EL1_SysRegWrite_f09243080b7c260d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTPS_CVAL_EL1_SysRegWrite_f09243080b7c260d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __SCR_EL3_ST : bits(1) = Slice(SCR_EL3, 11, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if HaveEL(EL3) & __SCR_EL3_NS == 0b0 then {
            if __SCR_EL3_ST == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTPS_CVAL_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTPS_CVAL_EL1 = val_name;
            return()
        }
    } else ()
}

val CNTPS_TVAL_EL1_SysRegWrite_a9b16e60037fa746 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTPS_TVAL_EL1_SysRegWrite_a9b16e60037fa746 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __SCR_EL3_ST : bits(1) = Slice(SCR_EL3, 11, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if HaveEL(EL3) & __SCR_EL3_NS == 0b0 then {
            if __SCR_EL3_ST == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTPS_TVAL_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTPS_TVAL_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTP_CTL_EL02_SysRegWrite_99a9da3e2454714e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTP_CTL_EL02_SysRegWrite_99a9da3e2454714e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTP_CTL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTP_CTL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTP_CTL_EL0_SysRegWrite_137f81090c1357e6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTP_CTL_EL0_SysRegWrite_137f81090c1357e6 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PTEN : bits(1) = Slice(CNTKCTL_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PTEN : bits(1) = Slice(CNTHCTL_EL2, 11, 1);
    let __CNTHCTL_EL2_EL0PTEN : bits(1) = Slice(CNTHCTL_EL2, 9, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            CNTHPS_CTL_EL2 = val_name[31 .. 0];
            return()
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            CNTHP_CTL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTP_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CNTP_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            CNTHPS_CTL_EL2 = val_name[31 .. 0];
            return()
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            CNTHP_CTL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTP_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTP_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTP_CVAL_EL02_SysRegWrite_2b3e9ccfce186a4f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTP_CVAL_EL02_SysRegWrite_2b3e9ccfce186a4f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTP_CVAL_EL0 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTP_CVAL_EL0 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTP_CVAL_EL0_SysRegWrite_d54c08ee0cf9aaf7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTP_CVAL_EL0_SysRegWrite_d54c08ee0cf9aaf7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PTEN : bits(1) = Slice(CNTKCTL_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PTEN : bits(1) = Slice(CNTHCTL_EL2, 11, 1);
    let __CNTHCTL_EL2_EL0PTEN : bits(1) = Slice(CNTHCTL_EL2, 9, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            CNTHPS_CVAL_EL2 = val_name;
            return()
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            CNTHP_CVAL_EL2 = val_name;
            return()
        } else {
            CNTP_CVAL_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CNTP_CVAL_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            CNTHPS_CVAL_EL2 = val_name;
            return()
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            CNTHP_CVAL_EL2 = val_name;
            return()
        } else {
            CNTP_CVAL_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTP_CVAL_EL0 = val_name;
            return()
        }
    } else ()
}

val CNTP_TVAL_EL02_SysRegWrite_caa9f2aa73cb6b96 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTP_TVAL_EL02_SysRegWrite_caa9f2aa73cb6b96 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTP_TVAL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTP_TVAL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTP_TVAL_EL0_SysRegWrite_d7441eec23c3d524 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTP_TVAL_EL0_SysRegWrite_d7441eec23c3d524 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0PTEN : bits(1) = Slice(CNTKCTL_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CNTHCTL_EL2_EL1PCEN : bits(1) = Slice(CNTHCTL_EL2, 1, 1);
    let __CNTHCTL_EL2_EL1PTEN : bits(1) = Slice(CNTHCTL_EL2, 11, 1);
    let __CNTHCTL_EL2_EL0PTEN : bits(1) = Slice(CNTHCTL_EL2, 9, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0PTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b10) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            CNTHPS_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            CNTHP_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTP_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b0) & __CNTHCTL_EL2_EL1PCEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & __CNTHCTL_EL2_EL1PTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CNTP_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            CNTHPS_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            CNTHP_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTP_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTP_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTVOFF_EL2_SysRegWrite_621ada4cfda60bcb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTVOFF_EL2_SysRegWrite_621ada4cfda60bcb (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTVOFF_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTVOFF_EL2 = val_name;
            return()
        }
    } else ()
}

val CNTV_CTL_EL02_SysRegWrite_d6cac9cc52dd8fec : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTV_CTL_EL02_SysRegWrite_d6cac9cc52dd8fec (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTV_CTL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTV_CTL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTV_CTL_EL0_SysRegWrite_e9fd22bae4b06064 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTV_CTL_EL0_SysRegWrite_e9fd22bae4b06064 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VTEN : bits(1) = Slice(CNTKCTL_EL1, 8, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VTEN : bits(1) = Slice(CNTHCTL_EL2, 8, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            CNTHVS_CTL_EL2 = val_name[31 .. 0];
            return()
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            CNTHV_CTL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTV_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTV_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            CNTHVS_CTL_EL2 = val_name[31 .. 0];
            return()
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            CNTHV_CTL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTV_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTV_CTL_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CNTV_CVAL_EL02_SysRegWrite_7548964ed28b5abb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTV_CVAL_EL02_SysRegWrite_7548964ed28b5abb (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTV_CVAL_EL0 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTV_CVAL_EL0 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTV_CVAL_EL0_SysRegWrite_f237c5c94ec92951 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTV_CVAL_EL0_SysRegWrite_f237c5c94ec92951 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VTEN : bits(1) = Slice(CNTKCTL_EL1, 8, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VTEN : bits(1) = Slice(CNTHCTL_EL2, 8, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            CNTHVS_CVAL_EL2 = val_name;
            return()
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            CNTHV_CVAL_EL2 = val_name;
            return()
        } else {
            CNTV_CVAL_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTV_CVAL_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            CNTHVS_CVAL_EL2 = val_name;
            return()
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            CNTHV_CVAL_EL2 = val_name;
            return()
        } else {
            CNTV_CVAL_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTV_CVAL_EL0 = val_name;
            return()
        }
    } else ()
}

val CNTV_TVAL_EL02_SysRegWrite_dc97f79a5f74078f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTV_TVAL_EL02_SysRegWrite_dc97f79a5f74078f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CNTV_TVAL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CNTV_TVAL_EL0 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CNTV_TVAL_EL0_SysRegWrite_903191acca729cda : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CNTV_TVAL_EL0_SysRegWrite_903191acca729cda (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CNTKCTL_EL1_EL0VTEN : bits(1) = Slice(CNTKCTL_EL1, 8, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CNTHCTL_EL2_EL0VTEN : bits(1) = Slice(CNTHCTL_EL2, 8, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CNTKCTL_EL1_EL0VTEN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CNTHCTL_EL2_EL0VTEN == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b0 then {
            CNTHVS_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCR_EL3_NS == 0b1 then {
            CNTHV_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTV_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CNTV_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b0 then {
            CNTHVS_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else if __HCR_EL2_E2H == 0b1 & __SCR_EL3_NS == 0b1 then {
            CNTHV_TVAL_EL2 = val_name[31 .. 0];
            return()
        } else {
            CNTV_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CNTV_TVAL_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CONTEXTIDR_EL12_SysRegWrite_33154953ae1b01d5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CONTEXTIDR_EL12_SysRegWrite_33154953ae1b01d5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                CONTEXTIDR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CONTEXTIDR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CONTEXTIDR_EL1_SysRegWrite_5408e4e72af4e23d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CONTEXTIDR_EL1_SysRegWrite_5408e4e72af4e23d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CONTEXTIDR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            CONTEXTIDR_EL2 = val_name[31 .. 0];
            return()
        } else {
            CONTEXTIDR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CONTEXTIDR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CONTEXTIDR_EL2_SysRegWrite_27187b6dc7c5a748 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CONTEXTIDR_EL2_SysRegWrite_27187b6dc7c5a748 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CONTEXTIDR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CONTEXTIDR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CPACR_EL12_SysRegWrite_637092a999939f8b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CPACR_EL12_SysRegWrite_637092a999939f8b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL3_TCPAC : bits(1) = Slice(CPTR_EL3, 31, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CPACR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                CPACR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CPACR_EL1_SysRegWrite_00878a1f3e87823c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CPACR_EL1_SysRegWrite_00878a1f3e87823c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL2_TCPAC : bits(1) = Slice(CPTR_EL2, 31, 1);
    let __CPTR_EL3_TCPAC : bits(1) = Slice(CPTR_EL3, 31, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __CPTR_EL2_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CPACR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __HCR_EL2_E2H == 0b1 then {
            CPTR_EL2 = val_name[31 .. 0];
            return()
        } else {
            CPACR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CPACR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CPTR_EL2_SysRegWrite_5a082f460b1b2308 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CPTR_EL2_SysRegWrite_5a082f460b1b2308 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_TCPAC : bits(1) = Slice(CPTR_EL3, 31, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TCPAC == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CPTR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CPTR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CPTR_EL3_SysRegWrite_879d4b1bad53408b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CPTR_EL3_SysRegWrite_879d4b1bad53408b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CPTR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CSCR_EL3_SysRegWrite_22b95c83b04d6c91 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CSCR_EL3_SysRegWrite_22b95c83b04d6c91 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CSCR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val CSSELR_EL1_SysRegWrite_1f9e1e0300c8783c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CSSELR_EL1_SysRegWrite_1f9e1e0300c8783c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TID2 : bits(1) = Slice(HCR_EL2, 17, 1);
    let __HCR_EL2_TID4 : bits(1) = Slice(HCR_EL2, 49, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID2 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TID4 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CSSELR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CSSELR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CSSELR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DACR32_EL2_SysRegWrite_a8bad0131817f121 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DACR32_EL2_SysRegWrite_a8bad0131817f121 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DACR32_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DACR32_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DAIF_SysRegWrite_3d31f214debf624b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DAIF_SysRegWrite_3d31f214debf624b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UMA : bits(1) = Slice(SCTLR_EL1, 9, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    if __PSTATE_EL == EL0 then {
        if not_bool(ELUsingAArch32(EL1)) & (EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | __SCTLR_EL1_UMA == 0b0) then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else {
            (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = val_name[9 .. 6];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = val_name[9 .. 6];
        return()
    } else if __PSTATE_EL == EL2 then {
        (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = val_name[9 .. 6];
        return()
    } else if __PSTATE_EL == EL3 then {
        (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = val_name[9 .. 6];
        return()
    } else ()
}

val DBGBCR_EL1_SysRegWrite_6730f3e3839510c5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGBCR_EL1_SysRegWrite_6730f3e3839510c5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGBCR_EL1[UInt(CRm[3 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGBCR_EL1[UInt(CRm[3 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGBCR_EL1[UInt(CRm[3 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DBGBVR_EL1_SysRegWrite_915752bfd6a41a2b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGBVR_EL1_SysRegWrite_915752bfd6a41a2b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGBVR_EL1[UInt(CRm[3 .. 0])] = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGBVR_EL1[UInt(CRm[3 .. 0])] = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGBVR_EL1[UInt(CRm[3 .. 0])] = val_name;
            return()
        }
    } else ()
}

val DBGCLAIMCLR_EL1_SysRegWrite_2a099a67767e57cf : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGCLAIMCLR_EL1_SysRegWrite_2a099a67767e57cf (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGCLAIMCLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGCLAIMCLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGCLAIMCLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DBGCLAIMSET_EL1_SysRegWrite_90e355b6a5730770 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGCLAIMSET_EL1_SysRegWrite_90e355b6a5730770 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGCLAIMSET_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGCLAIMSET_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGCLAIMSET_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register DBGDTRTX_EL0 : bits(32)

val DBGDTRTX_EL0_SysRegWrite_057e8c91e001a69f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGDTRTX_EL0_SysRegWrite_057e8c91e001a69f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDSCR_EL1_TDCC : bits(1) = Slice(MDSCR_EL1, 12, 1);
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if Halted() then {
        DBGDTRTX_EL0 = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __MDSCR_EL1_TDCC == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 27, 1) == 0b1 | (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTRTX_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTRTX_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTRTX_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTRTX_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DBGDTR_EL0_write : bits(64) -> unit effect {wreg}

function DBGDTR_EL0_write val_name = {
    let r : bits(64) = val_name;
    CDBGDTR_EL0 = ZeroExtend(r);
    return()
}

val DBGDTR_EL0_SysRegWrite_c7246a22e06c7729 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGDTR_EL0_SysRegWrite_c7246a22e06c7729 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDSCR_EL1_TDCC : bits(1) = Slice(MDSCR_EL1, 12, 1);
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if Halted() then {
        DBGDTR_EL0_write() = val_name;
        return()
    } else if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __MDSCR_EL1_TDCC == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 27, 1) == 0b1 | (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTR_EL0_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTR_EL0_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTR_EL0_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGDTR_EL0_write() = val_name;
            return()
        }
    } else ()
}

val DBGPRCR_EL1_SysRegWrite_710b60256172548e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGPRCR_EL1_SysRegWrite_710b60256172548e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDOSA : bits(1) = Slice(MDCR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 10, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGPRCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGPRCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGPRCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DBGVCR32_EL2_SysRegWrite_769fbfe4fa51a4e5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGVCR32_EL2_SysRegWrite_769fbfe4fa51a4e5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGVCR32_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DBGVCR32_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DBGWCR_EL1_SysRegWrite_6bda3acb5910d354 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGWCR_EL1_SysRegWrite_6bda3acb5910d354 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGWCR_EL1[UInt(CRm[3 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGWCR_EL1[UInt(CRm[3 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGWCR_EL1[UInt(CRm[3 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DBGWVR_EL1_SysRegWrite_745b296ee53305ea : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DBGWVR_EL1_SysRegWrite_745b296ee53305ea (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    let __EDSCR_TDA : bits(1) = Slice(EDSCR, 21, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGWVR_EL1[UInt(CRm[3 .. 0])] = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGWVR_EL1[UInt(CRm[3 .. 0])] = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((not_bool(ELUsingAArch32(EL1)) & Slice(OSLSR_EL1, 1, 1) == 0b0) & HaltingAllowed()) & __EDSCR_TDA == 0b1 then {
            Halt(DebugHalt_SoftwareAccess)
        } else {
            DBGWVR_EL1[UInt(CRm[3 .. 0])] = val_name;
            return()
        }
    } else ()
}

val DISR_EL1_SysRegWrite_64517664b9260065 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function DISR_EL1_SysRegWrite_64517664b9260065 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_AMO : bits(1) = Slice(HCR_EL2, 5, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_AMO == 0b1 then {
            VDISR_EL2 = val_name[31 .. 0];
            return()
        } else {
            DISR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DISR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DISR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val DLR_EL0_write : bits(64) -> unit effect {wreg}

function DLR_EL0_write val_name = {
    let r : bits(64) = val_name;
    CDLR_EL0 = ZeroExtend(r);
    return()
}

val DLR_EL0_SysRegWrite_a2d10a509fed3a63 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function DLR_EL0_SysRegWrite_a2d10a509fed3a63 (el, op0, op1, CRn, op2, CRm, val_name) = {
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else {
        DLR_EL0_write() = val_name;
        return()
    }
}

val DSPSR_EL0_SysRegWrite_6d6dabfcb332ec05 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function DSPSR_EL0_SysRegWrite_6d6dabfcb332ec05 (el, op0, op1, CRn, op2, CRm, val_name) = {
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else {
        DSPSR_EL0 = val_name[31 .. 0];
        return()
    }
}

val ELR_EL12_SysRegWrite_6720e93c266dadea : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ELR_EL12_SysRegWrite_6720e93c266dadea (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            ELR_EL1 = ZeroExtend(val_name);
            return()
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            ELR_EL1 = ZeroExtend(val_name);
            return()
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val ELR_EL1_SysRegWrite_b6bd589b2dd79575 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function ELR_EL1_SysRegWrite_b6bd589b2dd79575 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        ELR_EL1 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            ELR_EL2 = ZeroExtend(val_name);
            return()
        } else {
            ELR_EL1 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        ELR_EL1 = ZeroExtend(val_name);
        return()
    } else ()
}

val ELR_EL2_SysRegWrite_9f4ca59c1a88f1a9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function ELR_EL2_SysRegWrite_9f4ca59c1a88f1a9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        ELR_EL2 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        ELR_EL2 = ZeroExtend(val_name);
        return()
    } else ()
}

val ELR_EL3_SysRegWrite_8cd0b0c7f61ee7aa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function ELR_EL3_SysRegWrite_8cd0b0c7f61ee7aa (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        ELR_EL3 = ZeroExtend(val_name);
        return()
    } else ()
}

val ERRSELR_EL1_SysRegWrite_551535eed30e26f9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ERRSELR_EL1_SysRegWrite_551535eed30e26f9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERRSELR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERRSELR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERRSELR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ERXADDR_EL1_SysRegWrite_8a1eabc2959662e8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ERXADDR_EL1_SysRegWrite_8a1eabc2959662e8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXADDR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXADDR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXADDR_EL1 = val_name;
            return()
        }
    } else ()
}

val ERXCTLR_EL1_SysRegWrite_acca1e102ba86b42 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ERXCTLR_EL1_SysRegWrite_acca1e102ba86b42 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXCTLR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXCTLR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXCTLR_EL1 = val_name;
            return()
        }
    } else ()
}

val ERXMISC0_EL1_SysRegWrite_822ceca9b10b2621 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ERXMISC0_EL1_SysRegWrite_822ceca9b10b2621 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXMISC0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXMISC0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXMISC0_EL1 = val_name;
            return()
        }
    } else ()
}

val ERXMISC1_EL1_SysRegWrite_9a9ef77b5fd82587 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ERXMISC1_EL1_SysRegWrite_9a9ef77b5fd82587 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXMISC1_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXMISC1_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXMISC1_EL1 = val_name;
            return()
        }
    } else ()
}

val ERXSTATUS_EL1_SysRegWrite_f0798b4207ec0193 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ERXSTATUS_EL1_SysRegWrite_f0798b4207ec0193 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TERR : bits(1) = Slice(HCR_EL2, 36, 1);
    let __SCR_EL3_TERR : bits(1) = Slice(SCR_EL3, 15, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXSTATUS_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TERR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXSTATUS_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ERXSTATUS_EL1 = val_name;
            return()
        }
    } else ()
}

val ESR_EL12_SysRegWrite_2b2d6012ba438548 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ESR_EL12_SysRegWrite_2b2d6012ba438548 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                ESR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                ESR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val ESR_EL1_SysRegWrite_a8ce40896bd70a6b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ESR_EL1_SysRegWrite_a8ce40896bd70a6b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ESR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            ESR_EL2 = val_name[31 .. 0];
            return()
        } else {
            ESR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ESR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ESR_EL2_SysRegWrite_a10e84e3bd1020c8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ESR_EL2_SysRegWrite_a10e84e3bd1020c8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            ESR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ESR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ESR_EL3_SysRegWrite_195a2e1a5b40464e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ESR_EL3_SysRegWrite_195a2e1a5b40464e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ESR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val FAR_EL12_SysRegWrite_78f825940e556299 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FAR_EL12_SysRegWrite_78f825940e556299 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                FAR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                FAR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val FAR_EL1_SysRegWrite_fc0bd224b62cc089 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FAR_EL1_SysRegWrite_fc0bd224b62cc089 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            FAR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            FAR_EL2 = val_name;
            return()
        } else {
            FAR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            FAR_EL1 = val_name;
            return()
        }
    } else ()
}

val FAR_EL2_SysRegWrite_6370aabce83a1613 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FAR_EL2_SysRegWrite_6370aabce83a1613 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            FAR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            FAR_EL2 = val_name;
            return()
        }
    } else ()
}

val FAR_EL3_SysRegWrite_397cfda85a093e9d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FAR_EL3_SysRegWrite_397cfda85a093e9d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            FAR_EL3 = val_name;
            return()
        }
    } else ()
}

val FPCR_SysRegWrite_4f255cf55390cebb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FPCR_SysRegWrite_4f255cf55390cebb (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_FPEN : bits(2) = Slice(CPACR_EL1, 20, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_FPEN : bits(2) = Slice(CPTR_EL2, 20, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TFP : bits(1) = Slice(CPTR_EL2, 10, 1);
    let __CPTR_EL3_TFP : bits(1) = Slice(CPTR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_FPEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x00))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x07))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_FPEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPCR = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPCR = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPCR = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPCR = val_name[31 .. 0];
            return()
        }
    } else ()
}

val FPEXC32_EL2_SysRegWrite_9f180ead5c4d6735 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FPEXC32_EL2_SysRegWrite_9f180ead5c4d6735 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TFP : bits(1) = Slice(CPTR_EL2, 10, 1);
    let __CPTR_EL2_FPEN : bits(2) = Slice(CPTR_EL2, 20, 2);
    let __CPTR_EL3_TFP : bits(1) = Slice(CPTR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPEXC32_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPEXC32_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val FPSR_SysRegWrite_413aed98a94900de : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function FPSR_SysRegWrite_413aed98a94900de (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_FPEN : bits(2) = Slice(CPACR_EL1, 20, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_FPEN : bits(2) = Slice(CPTR_EL2, 20, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TFP : bits(1) = Slice(CPTR_EL2, 10, 1);
    let __CPTR_EL3_TFP : bits(1) = Slice(CPTR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_FPEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x00))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x07))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_FPEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPSR = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPSR = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_FPEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x07))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPSR = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_TFP == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x07))
        } else {
            FPSR = val_name[31 .. 0];
            return()
        }
    } else ()
}

val HACR_EL2_SysRegWrite_5b2ca32fcb39ecab : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function HACR_EL2_SysRegWrite_5b2ca32fcb39ecab (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            HACR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            HACR_EL2 = val_name;
            return()
        }
    } else ()
}

val HCR_EL2_SysRegWrite_6fc18e07a17fd5a2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function HCR_EL2_SysRegWrite_6fc18e07a17fd5a2 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            HCR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            HCR_EL2 = val_name;
            return()
        }
    } else ()
}

val HPFAR_EL2_SysRegWrite_20417eccdd6b4768 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function HPFAR_EL2_SysRegWrite_20417eccdd6b4768 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            HPFAR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            HPFAR_EL2 = val_name;
            return()
        }
    } else ()
}

val HSTR_EL2_SysRegWrite_391a605c0bfb9d1e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function HSTR_EL2_SysRegWrite_391a605c0bfb9d1e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            HSTR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            HSTR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_AP0R_EL1_SysRegWrite_949897f971748acc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_AP0R_EL1_SysRegWrite_949897f971748acc (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_AP0R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_AP0R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_AP0R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_AP0R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_AP1R_EL1_SysRegWrite_55167410f7650dea : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_AP1R_EL1_SysRegWrite_55167410f7650dea (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_AP1R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_AP1R_EL1_S[UInt(op2[1 .. 0])] = val_name[31 .. 0];
                return()
            } else {
                ICC_AP1R_EL1_NS[UInt(op2[1 .. 0])] = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_AP1R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_AP1R_EL1_S[UInt(op2[1 .. 0])] = val_name[31 .. 0];
                return()
            } else {
                ICC_AP1R_EL1_NS[UInt(op2[1 .. 0])] = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_AP1R_EL1[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                ICC_AP1R_EL1_S[UInt(op2[1 .. 0])] = val_name[31 .. 0];
                return()
            } else {
                ICC_AP1R_EL1_NS[UInt(op2[1 .. 0])] = val_name[31 .. 0];
                return()
            }
        }
    } else ()
}

register ICC_ASGI1R_EL1 : bits(64)

val ICC_ASGI1R_EL1_SysRegWrite_c163c25adc1b1354 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_ASGI1R_EL1_SysRegWrite_c163c25adc1b1354 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_ASGI1R_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_ASGI1R_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_ASGI1R_EL1 = val_name;
            return()
        }
    } else ()
}

val ICC_BPR0_EL1_SysRegWrite_10028206553f3655 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_BPR0_EL1_SysRegWrite_10028206553f3655 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_BPR0_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_BPR0_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_BPR0_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_BPR0_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_BPR1_EL1_write : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ICC_BPR1_EL1_write val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_BPR1_EL1_S = r
    } else {
        ICC_BPR1_EL1_NS = r
    };
    return()
}

val ICC_BPR1_EL1_SysRegWrite_a633b2e9f3626d9b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_BPR1_EL1_SysRegWrite_a633b2e9f3626d9b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_BPR1_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_BPR1_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_BPR1_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_BPR1_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_BPR1_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_BPR1_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_BPR1_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                ICC_BPR1_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_BPR1_EL1_NS = val_name[31 .. 0];
                return()
            }
        }
    } else ()
}

val ICC_CTLR_EL1_write : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ICC_CTLR_EL1_write val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_CTLR_EL1_S = r
    } else {
        ICC_CTLR_EL1_NS = r
    };
    return()
}

val ICC_CTLR_EL1_SysRegWrite_8ec3f4b67393eba8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_CTLR_EL1_SysRegWrite_8ec3f4b67393eba8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_CTLR_EL1 = val_name[31 .. 0];
            return()
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_CTLR_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_CTLR_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_CTLR_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_CTLR_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_CTLR_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_CTLR_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_CTLR_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                ICC_CTLR_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_CTLR_EL1_NS = val_name[31 .. 0];
                return()
            }
        }
    } else ()
}

val ICC_CTLR_EL3_SysRegWrite_ecc8b41b177c53e8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_CTLR_EL3_SysRegWrite_ecc8b41b177c53e8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_CTLR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register ICC_DIR_EL1 : bits(32)

register ICV_DIR_EL1 : bits(32)

val ICC_DIR_EL1_SysRegWrite_77fadeda7efde9c5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_DIR_EL1_SysRegWrite_77fadeda7efde9c5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TDIR : bits(1) = Slice(ICH_HCR_EL2, 14, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TDIR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_DIR_EL1 = val_name[31 .. 0];
            return()
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_DIR_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_DIR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_DIR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_DIR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register ICC_EOIR0_EL1 : bits(32)

register ICV_EOIR0_EL1 : bits(32)

val ICC_EOIR0_EL1_SysRegWrite_9c0fae08cd7a2444 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_EOIR0_EL1_SysRegWrite_9c0fae08cd7a2444 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_EOIR0_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_EOIR0_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_EOIR0_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_EOIR0_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register ICC_EOIR1_EL1 : bits(32)

register ICV_EOIR1_EL1 : bits(32)

val ICC_EOIR1_EL1_SysRegWrite_f065db56e179bf6e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_EOIR1_EL1_SysRegWrite_f065db56e179bf6e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_EOIR1_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_EOIR1_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_EOIR1_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_EOIR1_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_IGRPEN0_EL1_SysRegWrite_b94e4d10f7a33382 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_IGRPEN0_EL1_SysRegWrite_b94e4d10f7a33382 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL0 : bits(1) = Slice(ICH_HCR_EL2, 11, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __SCR_EL3_FIQ : bits(1) = Slice(SCR_EL3, 2, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL0 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_IGRPEN0_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_IGRPEN0_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_FIQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_IGRPEN0_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_IGRPEN0_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_IGRPEN1_EL1_write : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ICC_IGRPEN1_EL1_write val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_IGRPEN1_EL1_S = r
    } else {
        ICC_IGRPEN1_EL1_NS = r
    };
    return()
}

val ICC_IGRPEN1_EL1_SysRegWrite_c36dfa556252f6b4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_IGRPEN1_EL1_SysRegWrite_c36dfa556252f6b4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TALL1 : bits(1) = Slice(ICH_HCR_EL2, 12, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __SCR_EL3_IRQ : bits(1) = Slice(SCR_EL3, 1, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TALL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_IGRPEN1_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_IGRPEN1_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_IGRPEN1_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_IGRPEN1_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_IRQ == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_IGRPEN1_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_IGRPEN1_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_IGRPEN1_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                ICC_IGRPEN1_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_IGRPEN1_EL1_NS = val_name[31 .. 0];
                return()
            }
        }
    } else ()
}

val ICC_IGRPEN1_EL3_SysRegWrite_6f1db000a53b40ca : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_IGRPEN1_EL3_SysRegWrite_6f1db000a53b40ca (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_IGRPEN1_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_PMR_EL1_SysRegWrite_8bb2caa31e7d5e1b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_PMR_EL1_SysRegWrite_8bb2caa31e7d5e1b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            ICV_PMR_EL1 = val_name[31 .. 0];
            return()
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            ICV_PMR_EL1 = val_name[31 .. 0];
            return()
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_PMR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_PMR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_PMR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register ICC_SGI0R_EL1 : bits(64)

val ICC_SGI0R_EL1_SysRegWrite_ba6d1066ea6fbbb7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_SGI0R_EL1_SysRegWrite_ba6d1066ea6fbbb7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SGI0R_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SGI0R_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SGI0R_EL1 = val_name;
            return()
        }
    } else ()
}

register ICC_SGI1R_EL1 : bits(64)

val ICC_SGI1R_EL1_SysRegWrite_0da31fe6c2e1b098 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_SGI1R_EL1_SysRegWrite_0da31fe6c2e1b098 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL1_SRE : bits(1) = Slice(ICC_SRE_EL1_read(), 0, 1);
    let __ICH_HCR_EL2_TC : bits(1) = Slice(ICH_HCR_EL2, 10, 1);
    let __HCR_EL2_FMO : bits(1) = Slice(HCR_EL2, 3, 1);
    let __HCR_EL2_IMO : bits(1) = Slice(HCR_EL2, 4, 1);
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL1_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICH_HCR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FMO == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_IMO == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SGI1R_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & (Slice(SCR_EL3, 1, 1) @ Slice(SCR_EL3, 2, 1)) == 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SGI1R_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SGI1R_EL1 = val_name;
            return()
        }
    } else ()
}

val ICC_SRE_EL1_write : bits(32) -> unit effect {escape, rreg, undef, wreg}

function ICC_SRE_EL1_write val_name = {
    let r : bits(32) = val_name;
    if ELUsingAArch32(EL3) & IsSecure() then {
        ICC_SRE_EL1_S = r
    } else {
        ICC_SRE_EL1_NS = r
    };
    return()
}

val ICC_SRE_EL1_SysRegWrite_d2efb75caa67d019 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_SRE_EL1_SysRegWrite_d2efb75caa67d019 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_Enable : bits(1) = Slice(ICC_SRE_EL2, 3, 1);
    let __ICC_SRE_EL3_Enable : bits(1) = Slice(ICC_SRE_EL3, 3, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __ICC_SRE_EL2_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __ICC_SRE_EL3_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_SRE_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_SRE_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_SRE_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __ICC_SRE_EL3_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if HaveEL(EL3) then {
            if __SCR_EL3_NS == 0b0 then {
                ICC_SRE_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_SRE_EL1_NS = val_name[31 .. 0];
                return()
            }
        } else {
            ICC_SRE_EL1_write() = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            if __SCR_EL3_NS == 0b0 then {
                ICC_SRE_EL1_S = val_name[31 .. 0];
                return()
            } else {
                ICC_SRE_EL1_NS = val_name[31 .. 0];
                return()
            }
        }
    } else ()
}

val ICC_SRE_EL2_SysRegWrite_39c314f677b8ec2e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_SRE_EL2_SysRegWrite_39c314f677b8ec2e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL3_Enable : bits(1) = Slice(ICC_SRE_EL3, 3, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __ICC_SRE_EL3_Enable == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SRE_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SRE_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICC_SRE_EL3_SysRegWrite_c0af2dd58a7e1d22 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICC_SRE_EL3_SysRegWrite_c0af2dd58a7e1d22 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICC_SRE_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICH_AP0R_EL2_SysRegWrite_9517857bb550d699 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICH_AP0R_EL2_SysRegWrite_9517857bb550d699 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ICH_AP0R_EL2[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICH_AP0R_EL2[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICH_AP1R_EL2_SysRegWrite_20f46016b54a3395 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICH_AP1R_EL2_SysRegWrite_20f46016b54a3395 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ICH_AP1R_EL2[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICH_AP1R_EL2[UInt(op2[1 .. 0])] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICH_HCR_EL2_SysRegWrite_2fea52a15cd7dbe5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICH_HCR_EL2_SysRegWrite_2fea52a15cd7dbe5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ICH_HCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICH_HCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val ICH_LR_EL2_SysRegWrite_8b291f94259261d2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICH_LR_EL2_SysRegWrite_8b291f94259261d2 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ICH_LR_EL2[UInt([CRm[0]] @ op2[2 .. 0])] = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICH_LR_EL2[UInt([CRm[0]] @ op2[2 .. 0])] = val_name;
            return()
        }
    } else ()
}

val ICH_VMCR_EL2_SysRegWrite_86a315374f6b5205 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ICH_VMCR_EL2_SysRegWrite_86a315374f6b5205 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __ICC_SRE_EL2_SRE : bits(1) = Slice(ICC_SRE_EL2, 0, 1);
    let __ICC_SRE_EL3_SRE : bits(1) = Slice(ICC_SRE_EL3, 0, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __ICC_SRE_EL2_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            ICH_VMCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __ICC_SRE_EL3_SRE == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            ICH_VMCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val IFSR32_EL2_SysRegWrite_6ce25b2b11e30403 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IFSR32_EL2_SysRegWrite_6ce25b2b11e30403 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            IFSR32_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            IFSR32_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val LORC_EL1_SysRegWrite_7100b979c23fc52e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function LORC_EL1_SysRegWrite_7100b979c23fc52e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORC_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORC_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORC_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val LOREA_EL1_SysRegWrite_2d068511b7f5ce7b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function LOREA_EL1_SysRegWrite_2d068511b7f5ce7b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LOREA_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LOREA_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LOREA_EL1 = val_name;
            return()
        }
    } else ()
}

val LORN_EL1_SysRegWrite_bde03c74e878b099 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function LORN_EL1_SysRegWrite_bde03c74e878b099 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORN_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORN_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORN_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val LORSA_EL1_SysRegWrite_9ba633e967136731 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function LORSA_EL1_SysRegWrite_9ba633e967136731 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __HCR_EL2_TLOR : bits(1) = Slice(HCR_EL2, 35, 1);
    let __SCR_EL3_TLOR : bits(1) = Slice(SCR_EL3, 14, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORSA_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_TLOR == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORSA_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __SCR_EL3_NS == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            LORSA_EL1 = val_name;
            return()
        }
    } else ()
}

val MAIR_EL12_SysRegWrite_da2526ed2008ed50 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MAIR_EL12_SysRegWrite_da2526ed2008ed50 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                MAIR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                MAIR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val MAIR_EL1_SysRegWrite_45d8150aaf31e3b9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MAIR_EL1_SysRegWrite_45d8150aaf31e3b9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            MAIR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            MAIR_EL2 = val_name;
            return()
        } else {
            MAIR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MAIR_EL1 = val_name;
            return()
        }
    } else ()
}

val MAIR_EL2_SysRegWrite_4e3422c1776528f5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MAIR_EL2_SysRegWrite_4e3422c1776528f5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            MAIR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MAIR_EL2 = val_name;
            return()
        }
    } else ()
}

val MAIR_EL3_SysRegWrite_d15af780e0b4e771 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MAIR_EL3_SysRegWrite_d15af780e0b4e771 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MAIR_EL3 = val_name;
            return()
        }
    } else ()
}

val MDCCINT_EL1_SysRegWrite_1e6a37984aec7145 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MDCCINT_EL1_SysRegWrite_1e6a37984aec7145 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDCCINT_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDCCINT_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDCCINT_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val MDCR_EL2_SysRegWrite_3f12005c8c459bf3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MDCR_EL2_SysRegWrite_3f12005c8c459bf3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val MDCR_EL3_SysRegWrite_37dff5fa83ad16ed : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MDCR_EL3_SysRegWrite_37dff5fa83ad16ed (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDCR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val MDSCR_EL1_SysRegWrite_94ddb1e46aff4dfa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MDSCR_EL1_SysRegWrite_94ddb1e46aff4dfa (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDSCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDSCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MDSCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val MPAM0_EL1_SysRegWrite_88f6c0c61a59ac23 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAM0_EL1_SysRegWrite_88f6c0c61a59ac23 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    let __MPAM2_EL2_TRAPMPAM0EL1 : bits(1) = Slice(MPAM2_EL2_read(), 49, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MPAM2_EL2_TRAPMPAM0EL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            MPAM0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAM0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAM0_EL1 = val_name;
            return()
        }
    } else ()
}

val MPAM2_EL2_write : bits(64) -> unit effect {rreg, wreg}

function MPAM2_EL2_write val_name = {
    let r : bits(64) = val_name;
    MPAM3_EL3 = SetSlice(1, MPAM3_EL3, 63, Slice(r, 63, 1));
    _MPAM2_EL2_0_62 = Slice(r, 0, 63);
    return()
}

val MPAM1_EL1_write : bits(64) -> unit effect {rreg, undef, wreg}

function MPAM1_EL1_write val_name = {
    let r : bits(64) = val_name;
    if HaveEL(EL3) then {
        MPAM3_EL3 = SetSlice(1, MPAM3_EL3, 63, Slice(r, 63, 1))
    } else {
        MPAM2_EL2_write() = SetSlice(1, MPAM2_EL2_read(), 63, Slice(r, 63, 1))
    };
    _MPAM1_EL1_0_62 = Slice(r, 0, 63);
    return()
}

val MPAM1_EL12_SysRegWrite_2cbbb0edf5787671 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAM1_EL12_SysRegWrite_2cbbb0edf5787671 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                MPAM1_EL1_write() = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                MPAM1_EL1_write() = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val MPAM1_EL1_SysRegWrite_cd02720a3298b1c6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAM1_EL1_SysRegWrite_cd02720a3298b1c6 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    let __MPAM2_EL2_TRAPMPAM1EL1 : bits(1) = Slice(MPAM2_EL2_read(), 48, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MPAM2_EL2_TRAPMPAM1EL1 == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            MPAM1_EL1_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __HCR_EL2_E2H == 0b1 then {
            MPAM2_EL2_write() = val_name;
            return()
        } else {
            MPAM1_EL1_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAM1_EL1_write() = val_name;
            return()
        }
    } else ()
}

val MPAM2_EL2_SysRegWrite_d6bae8d18aebb554 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAM2_EL2_SysRegWrite_d6bae8d18aebb554 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAM2_EL2_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAM2_EL2_write() = val_name;
            return()
        }
    } else ()
}

val MPAM3_EL3_SysRegWrite_bb55d8a9d90e05e3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAM3_EL3_SysRegWrite_bb55d8a9d90e05e3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAM3_EL3 = val_name;
            return()
        }
    } else ()
}

val MPAMHCR_EL2_SysRegWrite_e38755d6111336b8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMHCR_EL2_SysRegWrite_e38755d6111336b8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMHCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMHCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val MPAMVPM0_EL2_SysRegWrite_c00108111630aa84 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM0_EL2_SysRegWrite_c00108111630aa84 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM0_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM0_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM1_EL2_SysRegWrite_81a739cc4bd1cd46 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM1_EL2_SysRegWrite_81a739cc4bd1cd46 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM1_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM1_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM2_EL2_SysRegWrite_20a1b54bc18980b1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM2_EL2_SysRegWrite_20a1b54bc18980b1 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM2_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM2_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM3_EL2_SysRegWrite_d2a71d8e23cc67af : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM3_EL2_SysRegWrite_d2a71d8e23cc67af (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM3_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM3_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM4_EL2_SysRegWrite_2d0a10731399829d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM4_EL2_SysRegWrite_2d0a10731399829d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM4_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM4_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM5_EL2_SysRegWrite_ec98ca57d40ac9ec : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM5_EL2_SysRegWrite_ec98ca57d40ac9ec (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM5_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM5_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM6_EL2_SysRegWrite_0934853fee68e9bd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM6_EL2_SysRegWrite_0934853fee68e9bd (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM6_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM6_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPM7_EL2_SysRegWrite_dfb7f68750df7012 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPM7_EL2_SysRegWrite_dfb7f68750df7012 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM7_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPM7_EL2 = val_name;
            return()
        }
    } else ()
}

val MPAMVPMV_EL2_SysRegWrite_abd8d27e91fadf85 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function MPAMVPMV_EL2_SysRegWrite_abd8d27e91fadf85 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MPAM3_EL3_TRAPLOWER : bits(1) = Slice(MPAM3_EL3, 62, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if HaveEL(EL3) & __MPAM3_EL3_TRAPLOWER == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPMV_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            MPAMVPMV_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val NZCV_SysRegWrite_a047a536d32ae853 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {rreg, wreg}

function NZCV_SysRegWrite_a047a536d32ae853 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = val_name[31 .. 28];
        return()
    } else if __PSTATE_EL == EL1 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = val_name[31 .. 28];
        return()
    } else if __PSTATE_EL == EL2 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = val_name[31 .. 28];
        return()
    } else if __PSTATE_EL == EL3 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = val_name[31 .. 28];
        return()
    } else ()
}

val OSDLR_EL1_SysRegWrite_591fd96d91652c64 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function OSDLR_EL1_SysRegWrite_591fd96d91652c64 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    __MDCR_EL2_TDOSA = Slice(MDCR_EL2, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 10, 1)) != 0b00) & (HaveDoubleLock() | __IMPDEF_boolean("Trapped by __MDCR_EL2_TDOSA")) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & Slice(MDCR_EL3, 10, 1) == 0b1) & (HaveDoubleLock() | __IMPDEF_boolean("Trapped by MDCR_EL3.TDOSA")) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & Slice(MDCR_EL3, 10, 1) == 0b1) & (HaveDoubleLock() | __IMPDEF_boolean("Trapped by MDCR_EL3.TDOSA")) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val OSDTRRX_EL1_SysRegWrite_6dc5d8521b60df8a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function OSDTRRX_EL1_SysRegWrite_6dc5d8521b60df8a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDTRRX_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDTRRX_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDTRRX_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val OSDTRTX_EL1_SysRegWrite_9ba0c4a85d0c1de5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function OSDTRTX_EL1_SysRegWrite_9ba0c4a85d0c1de5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDTRTX_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDTRTX_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSDTRTX_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val OSECCR_EL1_SysRegWrite_cabf381bfb822732 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function OSECCR_EL1_SysRegWrite_cabf381bfb822732 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDA : bits(1) = Slice(MDCR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 9, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSECCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSECCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSECCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register OSLAR_EL1 : bits(32)

val OSLAR_EL1_SysRegWrite_582d77c57653b2c4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function OSLAR_EL1_SysRegWrite_582d77c57653b2c4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL3_TDOSA : bits(1) = Slice(MDCR_EL3, 10, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(MDCR_EL2, 8, 1) @ Slice(MDCR_EL2, 10, 1)) != 0b00 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSLAR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TDOSA == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSLAR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            OSLAR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PAN_SysRegWrite_aedbb13e40f0add0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function PAN_SysRegWrite_aedbb13e40f0add0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        PSTATE.PAN = [val_name[22]];
        return()
    } else if __PSTATE_EL == EL2 then {
        PSTATE.PAN = [val_name[22]];
        return()
    } else if __PSTATE_EL == EL3 then {
        PSTATE.PAN = [val_name[22]];
        return()
    } else ()
}

val PAR_EL1_SysRegWrite_aa92c70a4b5d5873 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PAR_EL1_SysRegWrite_aa92c70a4b5d5873 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            PAR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            PAR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PAR_EL1 = val_name;
            return()
        }
    } else ()
}

val PMBLIMITR_EL1_SysRegWrite_ddfe2ba603df6628 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMBLIMITR_EL1_SysRegWrite_ddfe2ba603df6628 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_E2PB : bits(2) = Slice(MDCR_EL2, 12, 2);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (match __MDCR_EL2_E2PB {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBLIMITR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBLIMITR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBLIMITR_EL1 = val_name;
            return()
        }
    } else ()
}

val PMBPTR_EL1_SysRegWrite_32441d8a7a2b9601 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMBPTR_EL1_SysRegWrite_32441d8a7a2b9601 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_E2PB : bits(2) = Slice(MDCR_EL2, 12, 2);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (match __MDCR_EL2_E2PB {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBPTR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBPTR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBPTR_EL1 = val_name;
            return()
        }
    } else ()
}

val PMBSR_EL1_SysRegWrite_ff19dc948509312f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMBSR_EL1_SysRegWrite_ff19dc948509312f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_E2PB : bits(2) = Slice(MDCR_EL2, 12, 2);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (match __MDCR_EL2_E2PB {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBSR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBSR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMBSR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMCCFILTR_EL0_SysRegWrite_42277f001664525c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMCCFILTR_EL0_SysRegWrite_42277f001664525c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCFILTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCFILTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCFILTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCFILTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMCCNTR_EL0_SysRegWrite_1d21e0789830cbf9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMCCNTR_EL0_SysRegWrite_1d21e0789830cbf9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCNTR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCNTR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCNTR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCCNTR_EL0 = val_name;
            return()
        }
    } else ()
}

val PMCNTENCLR_EL0_SysRegWrite_bf2c4fae1a891e1b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMCNTENCLR_EL0_SysRegWrite_bf2c4fae1a891e1b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMCNTENSET_EL0_SysRegWrite_227af2773d320cb1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMCNTENSET_EL0_SysRegWrite_227af2773d320cb1 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCNTENSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMCR_EL0_SysRegWrite_87ae64466e09f89a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMCR_EL0_SysRegWrite_87ae64466e09f89a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL2_TPMCR : bits(1) = Slice(MDCR_EL2, 5, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMCR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMCR == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMCR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMEVCNTR_EL0_SysRegWrite_c197579331ed9cbb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMEVCNTR_EL0_SysRegWrite_c197579331ed9cbb (el, op0, op1, CRn, op2, CRm, val_name) = {
    let 'idx = UInt(CRm[1 .. 0] @ op2[2 .. 0]);
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVCNTR_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVCNTR_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVCNTR_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVCNTR_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMEVTYPER_EL0_SysRegWrite_3e6ae16cd645ec0d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMEVTYPER_EL0_SysRegWrite_3e6ae16cd645ec0d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let 'idx = UInt(CRm[1 .. 0] @ op2[2 .. 0]);
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVTYPER_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVTYPER_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVTYPER_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            assert(constraint('idx < 31));
            PMEVTYPER_EL0[idx] = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMINTENCLR_EL1_SysRegWrite_1ebd7bf3738fe872 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMINTENCLR_EL1_SysRegWrite_1ebd7bf3738fe872 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMINTENCLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMINTENCLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMINTENCLR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMINTENSET_EL1_SysRegWrite_dd2481ad892e3441 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMINTENSET_EL1_SysRegWrite_dd2481ad892e3441 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMINTENSET_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMINTENSET_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMINTENSET_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMOVSCLR_EL0_SysRegWrite_9dfa73cda394af99 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMOVSCLR_EL0_SysRegWrite_9dfa73cda394af99 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSCLR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMOVSSET_EL0_SysRegWrite_cfbbfe3b81fe4290 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMOVSSET_EL0_SysRegWrite_cfbbfe3b81fe4290 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMOVSSET_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMSCR_EL12_SysRegWrite_fef9a94f50c2763b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSCR_EL12_SysRegWrite_fef9a94f50c2763b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                PMSCR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                PMSCR_EL1 = val_name[31 .. 0];
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val PMSCR_EL1_SysRegWrite_9798a89ab6804fe0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSCR_EL1_SysRegWrite_9798a89ab6804fe0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __HCR_EL2_E2H == 0b1 then {
            PMSCR_EL2 = val_name[31 .. 0];
            return()
        } else {
            PMSCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMSCR_EL2_SysRegWrite_02cd14dd325ed94b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSCR_EL2_SysRegWrite_02cd14dd325ed94b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMSELR_EL0_SysRegWrite_18613307de8564a3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSELR_EL0_SysRegWrite_18613307de8564a3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & (Slice(PMUSERENR_EL0, 3, 1) @ Slice(PMUSERENR_EL0, 0, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSELR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSELR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSELR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSELR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMSEVFR_EL1_SysRegWrite_6524c56cd8a10057 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSEVFR_EL1_SysRegWrite_6524c56cd8a10057 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSEVFR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSEVFR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSEVFR_EL1 = val_name;
            return()
        }
    } else ()
}

val PMSFCR_EL1_SysRegWrite_44d58271848f0db1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSFCR_EL1_SysRegWrite_44d58271848f0db1 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSFCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSFCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSFCR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMSICR_EL1_SysRegWrite_1e74423ea1c96ae7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSICR_EL1_SysRegWrite_1e74423ea1c96ae7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSICR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSICR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSICR_EL1 = val_name;
            return()
        }
    } else ()
}

val PMSIRR_EL1_SysRegWrite_bb25878486c35a36 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSIRR_EL1_SysRegWrite_bb25878486c35a36 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSIRR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSIRR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSIRR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMSLATFR_EL1_SysRegWrite_5c8b43a6a65c8272 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSLATFR_EL1_SysRegWrite_5c8b43a6a65c8272 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPMS : bits(1) = Slice(MDCR_EL2, 14, 1);
    let __SCR_EL3_NS : bits(1) = Slice(SCR_EL3, 0, 1);
    let __MDCR_EL3_NSPB : bits(2) = Slice(MDCR_EL3, 12, 2);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPMS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSLATFR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b0) & __MDCR_EL3_NSPB != 0b01 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if ((HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_NS == 0b1) & __MDCR_EL3_NSPB != 0b11 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSLATFR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSLATFR_EL1 = val_name[31 .. 0];
            return()
        }
    } else ()
}

register PMSWINC_EL0 : bits(32)

val PMSWINC_EL0_SysRegWrite_cce1d915b163d5e3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMSWINC_EL0_SysRegWrite_cce1d915b163d5e3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & (Slice(PMUSERENR_EL0, 1, 1) @ Slice(PMUSERENR_EL0, 0, 1)) == 0b00 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSWINC_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSWINC_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSWINC_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMSWINC_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMUSERENR_EL0_SysRegWrite_e7535626e3360c36 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMUSERENR_EL0_SysRegWrite_e7535626e3360c36 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMUSERENR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMUSERENR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMUSERENR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMXEVCNTR_EL0_SysRegWrite_20b0a6df43a7d4ef : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMXEVCNTR_EL0_SysRegWrite_20b0a6df43a7d4ef (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVCNTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVCNTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVCNTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVCNTR_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val PMXEVTYPER_EL0_SysRegWrite_82fb55a6e723e983 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function PMXEVTYPER_EL0_SysRegWrite_82fb55a6e723e983 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PMUSERENR_EL0_EN : bits(1) = Slice(PMUSERENR_EL0, 0, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __MDCR_EL2_TPM : bits(1) = Slice(MDCR_EL2, 6, 1);
    let __MDCR_EL3_TPM : bits(1) = Slice(MDCR_EL3, 6, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if not_bool(ELUsingAArch32(EL1)) & __PMUSERENR_EL0_EN == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVTYPER_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __MDCR_EL2_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVTYPER_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __MDCR_EL3_TPM == 0b1 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVTYPER_EL0 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            PMXEVTYPER_EL0 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val RMR_EL1_SysRegWrite_0ae19f794f511c7a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RMR_EL1_SysRegWrite_0ae19f794f511c7a (el, op0, op1, CRn, op2, CRm, val_name) = {
    if PSTATE.EL == EL1 & IsHighestEL(EL1) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL1, UInt(0x18))
        } else {
            RMR_EL1 = val_name[31 .. 0];
            return()
        }
    } else {
        throw(Error_Undefined())
    }
}

val RMR_EL2_SysRegWrite_df7b9a989e2495d2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RMR_EL2_SysRegWrite_df7b9a989e2495d2 (el, op0, op1, CRn, op2, CRm, val_name) = {
    if PSTATE.EL == EL2 & IsHighestEL(EL2) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            RMR_EL2 = val_name[31 .. 0];
            return()
        }
    } else {
        throw(Error_Undefined())
    }
}

val RMR_EL3_SysRegWrite_2849130fc457929e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RMR_EL3_SysRegWrite_2849130fc457929e (el, op0, op1, CRn, op2, CRm, val_name) = {
    if PSTATE.EL == EL3 & IsHighestEL(EL3) then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            RMR_EL3 = val_name[31 .. 0];
            return()
        }
    } else {
        throw(Error_Undefined())
    }
}

val RSP_EL0_SysRegWrite_5b2edb6edd27507d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RSP_EL0_SysRegWrite_5b2edb6edd27507d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val RTPIDR_EL0_SysRegWrite_74d55919bd0ab5f3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RTPIDR_EL0_SysRegWrite_74d55919bd0ab5f3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val S3_op1_CCn_CCm_op2_SysRegWrite_22dd63287f599042 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S3_op1_CCn_CCm_op2_SysRegWrite_22dd63287f599042 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TIDCP : bits(1) = Slice(HCR_EL2, 20, 1);
    if __PSTATE_EL == EL1 then {
        if EL2Enabled() & __HCR_EL2_TIDCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            S3_op1_Cn_Cm_op2 = val_name;
            return()
        }
    } else {
        S3_op1_Cn_Cm_op2 = val_name;
        return()
    }
}

val SCR_EL3_SysRegWrite_020d082781fa9b72 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCR_EL3_SysRegWrite_020d082781fa9b72 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val SCTLR_EL12_SysRegWrite_302de25977d2a0ca : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCTLR_EL12_SysRegWrite_302de25977d2a0ca (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                SCTLR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                SCTLR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val SCTLR_EL1_SysRegWrite_711b0546c662c54d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCTLR_EL1_SysRegWrite_711b0546c662c54d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            SCTLR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            SCTLR_EL2 = val_name;
            return()
        } else {
            SCTLR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCTLR_EL1 = val_name;
            return()
        }
    } else ()
}

val SCTLR_EL2_SysRegWrite_ff61a6f00288b28a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCTLR_EL2_SysRegWrite_ff61a6f00288b28a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            SCTLR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCTLR_EL2 = val_name;
            return()
        }
    } else ()
}

val SCTLR_EL3_SysRegWrite_5b7cc79e5ea93a8f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCTLR_EL3_SysRegWrite_5b7cc79e5ea93a8f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCTLR_EL3 = val_name;
            return()
        }
    } else ()
}

val SCXTNUM_EL0_write : bits(64) -> unit effect {wreg}

function SCXTNUM_EL0_write val_name = {
    let r : bits(64) = val_name;
    CID_EL0 = ZeroExtend(r);
    return()
}

val SCXTNUM_EL0_SysRegWrite_9dbee2793d69c02e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCXTNUM_EL0_SysRegWrite_9dbee2793d69c02e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_TSCXT : bits(1) = Slice(SCTLR_EL1, 20, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_EnSCXT : bits(1) = Slice(HCR_EL2, 53, 1);
    let __SCTLR_EL2_TSCXT : bits(1) = Slice(SCTLR_EL2, 20, 1);
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_TSCXT == 0b1 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_TSCXT == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL0_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL0_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL0_write() = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL0_write() = val_name;
            return()
        }
    } else ()
}

val SCXTNUM_EL12_SysRegWrite_ba74367909393c9b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCXTNUM_EL12_SysRegWrite_ba74367909393c9b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                SCXTNUM_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                SCXTNUM_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val SCXTNUM_EL1_SysRegWrite_6467f6f26a31cece : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCXTNUM_EL1_SysRegWrite_6467f6f26a31cece (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_EnSCXT : bits(1) = Slice(HCR_EL2, 53, 1);
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if __HCR_EL2_E2H == 0b1 then {
            SCXTNUM_EL2 = val_name;
            return()
        } else {
            SCXTNUM_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL1 = val_name;
            return()
        }
    } else ()
}

val SCXTNUM_EL2_SysRegWrite_2fcbb6503badb23c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCXTNUM_EL2_SysRegWrite_2fcbb6503badb23c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCR_EL3_EnSCXT : bits(1) = Slice(SCR_EL3, 25, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __SCR_EL3_EnSCXT == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL2 = val_name;
            return()
        }
    } else ()
}

val SCXTNUM_EL3_SysRegWrite_b39fe9ab09a67ecd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SCXTNUM_EL3_SysRegWrite_b39fe9ab09a67ecd (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SCXTNUM_EL3 = val_name;
            return()
        }
    } else ()
}

val SDER32_EL3_SysRegWrite_69011ff5e95ac923 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SDER32_EL3_SysRegWrite_69011ff5e95ac923 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            SDER32_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val SPSR_EL12_SysRegWrite_cabdb902efd62924 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function SPSR_EL12_SysRegWrite_cabdb902efd62924 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            SPSR_EL1 = val_name[31 .. 0];
            return()
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            SPSR_EL1 = val_name[31 .. 0];
            return()
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val SPSR_EL1_SysRegWrite_c3a982c3130dcaea : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_EL1_SysRegWrite_c3a982c3130dcaea (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        SPSR_EL1 = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            SPSR_EL2 = val_name[31 .. 0];
            return()
        } else {
            SPSR_EL1 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        SPSR_EL1 = val_name[31 .. 0];
        return()
    } else ()
}

val SPSR_EL2_SysRegWrite_1d65bd974e988727 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_EL2_SysRegWrite_1d65bd974e988727 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        SPSR_EL2 = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL3 then {
        SPSR_EL2 = val_name[31 .. 0];
        return()
    } else ()
}

val SPSR_EL3_SysRegWrite_7b0326ec9be492f4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_EL3_SysRegWrite_7b0326ec9be492f4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        SPSR_EL3 = val_name[31 .. 0];
        return()
    } else ()
}

val SPSR_abt_SysRegWrite_ecb9f412e44a217b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_abt_SysRegWrite_ecb9f412e44a217b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        SPSR_abt = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL3 then {
        SPSR_abt = val_name[31 .. 0];
        return()
    } else ()
}

val SPSR_fiq_SysRegWrite_760097483f6eab5e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_fiq_SysRegWrite_760097483f6eab5e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        SPSR_fiq = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL3 then {
        SPSR_fiq = val_name[31 .. 0];
        return()
    } else ()
}

val SPSR_irq_SysRegWrite_d42335013c288fbe : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_irq_SysRegWrite_d42335013c288fbe (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        SPSR_irq = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL3 then {
        SPSR_irq = val_name[31 .. 0];
        return()
    } else ()
}

val SPSR_und_SysRegWrite_76485ab5b58e2a80 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSR_und_SysRegWrite_76485ab5b58e2a80 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        SPSR_und = val_name[31 .. 0];
        return()
    } else if __PSTATE_EL == EL3 then {
        SPSR_und = val_name[31 .. 0];
        return()
    } else ()
}

val SPSel_SysRegWrite_c849e120e8533c8c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SPSel_SysRegWrite_c849e120e8533c8c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return()
        } else {
            PSTATE.SP = [val_name[0]];
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return()
        } else {
            PSTATE.SP = [val_name[0]];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            return()
        } else {
            PSTATE.SP = [val_name[0]];
            return()
        }
    } else ()
}

val SP_EL0_SysRegWrite_78f870c69d82f9e2 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SP_EL0_SysRegWrite_78f870c69d82f9e2 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else {
            SP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else {
            SP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else {
            SP_EL0 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val SP_EL1_SysRegWrite_84ae51cf4bf77caa : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SP_EL1_SysRegWrite_84ae51cf4bf77caa (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else {
            SP_EL1 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else {
            SP_EL1 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val SP_EL2_SysRegWrite_a29ffeac6d3856e5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function SP_EL2_SysRegWrite_a29ffeac6d3856e5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else {
            SP_EL2 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val SSBS_SysRegWrite_e080097cffcde083 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {rreg, wreg}

function SSBS_SysRegWrite_e080097cffcde083 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        PSTATE.SSBS = [val_name[12]];
        return()
    } else if __PSTATE_EL == EL1 then {
        PSTATE.SSBS = [val_name[12]];
        return()
    } else if __PSTATE_EL == EL2 then {
        PSTATE.SSBS = [val_name[12]];
        return()
    } else if __PSTATE_EL == EL3 then {
        PSTATE.SSBS = [val_name[12]];
        return()
    } else ()
}

val TCR_EL12_SysRegWrite_64a7f44c6ddaa0f8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TCR_EL12_SysRegWrite_64a7f44c6ddaa0f8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                TCR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                TCR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val TCR_EL1_SysRegWrite_c27e6fc190bb0f0b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TCR_EL1_SysRegWrite_c27e6fc190bb0f0b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TCR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            TCR_EL2 = val_name;
            return()
        } else {
            TCR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TCR_EL1 = val_name;
            return()
        }
    } else ()
}

val TCR_EL2_SysRegWrite_5e38279a245750c4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TCR_EL2_SysRegWrite_5e38279a245750c4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TCR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TCR_EL2 = val_name;
            return()
        }
    } else ()
}

val TCR_EL3_SysRegWrite_3b3587015a3d20f4 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TCR_EL3_SysRegWrite_3b3587015a3d20f4 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TCR_EL3 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val TPIDRRO_EL0_SysRegWrite_20bedffb2581e57d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function TPIDRRO_EL0_SysRegWrite_20bedffb2581e57d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        TPIDRRO_EL0 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL2 then {
        TPIDRRO_EL0 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        TPIDRRO_EL0 = ZeroExtend(val_name);
        return()
    } else ()
}

val TPIDR_EL0_SysRegWrite_6b1ef76c828f0bf5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {rreg, wreg}

function TPIDR_EL0_SysRegWrite_6b1ef76c828f0bf5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        } else {
            TPIDR_EL0 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        TPIDR_EL0 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL2 then {
        TPIDR_EL0 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        TPIDR_EL0 = ZeroExtend(val_name);
        return()
    } else ()
}

val TPIDR_EL1_SysRegWrite_566127c19bf948d1 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function TPIDR_EL1_SysRegWrite_566127c19bf948d1 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        } else {
            TPIDR_EL1 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        TPIDR_EL1 = ZeroExtend(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        TPIDR_EL1 = ZeroExtend(val_name);
        return()
    } else ()
}

val TPIDR_EL2_SysRegWrite_adfab02a898d4b19 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function TPIDR_EL2_SysRegWrite_adfab02a898d4b19 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        } else {
            TPIDR_EL2 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        TPIDR_EL2 = ZeroExtend(val_name);
        return()
    } else ()
}

val TPIDR_EL3_SysRegWrite_08e0e9cc5d3f6f5c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function TPIDR_EL3_SysRegWrite_08e0e9cc5d3f6f5c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = ZeroExtend(val_name);
            return()
        } else {
            TPIDR_EL3 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val TTBR0_EL12_SysRegWrite_fd9df8519bfad5c0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR0_EL12_SysRegWrite_fd9df8519bfad5c0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                TTBR0_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                TTBR0_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val TTBR0_EL1_SysRegWrite_8a149790a79e2eab : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR0_EL1_SysRegWrite_8a149790a79e2eab (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TTBR0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            TTBR0_EL2 = val_name;
            return()
        } else {
            TTBR0_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TTBR0_EL1 = val_name;
            return()
        }
    } else ()
}

val TTBR0_EL2_SysRegWrite_7cd39d4a24a70e7f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR0_EL2_SysRegWrite_7cd39d4a24a70e7f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TTBR0_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TTBR0_EL2 = val_name;
            return()
        }
    } else ()
}

val TTBR0_EL3_SysRegWrite_7e091a8effc9ee7f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR0_EL3_SysRegWrite_7e091a8effc9ee7f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TTBR0_EL3 = val_name;
            return()
        }
    } else ()
}

val TTBR1_EL12_SysRegWrite_4fbeb1f28c2e8107 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR1_EL12_SysRegWrite_4fbeb1f28c2e8107 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                TTBR1_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                TTBR1_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val TTBR1_EL1_SysRegWrite_89690e4d3c87217b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR1_EL1_SysRegWrite_89690e4d3c87217b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TVM : bits(1) = Slice(HCR_EL2, 26, 1);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TVM == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TTBR1_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            TTBR1_EL2 = val_name;
            return()
        } else {
            TTBR1_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TTBR1_EL1 = val_name;
            return()
        }
    } else ()
}

val TTBR1_EL2_SysRegWrite_59fad32bc548b47a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function TTBR1_EL2_SysRegWrite_59fad32bc548b47a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TTBR1_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TTBR1_EL2 = val_name;
            return()
        }
    } else ()
}

val UAO_SysRegWrite_594f371263b733f0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, wreg}

function UAO_SysRegWrite_594f371263b733f0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        PSTATE.UAO = [val_name[23]];
        return()
    } else if __PSTATE_EL == EL2 then {
        PSTATE.UAO = [val_name[23]];
        return()
    } else if __PSTATE_EL == EL3 then {
        PSTATE.UAO = [val_name[23]];
        return()
    } else ()
}

val VBAR_EL12_SysRegWrite_a20f8f7f07b5cf7a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VBAR_EL12_SysRegWrite_a20f8f7f07b5cf7a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x18))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x18))
                }
            } else {
                VBAR_EL1 = ZeroExtend(val_name);
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            } else {
                VBAR_EL1 = ZeroExtend(val_name);
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val VBAR_EL1_SysRegWrite_29ba7540e032fce6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VBAR_EL1_SysRegWrite_29ba7540e032fce6 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VBAR_EL1 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if __HCR_EL2_E2H == 0b1 then {
            VBAR_EL2 = ZeroExtend(val_name);
            return()
        } else {
            VBAR_EL1 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VBAR_EL1 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val VBAR_EL2_SysRegWrite_d5657e8591e8e22a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VBAR_EL2_SysRegWrite_d5657e8591e8e22a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VBAR_EL2 = ZeroExtend(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VBAR_EL2 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val VBAR_EL3_SysRegWrite_1da603c27eb5f668 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VBAR_EL3_SysRegWrite_1da603c27eb5f668 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VBAR_EL3 = ZeroExtend(val_name);
            return()
        }
    } else ()
}

val VDISR_EL2_SysRegWrite_8b2c23874e253f64 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VDISR_EL2_SysRegWrite_8b2c23874e253f64 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VDISR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VDISR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val VMPIDR_EL2_SysRegWrite_c153d7c8b5628bd5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VMPIDR_EL2_SysRegWrite_c153d7c8b5628bd5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VMPIDR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(HaveEL(EL2)) then {
            return()
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VMPIDR_EL2 = val_name;
            return()
        }
    } else ()
}

val VPIDR_EL2_SysRegWrite_0dbf139af5a73d1f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VPIDR_EL2_SysRegWrite_0dbf139af5a73d1f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VPIDR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(HaveEL(EL2)) then {
            return()
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VPIDR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val VSESR_EL2_SysRegWrite_e989f4bcf0ae8aa6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VSESR_EL2_SysRegWrite_e989f4bcf0ae8aa6 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VSESR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VSESR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val VTCR_EL2_SysRegWrite_d49abb8b3aa0eff3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VTCR_EL2_SysRegWrite_d49abb8b3aa0eff3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VTCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VTCR_EL2 = val_name[31 .. 0];
            return()
        }
    } else ()
}

val VTTBR_EL2_SysRegWrite_5198ee0e793550a5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VTTBR_EL2_SysRegWrite_5198ee0e793550a5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            VTTBR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            VTTBR_EL2 = val_name;
            return()
        }
    } else ()
}

val AArch64_AutoGen_SysRegWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_SysRegWrite (el, op0, op1, CRn, op2, CRm, val_name) = {
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        TPIDR_EL1_SysRegWrite_566127c19bf948d1(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        SP_EL2_SysRegWrite_a29ffeac6d3856e5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        ELR_EL2_SysRegWrite_9f4ca59c1a88f1a9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ELR_EL1_SysRegWrite_b6bd589b2dd79575(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        TPIDRRO_EL0_SysRegWrite_20bedffb2581e57d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        TPIDR_EL2_SysRegWrite_adfab02a898d4b19(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        TPIDR_EL0_SysRegWrite_6b1ef76c828f0bf5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        SP_EL1_SysRegWrite_84ae51cf4bf77caa(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        ELR_EL3_SysRegWrite_8cd0b0c7f61ee7aa(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        SP_EL0_SysRegWrite_78f870c69d82f9e2(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        TPIDR_EL3_SysRegWrite_08e0e9cc5d3f6f5c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        VBAR_EL2_SysRegWrite_d5657e8591e8e22a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        VBAR_EL1_SysRegWrite_29ba7540e032fce6(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        VBAR_EL3_SysRegWrite_1da603c27eb5f668(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        VBAR_EL12_SysRegWrite_a20f8f7f07b5cf7a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        ELR_EL12_SysRegWrite_6720e93c266dadea(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b100 then {
        RTPIDR_EL0_SysRegWrite_74d55919bd0ab5f3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b111) & op2 == 0b011 then {
        RSP_EL0_SysRegWrite_5b2edb6edd27507d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        HCR_EL2_SysRegWrite_6fc18e07a17fd5a2(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0111) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        PAR_EL1_SysRegWrite_aa92c70a4b5d5873(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        CNTVOFF_EL2_SysRegWrite_621ada4cfda60bcb(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & (match CRn {
      [bitone, _, bitone, bitone] => true,
      _ => false
    }) : bool) & op0 == 0b11) & (match op1 {
      [_, _, _] => true,
      _ => false
    }) : bool) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        S3_op1_CCn_CCm_op2_SysRegWrite_22dd63287f599042(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [bitone, bitone, bitzero, _] => true,
      _ => false
    }) : bool & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        ICH_LR_EL2_SysRegWrite_8b291f94259261d2(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        MAIR_EL2_SysRegWrite_4e3422c1776528f5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        MAIR_EL1_SysRegWrite_45d8150aaf31e3b9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        ACTLR_EL3_SysRegWrite_c797d5a80525afa4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        AMAIR_EL2_SysRegWrite_9345da970d78b298(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        AMAIR_EL1_SysRegWrite_0d9c3d92d9a71703(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        FAR_EL1_SysRegWrite_fc0bd224b62cc089(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        FAR_EL12_SysRegWrite_78f825940e556299(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        AMAIR_EL3_SysRegWrite_622c473bfedac80a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        SCXTNUM_EL1_SysRegWrite_6467f6f26a31cece(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b111 then {
        SCXTNUM_EL12_SysRegWrite_ba74367909393c9b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        TCR_EL2_SysRegWrite_5e38279a245750c4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        TCR_EL1_SysRegWrite_c27e6fc190bb0f0b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        HACR_EL2_SysRegWrite_5b2ca32fcb39ecab(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        ICC_ASGI1R_EL1_SysRegWrite_c163c25adc1b1354(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        CNTP_CVAL_EL0_SysRegWrite_d54c08ee0cf9aaf7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        CNTP_CVAL_EL02_SysRegWrite_2b3e9ccfce186a4f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        SCTLR_EL1_SysRegWrite_711b0546c662c54d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        SCTLR_EL12_SysRegWrite_302de25977d2a0ca(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        AMAIR_EL12_SysRegWrite_9c44aba2de7c2ff8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        SCXTNUM_EL0_SysRegWrite_9dbee2793d69c02e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ACTLR_EL1_SysRegWrite_338051dbe9bdf650(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        VMPIDR_EL2_SysRegWrite_c153d7c8b5628bd5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        ICC_SGI1R_EL1_SysRegWrite_0da31fe6c2e1b098(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        ACTLR_EL2_SysRegWrite_416ec7c6fadd122d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        FAR_EL3_SysRegWrite_397cfda85a093e9d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        TTBR1_EL2_SysRegWrite_59fad32bc548b47a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        TTBR1_EL1_SysRegWrite_89690e4d3c87217b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        DBGDTR_EL0_SysRegWrite_c7246a22e06c7729(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        DLR_EL0_SysRegWrite_a2d10a509fed3a63(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        DBGBVR_EL1_SysRegWrite_915752bfd6a41a2b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        AFSR1_EL3_SysRegWrite_d776cc264803f49e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b111) & op2 == 0b010 then {
        CNTPS_CVAL_EL1_SysRegWrite_f09243080b7c260d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        LOREA_EL1_SysRegWrite_2d068511b7f5ce7b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        MAIR_EL12_SysRegWrite_da2526ed2008ed50(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        DBGWVR_EL1_SysRegWrite_745b296ee53305ea(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        TTBR0_EL3_SysRegWrite_7e091a8effc9ee7f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        CNTV_CVAL_EL0_SysRegWrite_f237c5c94ec92951(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        CNTV_CVAL_EL02_SysRegWrite_7548964ed28b5abb(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        CNTHP_CVAL_EL2_SysRegWrite_36de219faded7cbc(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        ICC_SGI0R_EL1_SysRegWrite_ba6d1066ea6fbbb7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        TCR_EL12_SysRegWrite_64a7f44c6ddaa0f8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b100 then {
        HPFAR_EL2_SysRegWrite_20417eccdd6b4768(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b111 then {
        SCXTNUM_EL3_SysRegWrite_b39fe9ab09a67ecd(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        TTBR1_EL12_SysRegWrite_4fbeb1f28c2e8107(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        SCTLR_EL3_SysRegWrite_5b7cc79e5ea93a8f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        AFSR0_EL3_SysRegWrite_e615501306210a25(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        AFSR1_EL2_SysRegWrite_c0ebc4cc65472544(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        AFSR1_EL1_SysRegWrite_6690138c9fdd136c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        MAIR_EL3_SysRegWrite_d15af780e0b4e771(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1101 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        PMCCNTR_EL0_SysRegWrite_1d21e0789830cbf9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        AFSR0_EL2_SysRegWrite_2f9da4789f5b4073(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        AFSR0_EL1_SysRegWrite_04474930979e1c86(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        SCTLR_EL2_SysRegWrite_ff61a6f00288b28a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        TTBR0_EL2_SysRegWrite_7cd39d4a24a70e7f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        TTBR0_EL1_SysRegWrite_8a149790a79e2eab(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        AFSR1_EL12_SysRegWrite_9dbf207cccd92d9d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        FAR_EL2_SysRegWrite_6370aabce83a1613(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        AFSR0_EL12_SysRegWrite_9fafb4f6dbddd904(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        CNTHV_CVAL_EL2_SysRegWrite_b3d7c631e2b3eaab(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        LORSA_EL1_SysRegWrite_9ba633e967136731(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        SCXTNUM_EL2_SysRegWrite_2fcbb6503badb23c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        VTTBR_EL2_SysRegWrite_5198ee0e793550a5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        TTBR0_EL12_SysRegWrite_fd9df8519bfad5c0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        MPAM3_EL3_SysRegWrite_bb55d8a9d90e05e3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        MPAMVPM2_EL2_SysRegWrite_20a1b54bc18980b1(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        MPAMVPM5_EL2_SysRegWrite_ec98ca57d40ac9ec(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b110 then {
        MPAMVPM6_EL2_SysRegWrite_0934853fee68e9bd(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        MPAMVPM7_EL2_SysRegWrite_dfb7f68750df7012(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        MPAMVPM0_EL2_SysRegWrite_c00108111630aa84(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        MPAMVPM3_EL2_SysRegWrite_d2a71d8e23cc67af(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        MPAM2_EL2_SysRegWrite_d6bae8d18aebb554(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        MPAM1_EL1_SysRegWrite_cd02720a3298b1c6(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        MPAM0_EL1_SysRegWrite_88f6c0c61a59ac23(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        MPAMVPM1_EL2_SysRegWrite_81a739cc4bd1cd46(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b100 then {
        MPAMVPM4_EL2_SysRegWrite_2d0a10731399829d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        MPAM1_EL12_SysRegWrite_2cbbb0edf5787671(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        PMBPTR_EL1_SysRegWrite_32441d8a7a2b9601(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        PMSICR_EL1_SysRegWrite_1e74423ea1c96ae7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        PMSEVFR_EL1_SysRegWrite_6524c56cd8a10057(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        PMBLIMITR_EL1_SysRegWrite_ddfe2ba603df6628(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        ERXADDR_EL1_SysRegWrite_8a1eabc2959662e8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        ERXMISC0_EL1_SysRegWrite_822ceca9b10b2621(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ERXMISC1_EL1_SysRegWrite_9a9ef77b5fd82587(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ERXCTLR_EL1_SysRegWrite_acca1e102ba86b42(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        ERXSTATUS_EL1_SysRegWrite_f0798b4207ec0193(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        CONTEXTIDR_EL1_SysRegWrite_5408e4e72af4e23d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        CONTEXTIDR_EL12_SysRegWrite_33154953ae1b01d5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        DSPSR_EL0_SysRegWrite_6d6dabfcb332ec05(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b101 then {
        PMSELR_EL0_SysRegWrite_18613307de8564a3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        ICC_CTLR_EL1_SysRegWrite_8ec3f4b67393eba8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & (match op2 {
      [bitzero, _, _] => true,
      _ => false
    }) : bool then {
        ICC_AP1R_EL1_SysRegWrite_55167410f7650dea(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        DAIF_SysRegWrite_3d31f214debf624b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        CNTP_CTL_EL0_SysRegWrite_137f81090c1357e6(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        CNTP_CTL_EL02_SysRegWrite_99a9da3e2454714e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [bitone, bitzero, _, _] => true,
      _ => false
    }) : bool & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        PMEVCNTR_EL0_SysRegWrite_c197579331ed9cbb(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        CNTHV_TVAL_EL2_SysRegWrite_e215d12d330397f1(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        CNTV_TVAL_EL0_SysRegWrite_903191acca729cda(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        SPSR_irq_SysRegWrite_d42335013c288fbe(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        SPSR_abt_SysRegWrite_ecb9f412e44a217b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & (match op2 {
      [bitone, _, _] => true,
      _ => false
    }) : bool then {
        ICC_AP0R_EL1_SysRegWrite_949897f971748acc(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        ESR_EL1_SysRegWrite_a8ce40896bd70a6b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        ESR_EL12_SysRegWrite_2b2d6012ba438548(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        ICC_BPR1_EL1_SysRegWrite_a633b2e9f3626d9b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        TCR_EL3_SysRegWrite_3b3587015a3d20f4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        ICC_PMR_EL1_SysRegWrite_8bb2caa31e7d5e1b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ICC_EOIR1_EL1_SysRegWrite_f065db56e179bf6e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        ESR_EL2_SysRegWrite_a10e84e3bd1020c8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        RMR_EL1_SysRegWrite_0ae19f794f511c7a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        LORN_EL1_SysRegWrite_bde03c74e878b099(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        HSTR_EL2_SysRegWrite_391a605c0bfb9d1e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b100 then {
        ICC_CTLR_EL3_SysRegWrite_ecc8b41b177c53e8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b111 then {
        ICH_VMCR_EL2_SysRegWrite_86a315374f6b5205(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        PMCNTENCLR_EL0_SysRegWrite_bf2c4fae1a891e1b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        MDCR_EL3_SysRegWrite_37dff5fa83ad16ed(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b101 then {
        ICC_SRE_EL2_SysRegWrite_39c314f677b8ec2e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b111) & op2 == 0b001 then {
        CNTPS_CTL_EL1_SysRegWrite_a0625fd9f7b035a8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0011) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        DACR32_EL2_SysRegWrite_a8bad0131817f121(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        LORC_EL1_SysRegWrite_7100b979c23fc52e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        SPSR_und_SysRegWrite_76485ab5b58e2a80(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b110 then {
        SSBS_SysRegWrite_e080097cffcde083(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        ICH_HCR_EL2_SysRegWrite_2fea52a15cd7dbe5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        ICC_IGRPEN0_EL1_SysRegWrite_b94e4d10f7a33382(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        FPCR_SysRegWrite_4f255cf55390cebb(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        PMCR_EL0_SysRegWrite_87ae64466e09f89a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        DBGPRCR_EL1_SysRegWrite_710b60256172548e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        ICC_BPR0_EL1_SysRegWrite_10028206553f3655(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        PAN_SysRegWrite_aedbb13e40f0add0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        MDCR_EL2_SysRegWrite_3f12005c8c459bf3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        CONTEXTIDR_EL2_SysRegWrite_27187b6dc7c5a748(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        FPSR_SysRegWrite_413aed98a94900de(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        CNTP_TVAL_EL0_SysRegWrite_d7441eec23c3d524(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        CNTP_TVAL_EL02_SysRegWrite_caa9f2aa73cb6b96(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & (match op2 {
      [bitzero, _, _] => true,
      _ => false
    }) : bool then {
        ICH_AP1R_EL2_SysRegWrite_20f46016b54a3395(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ICC_DIR_EL1_SysRegWrite_77fadeda7efde9c5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b100) & op2 == 0b000 then {
        DBGVCR32_EL2_SysRegWrite_769fbfe4fa51a4e5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b111 then {
        ICC_IGRPEN1_EL1_SysRegWrite_c36dfa556252f6b4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b101 then {
        DBGBCR_EL1_SysRegWrite_6730f3e3839510c5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1111 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        PMCCFILTR_EL0_SysRegWrite_42277f001664525c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b101 then {
        ICC_SRE_EL1_SysRegWrite_d2efb75caa67d019(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        DBGCLAIMSET_EL1_SysRegWrite_90e355b6a5730770(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        CPTR_EL2_SysRegWrite_5a082f460b1b2308(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        CPACR_EL1_SysRegWrite_00878a1f3e87823c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & (match op2 {
      [bitzero, _, _] => true,
      _ => false
    }) : bool then {
        ICH_AP0R_EL2_SysRegWrite_9517857bb550d699(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        RMR_EL3_SysRegWrite_2849130fc457929e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ICC_EOIR0_EL1_SysRegWrite_9c0fae08cd7a2444(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b010) & op2 == 0b000 then {
        CSSELR_EL1_SysRegWrite_1f9e1e0300c8783c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b000 then {
        MDCCINT_EL1_SysRegWrite_1e6a37984aec7145(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        UAO_SysRegWrite_594f371263b733f0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        CNTKCTL_EL1_SysRegWrite_9a7be69aa33bb9c2(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        CNTKCTL_EL12_SysRegWrite_518123f17a6402e4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        PMINTENCLR_EL1_SysRegWrite_1ebd7bf3738fe872(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        SPSR_EL3_SysRegWrite_7b0326ec9be492f4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        OSECCR_EL1_SysRegWrite_cabf381bfb822732(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1101 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        PMXEVCNTR_EL0_SysRegWrite_20b0a6df43a7d4ef(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        SCR_EL3_SysRegWrite_020d082781fa9b72(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        PMUSERENR_EL0_SysRegWrite_e7535626e3360c36(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b111) & op2 == 0b000 then {
        CNTPS_TVAL_EL1_SysRegWrite_a9b16e60037fa746(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        OSDLR_EL1_SysRegWrite_591fd96d91652c64(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        CNTV_TVAL_EL02_SysRegWrite_dc97f79a5f74078f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        PMCNTENSET_EL0_SysRegWrite_227af2773d320cb1(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        VTCR_EL2_SysRegWrite_d49abb8b3aa0eff3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b0111) & op0 == 0b10) & op1 == 0b000) & op2 == 0b110 then {
        DBGCLAIMCLR_EL1_SysRegWrite_2a099a67767e57cf(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        RMR_EL2_SysRegWrite_df7b9a989e2495d2(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        CNTHV_CTL_EL2_SysRegWrite_ecc786a588fc8ab9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        CNTV_CTL_EL0_SysRegWrite_e9fd22bae4b06064(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        SPSR_EL2_SysRegWrite_1d65bd974e988727(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        SPSR_EL1_SysRegWrite_c3a982c3130dcaea(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        NZCV_SysRegWrite_a047a536d32ae853(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        PMINTENSET_EL1_SysRegWrite_dd2481ad892e3441(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1110 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        PMOVSSET_EL0_SysRegWrite_cfbbfe3b81fe4290(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & op2 == 0b000 then {
        CNTFRQ_EL0_SysRegWrite_0fac77f077759456(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        CPACR_EL12_SysRegWrite_637092a999939f8b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        SPSR_EL12_SysRegWrite_cabdb902efd62924(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        FPEXC32_EL2_SysRegWrite_9f180ead5c4d6735(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        MDSCR_EL1_SysRegWrite_94ddb1e46aff4dfa(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        SPSel_SysRegWrite_c849e120e8533c8c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        SPSR_fiq_SysRegWrite_760097483f6eab5e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        SDER32_EL3_SysRegWrite_69011ff5e95ac923(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        PMOVSCLR_EL0_SysRegWrite_9dfa73cda394af99(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        CNTHP_CTL_EL2_SysRegWrite_92034fc54290a7b8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        CNTHP_TVAL_EL2_SysRegWrite_877bbf4f78f810b9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        DBGDTRTX_EL0_SysRegWrite_057e8c91e001a69f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        CNTHCTL_EL2_SysRegWrite_eb0cbec9f9398e0e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        OSDTRRX_EL1_SysRegWrite_6dc5d8521b60df8a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        IFSR32_EL2_SysRegWrite_6ce25b2b11e30403(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b111 then {
        ICC_IGRPEN1_EL3_SysRegWrite_6f1db000a53b40ca(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1101 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        PMXEVTYPER_EL0_SysRegWrite_82fb55a6e723e983(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b111 then {
        DBGWCR_EL1_SysRegWrite_6bda3acb5910d354(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        CPTR_EL3_SysRegWrite_879d4b1bad53408b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b100 then {
        PMSWINC_EL0_SysRegWrite_cce1d915b163d5e3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        ESR_EL3_SysRegWrite_195a2e1a5b40464e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool & CRn == 0b1110) & op0 == 0b11) & op1 == 0b011) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        PMEVTYPER_EL0_SysRegWrite_3e6ae16cd645ec0d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1110) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        CNTV_CTL_EL02_SysRegWrite_d6cac9cc52dd8fec(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b101 then {
        ICC_SRE_EL3_SysRegWrite_c0af2dd58a7e1d22(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b000) & op2 == 0b010 then {
        OSDTRTX_EL1_SysRegWrite_9ba0c4a85d0c1de5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0001) & op0 == 0b10) & op1 == 0b000) & op2 == 0b100 then {
        OSLAR_EL1_SysRegWrite_582d77c57653b2c4(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0000) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        VPIDR_EL2_SysRegWrite_0dbf139af5a73d1f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        MPAMHCR_EL2_SysRegWrite_e38755d6111336b8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1010) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        MPAMVPMV_EL2_SysRegWrite_abd8d27e91fadf85(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        PMSCR_EL2_SysRegWrite_02cd14dd325ed94b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        PMSCR_EL1_SysRegWrite_9798a89ab6804fe0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        PMSIRR_EL1_SysRegWrite_bb25878486c35a36(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        PMSFCR_EL1_SysRegWrite_44d58271848f0db1(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1010 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b011 then {
        PMBSR_EL1_SysRegWrite_ff19dc948509312f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        PMSCR_EL12_SysRegWrite_fef9a94f50c2763b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b1001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b110 then {
        PMSLATFR_EL1_SysRegWrite_5c8b43a6a65c8272(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        VDISR_EL2_SysRegWrite_8b2c23874e253f64(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        DISR_EL1_SysRegWrite_64517664b9260065(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        VSESR_EL2_SysRegWrite_e989f4bcf0ae8aa6(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        ERRSELR_EL1_SysRegWrite_551535eed30e26f9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b011 then {
        CHCR_EL2_SysRegWrite_dadda8ecf053e448(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        CCTLR_EL0_SysRegWrite_a4d8c57cb436292b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        CCTLR_EL3_SysRegWrite_f5e936c8846e6fc7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b000) & op2 == 0b010 then {
        CCTLR_EL1_SysRegWrite_dc20ad2a867ac9bf(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b101) & op2 == 0b010 then {
        CCTLR_EL12_SysRegWrite_c7d9d6463096d910(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        CCTLR_EL2_SysRegWrite_65620c8ccb1113a5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0010 & CRn == 0b0001) & op0 == 0b11) & op1 == 0b110) & op2 == 0b011 then {
        CSCR_EL3_SysRegWrite_22b95c83b04d6c91(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    throw(Error_Undefined())
}

val TakeReset : forall ('cold : Bool). bool('cold) -> unit

val AArch64_SysRegWrite : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SysRegWrite (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_SysRegWrite(PSTATE.EL, op0[1 .. 0], op1[2 .. 0], crn[3 .. 0], op2[2 .. 0], crm[3 .. 0], val_name);
    if ((((op0 == 3 & crn == UInt(0xc)) & ((op1 == 6 | op1 == 4) | op1 == 0)) & op2 == 2) & crm == 0) & [val_name[1]] == 0b1 then {
        TakeReset(false)
    } else ();
    return()
}

val CDBGDTR_EL0_CapSysRegWrite_336052f10e4a36b7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CDBGDTR_EL0_CapSysRegWrite_336052f10e4a36b7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else if (((PSTATE.EL == EL1 | PSTATE.EL == EL0) & not_bool(ELUsingAArch32(EL1))) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        }
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
        AArch64_SystemAccessTrap(EL3, UInt(0x29))
    } else {
        CDBGDTR_EL0 = val_name;
        return()
    }
}

val CDLR_EL0_CapSysRegWrite_2763be7daadf3c03 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CDLR_EL0_CapSysRegWrite_2763be7daadf3c03 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else if (((PSTATE.EL == EL1 | PSTATE.EL == EL0) & not_bool(ELUsingAArch32(EL1))) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        }
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
        AArch64_SystemAccessTrap(EL3, UInt(0x29))
    } else {
        CDLR_EL0 = val_name;
        return()
    }
}

val CELR_EL12_CapSysRegWrite_a1507df00ba9d725 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CELR_EL12_CapSysRegWrite_a1507df00ba9d725 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
              [_, bitzero] => true,
              _ => false
            }) : bool then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29))
            } else {
                ELR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29))
            } else {
                ELR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CELR_EL1_CapSysRegWrite_33a9b4f0fad89fe8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CELR_EL1_CapSysRegWrite_33a9b4f0fad89fe8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            ELR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 then {
            ELR_EL2 = val_name;
            return()
        } else {
            ELR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            ELR_EL1 = val_name;
            return()
        }
    } else ()
}

val CELR_EL2_CapSysRegWrite_8d32fe1dd5ad0417 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CELR_EL2_CapSysRegWrite_8d32fe1dd5ad0417 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            ELR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            ELR_EL2 = val_name;
            return()
        }
    } else ()
}

val CELR_EL3_CapSysRegWrite_55e82fec5d907003 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CELR_EL3_CapSysRegWrite_55e82fec5d907003 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            ELR_EL3 = val_name;
            return()
        }
    } else ()
}

val CID_EL0_CapSysRegWrite_8c1c5cf69181759f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CID_EL0_CapSysRegWrite_8c1c5cf69181759f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CID_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CID_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CID_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            CID_EL0 = val_name;
            return()
        }
    } else ()
}

val CSP_EL0_CapSysRegWrite_ee1d127810ef0f04 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CSP_EL0_CapSysRegWrite_ee1d127810ef0f04 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            SP_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            SP_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            SP_EL0 = val_name;
            return()
        }
    } else ()
}

val CSP_EL1_CapSysRegWrite_f4579d836810c21a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CSP_EL1_CapSysRegWrite_f4579d836810c21a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            SP_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            SP_EL1 = val_name;
            return()
        }
    } else ()
}

val CSP_EL2_CapSysRegWrite_59c69d74679ef283 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CSP_EL2_CapSysRegWrite_59c69d74679ef283 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            SP_EL2 = val_name;
            return()
        }
    } else ()
}

val CTPIDRRO_EL0_CapSysRegWrite_e64109ff95ad4800 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CTPIDRRO_EL0_CapSysRegWrite_e64109ff95ad4800 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDRRO_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDRRO_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDRRO_EL0 = val_name;
            return()
        }
    } else ()
}

val CTPIDR_EL0_CapSysRegWrite_8f94c4d256adadf0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CTPIDR_EL0_CapSysRegWrite_8f94c4d256adadf0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = val_name;
            return()
        } else {
            TPIDR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDR_EL0 = val_name;
            return()
        }
    } else ()
}

val CTPIDR_EL1_CapSysRegWrite_3190df090d2d128f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CTPIDR_EL1_CapSysRegWrite_3190df090d2d128f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = val_name;
            return()
        } else {
            TPIDR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDR_EL1 = val_name;
            return()
        }
    } else ()
}

val CTPIDR_EL2_CapSysRegWrite_a740113e578c9b32 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CTPIDR_EL2_CapSysRegWrite_a740113e578c9b32 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = val_name;
            return()
        } else {
            TPIDR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            TPIDR_EL2 = val_name;
            return()
        }
    } else ()
}

val CTPIDR_EL3_CapSysRegWrite_376b7d525b15b21b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CTPIDR_EL3_CapSysRegWrite_376b7d525b15b21b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            RTPIDR_EL0 = val_name;
            return()
        } else {
            TPIDR_EL3 = val_name;
            return()
        }
    } else ()
}

val CVBAR_EL12_CapSysRegWrite_3fd157cf974c31e5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CVBAR_EL12_CapSysRegWrite_3fd157cf974c31e5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                if TargetELForCapabilityExceptions() == EL2 then {
                    AArch64_SystemAccessTrap(EL2, UInt(0x2A))
                } else {
                    AArch64_SystemAccessTrap(EL3, UInt(0x2A))
                }
            } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
              [_, bitzero] => true,
              _ => false
            }) : bool then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29))
            } else {
                VBAR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else if __PSTATE_EL == EL3 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1 then {
            if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A))
            } else if __CPTR_EL3_EC == 0b0 then {
                AArch64_SystemAccessTrap(EL3, UInt(0x29))
            } else {
                VBAR_EL1 = val_name;
                return()
            }
        } else {
            throw(Error_Undefined())
        }
    } else ()
}

val CVBAR_EL1_CapSysRegWrite_bbad0575f41fce2f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CVBAR_EL1_CapSysRegWrite_bbad0575f41fce2f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x2A))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x2A))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A))
            }
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            VBAR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x2A))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 then {
            VBAR_EL2 = val_name;
            return()
        } else {
            VBAR_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x2A))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            VBAR_EL1 = val_name;
            return()
        }
    } else ()
}

val CVBAR_EL2_CapSysRegWrite_2a412e2b2c0a0a2b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CVBAR_EL2_CapSysRegWrite_2a412e2b2c0a0a2b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x2A))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x2A))
            }
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            VBAR_EL2 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x2A))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            VBAR_EL2 = val_name;
            return()
        }
    } else ()
}

val CVBAR_EL3_CapSysRegWrite_f3c8bbee84b292db : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function CVBAR_EL3_CapSysRegWrite_f3c8bbee84b292db (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x2A))
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            VBAR_EL3 = val_name;
            return()
        }
    } else ()
}

val DDC_CapSysRegWrite_9bc98e4e82148914 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function DDC_CapSysRegWrite_9bc98e4e82148914 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    if ((PSTATE.EL == EL0 & not_bool(ELUsingAArch32(EL1))) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
        if EL2Enabled() & __HCR_EL2_TGE == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        }
    } else if PSTATE.EL == EL1 & (match __CPACR_EL1_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL1, UInt(0x29))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
      [_, bitzero] => true,
      _ => false
    }) : bool then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if ((((PSTATE.EL == EL1 | PSTATE.EL == EL0 | PSTATE.EL == EL2) & EL2Enabled()) & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
        AArch64_SystemAccessTrap(EL2, UInt(0x29))
    } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
        AArch64_SystemAccessTrap(EL3, UInt(0x29))
    } else if IsInRestricted() then {
        RDDC_EL0 = val_name;
        return()
    } else if __PSTATE_SP == 0b0 then {
        DDC_EL0 = val_name;
        return()
    } else if PSTATE.EL == EL0 then {
        DDC_EL0 = val_name;
        return()
    } else if PSTATE.EL == EL1 then {
        DDC_EL1 = val_name;
        return()
    } else if PSTATE.EL == EL2 then {
        DDC_EL2 = val_name;
        return()
    } else if PSTATE.EL == EL3 then {
        DDC_EL3 = val_name;
        return()
    } else ()
}

val DDC_EL0_CapSysRegWrite_1a928678ff9b43a6 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function DDC_EL0_CapSysRegWrite_1a928678ff9b43a6 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __PSTATE_SP : bits(1) = PSTATE.SP;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            DDC_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            DDC_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if __PSTATE_SP == 0b0 then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            DDC_EL0 = val_name;
            return()
        }
    } else ()
}

val DDC_EL1_CapSysRegWrite_e7ecb5b1f0c49d28 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function DDC_EL1_CapSysRegWrite_e7ecb5b1f0c49d28 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            DDC_EL1 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            DDC_EL1 = val_name;
            return()
        }
    } else ()
}

val DDC_EL2_CapSysRegWrite_b4142a2dcadf2a34 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function DDC_EL2_CapSysRegWrite_b4142a2dcadf2a34 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            DDC_EL2 = val_name;
            return()
        }
    } else ()
}

val RCSP_EL0_CapSysRegWrite_d8f83400674fbeeb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function RCSP_EL0_CapSysRegWrite_d8f83400674fbeeb (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RSP_EL0 = val_name;
            return()
        }
    } else ()
}

val RCTPIDR_EL0_CapSysRegWrite_27f7c47e137c72f8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function RCTPIDR_EL0_CapSysRegWrite_27f7c47e137c72f8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RTPIDR_EL0 = val_name;
            return()
        }
    } else ()
}

val RDDC_EL0_CapSysRegWrite_c528d1b2eb785ad7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function RDDC_EL0_CapSysRegWrite_c528d1b2eb785ad7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __CPACR_EL1_CEN : bits(2) = Slice(CPACR_EL1, 18, 2);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __CPTR_EL2_CEN : bits(2) = Slice(CPTR_EL2, 18, 2);
    let __HCR_EL2_E2H : bits(1) = Slice(HCR_EL2, 34, 1);
    let __CPTR_EL2_TC : bits(1) = Slice(CPTR_EL2, 9, 1);
    let __CPTR_EL3_EC : bits(1) = Slice(CPTR_EL3, 9, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __CPACR_EL1_CEN != 0b11 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x29))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x29))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __CPTR_EL2_CEN != 0b11 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RDDC_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if (match __CPACR_EL1_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL1, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H != 0b1) & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_E2H == 0b1) & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RDDC_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __HCR_EL2_E2H == 0b0 & __CPTR_EL2_TC == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if __HCR_EL2_E2H == 0b1 & (match __CPTR_EL2_CEN {
          [_, bitzero] => true,
          _ => false
        }) : bool then {
            AArch64_SystemAccessTrap(EL2, UInt(0x29))
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RDDC_EL0 = val_name;
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & IsInRestricted()) & not_bool(Halted()) then {
            throw(Error_Undefined())
        } else if __CPTR_EL3_EC == 0b0 then {
            AArch64_SystemAccessTrap(EL3, UInt(0x29))
        } else {
            RDDC_EL0 = val_name;
            return()
        }
    } else ()
}

val AArch64_AutoGen_CapSysRegWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_CapSysRegWrite (el, op0, op1, CRn, op2, CRm, val_name) = {
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b000) & op2 == 0b100 then {
        CTPIDR_EL1_CapSysRegWrite_3190df090d2d128f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        CSP_EL2_CapSysRegWrite_59c69d74679ef283(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        CELR_EL2_CapSysRegWrite_8d32fe1dd5ad0417(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        CELR_EL1_CapSysRegWrite_33a9b4f0fad89fe8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b011 then {
        CTPIDRRO_EL0_CapSysRegWrite_e64109ff95ad4800(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b100) & op2 == 0b010 then {
        CTPIDR_EL2_CapSysRegWrite_a740113e578c9b32(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b010 then {
        CTPIDR_EL0_CapSysRegWrite_8f94c4d256adadf0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        CSP_EL1_CapSysRegWrite_f4579d836810c21a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        CELR_EL3_CapSysRegWrite_55e82fec5d907003(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        CSP_EL0_CapSysRegWrite_ee1d127810ef0f04(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b110) & op2 == 0b010 then {
        CTPIDR_EL3_CapSysRegWrite_376b7d525b15b21b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b000 then {
        CVBAR_EL2_CapSysRegWrite_2a412e2b2c0a0a2b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b000 then {
        CVBAR_EL1_CapSysRegWrite_bbad0575f41fce2f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b000 then {
        CVBAR_EL3_CapSysRegWrite_f3c8bbee84b292db(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b000 then {
        CVBAR_EL12_CapSysRegWrite_3fd157cf974c31e5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b101) & op2 == 0b001 then {
        CELR_EL12_CapSysRegWrite_a1507df00ba9d725(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b110) & op2 == 0b001 then {
        DDC_EL2_CapSysRegWrite_b4142a2dcadf2a34(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        DDC_CapSysRegWrite_9bc98e4e82148914(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b100 then {
        RCTPIDR_EL0_CapSysRegWrite_27f7c47e137c72f8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1101) & op0 == 0b11) & op1 == 0b011) & op2 == 0b111 then {
        CID_EL0_CapSysRegWrite_8c1c5cf69181759f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        CDLR_EL0_CapSysRegWrite_2763be7daadf3c03(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b111) & op2 == 0b011 then {
        RCSP_EL0_CapSysRegWrite_d8f83400674fbeeb(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b011) & op2 == 0b001 then {
        RDDC_EL0_CapSysRegWrite_c528d1b2eb785ad7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b000) & op2 == 0b001 then {
        DDC_EL0_CapSysRegWrite_1a928678ff9b43a6(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0000) & op0 == 0b10) & op1 == 0b011) & op2 == 0b000 then {
        CDBGDTR_EL0_CapSysRegWrite_336052f10e4a36b7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0100) & op0 == 0b11) & op1 == 0b100) & op2 == 0b001 then {
        DDC_EL1_CapSysRegWrite_e7ecb5b1f0c49d28(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    throw(Error_Undefined())
}

val DDC_set : bits(129) -> unit effect {rreg, wreg}

function DDC_set value_name = {
    DDC = value_name;
    if IsInRestricted() then {
        RDDC_EL0 = value_name
    } else if PSTATE.SP == 0b0 then {
        DDC_EL0 = value_name
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              DDC_EL0 = value_name
          },
          ? if ? == EL1 => {
              DDC_EL1 = value_name
          },
          ? if ? == EL2 => {
              DDC_EL2 = value_name
          },
          ? if ? == EL3 => {
              DDC_EL3 = value_name
          },
          _ => ()
        }
    }
}

val AArch64_CapSysRegWrite : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CapSysRegWrite (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_CapSysRegWrite(PSTATE.EL, op0[1 .. 0], op1[2 .. 0], crn[3 .. 0], op2[2 .. 0], crm[3 .. 0], val_name);
    let is_ddc : bool = (((op0 == 3 & op1 == 3) & crn == 4) & crm == 1) & op2 == 1;
    if is_ddc then {
        DDC_set() = val_name
    } else ()
}

val TLBI_ALLE1IS : unit -> unit

val ALLE1IS_SysOpsWrite_8b81b55e2116aad3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ALLE1IS_SysOpsWrite_8b81b55e2116aad3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_ALLE1IS();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ALLE1IS();
            return()
        }
    } else ()
}

val TLBI_ALLE1 : unit -> unit

val ALLE1_SysOpsWrite_69364bedc72cbe96 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ALLE1_SysOpsWrite_69364bedc72cbe96 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_ALLE1();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ALLE1();
            return()
        }
    } else ()
}

val TLBI_ALLE2IS : unit -> unit

val ALLE2IS_SysOpsWrite_3a173239947b2c25 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ALLE2IS_SysOpsWrite_3a173239947b2c25 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_ALLE2IS();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ALLE2IS();
            return()
        }
    } else ()
}

val TLBI_ALLE2 : unit -> unit

val ALLE2_SysOpsWrite_19c7b5110a5efe1d : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ALLE2_SysOpsWrite_19c7b5110a5efe1d (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_ALLE2();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ALLE2();
            return()
        }
    } else ()
}

val TLBI_ALLE3IS : unit -> unit

val ALLE3IS_SysOpsWrite_e64b79b4c41910fb : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ALLE3IS_SysOpsWrite_e64b79b4c41910fb (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ALLE3IS();
            return()
        }
    } else ()
}

val TLBI_ALLE3 : unit -> unit

val ALLE3_SysOpsWrite_5835ce2f987f3d36 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ALLE3_SysOpsWrite_5835ce2f987f3d36 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ALLE3();
            return()
        }
    } else ()
}

val TLBI_ASIDE1IS : bits(64) -> unit

val ASIDE1IS_SysOpsWrite_5a5dff91f113e41e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ASIDE1IS_SysOpsWrite_5a5dff91f113e41e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_TTLBIS : bits(1) = Slice(HCR_EL2, 54, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLBIS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TLBI_ASIDE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_ASIDE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ASIDE1IS(val_name);
            return()
        }
    } else ()
}

val TLBI_ASIDE1 : bits(64) -> unit

val ASIDE1_SysOpsWrite_7ba7a3df395925e0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ASIDE1_SysOpsWrite_7ba7a3df395925e0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            TLBI_ASIDE1IS(val_name);
            return()
        } else {
            TLBI_ASIDE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_ASIDE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_ASIDE1(val_name);
            return()
        }
    } else ()
}

val DC_CISW : bits(64) -> unit

val CISW_SysOpsWrite_5321b1c3157dccce : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CISW_SysOpsWrite_5321b1c3157dccce (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TSW : bits(1) = Slice(HCR_EL2, 22, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TSW == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CISW(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DC_CISW(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DC_CISW(val_name);
            return()
        }
    } else ()
}

val DC_CIVAC : bits(64) -> unit

val CIVAC_SysOpsWrite_47ad60ecb930d217 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CIVAC_SysOpsWrite_47ad60ecb930d217 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCI : bits(1) = Slice(SCTLR_EL1, 26, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TPCP : bits(1) = Slice(HCR_EL2, 23, 1);
    let __SCTLR_EL2_UCI : bits(1) = Slice(SCTLR_EL2, 26, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCI == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCI == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CIVAC(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CIVAC(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_CIVAC(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_CIVAC(val_name);
        return()
    } else ()
}

val DC_CSW : bits(64) -> unit

val CSW_SysOpsWrite_9544819da3ebaa1b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CSW_SysOpsWrite_9544819da3ebaa1b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TSW : bits(1) = Slice(HCR_EL2, 22, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TSW == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CSW(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DC_CSW(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DC_CSW(val_name);
            return()
        }
    } else ()
}

val DC_CVAC : bits(64) -> unit

val CVAC_SysOpsWrite_c7d2e911c691cc6b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CVAC_SysOpsWrite_c7d2e911c691cc6b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCI : bits(1) = Slice(SCTLR_EL1, 26, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TPCP : bits(1) = Slice(HCR_EL2, 23, 1);
    let __SCTLR_EL2_UCI : bits(1) = Slice(SCTLR_EL2, 26, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCI == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCI == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVAC(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVAC(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_CVAC(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_CVAC(val_name);
        return()
    } else ()
}

val DC_CVADP : bits(64) -> unit

val CVADP_SysOpsWrite_9953ef108c01d34a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CVADP_SysOpsWrite_9953ef108c01d34a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCI : bits(1) = Slice(SCTLR_EL1, 26, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TPCP : bits(1) = Slice(HCR_EL2, 23, 1);
    let __SCTLR_EL2_UCI : bits(1) = Slice(SCTLR_EL2, 26, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCI == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCI == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVADP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVADP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_CVADP(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_CVADP(val_name);
        return()
    } else ()
}

val DC_CVAP : bits(64) -> unit

val CVAP_SysOpsWrite_a43f75867888e74a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CVAP_SysOpsWrite_a43f75867888e74a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCI : bits(1) = Slice(SCTLR_EL1, 26, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TPCP : bits(1) = Slice(HCR_EL2, 23, 1);
    let __SCTLR_EL2_UCI : bits(1) = Slice(SCTLR_EL2, 26, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCI == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCI == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVAP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVAP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_CVAP(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_CVAP(val_name);
        return()
    } else ()
}

val DC_CVAU : bits(64) -> unit

val CVAU_SysOpsWrite_4a72bbc98a17973c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function CVAU_SysOpsWrite_4a72bbc98a17973c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCI : bits(1) = Slice(SCTLR_EL1, 26, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TPU : bits(1) = Slice(HCR_EL2, 24, 1);
    let __HCR_EL2_TOCU : bits(1) = Slice(HCR_EL2, 52, 1);
    let __SCTLR_EL2_UCI : bits(1) = Slice(SCTLR_EL2, 26, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCI == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TPU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TOCU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCI == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVAU(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TOCU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_CVAU(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_CVAU(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_CVAU(val_name);
        return()
    } else ()
}

val IC_IALLUIS : unit -> unit

val IALLUIS_SysOpsWrite_9a906c8365100aff : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IALLUIS_SysOpsWrite_9a906c8365100aff (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TPU : bits(1) = Slice(HCR_EL2, 24, 1);
    let __HCR_EL2_TICAB : bits(1) = Slice(HCR_EL2, 50, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TICAB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            IC_IALLUIS();
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            IC_IALLUIS();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            IC_IALLUIS();
            return()
        }
    } else ()
}

val IC_IALLU : unit -> unit

val IALLU_SysOpsWrite_81563797a4921929 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IALLU_SysOpsWrite_81563797a4921929 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TPU : bits(1) = Slice(HCR_EL2, 24, 1);
    let __HCR_EL2_TOCU : bits(1) = Slice(HCR_EL2, 52, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TOCU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            IC_IALLUIS();
            return()
        } else {
            IC_IALLU();
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            IC_IALLU();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            IC_IALLU();
            return()
        }
    } else ()
}

val TLBI_IPAS2E1IS : bits(64) -> unit

val IPAS2E1IS_SysOpsWrite_ed4be1feae90b987 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IPAS2E1IS_SysOpsWrite_ed4be1feae90b987 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_IPAS2E1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if not_bool(EL2Enabled()) then {
            return()
        } else {
            TLBI_IPAS2E1IS(val_name);
            return()
        }
    } else ()
}

val TLBI_IPAS2E1 : bits(64) -> unit

val IPAS2E1_SysOpsWrite_a65fef0d99f9428f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IPAS2E1_SysOpsWrite_a65fef0d99f9428f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_IPAS2E1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if not_bool(EL2Enabled()) then {
            return()
        } else {
            TLBI_IPAS2E1(val_name);
            return()
        }
    } else ()
}

val TLBI_IPAS2LE1IS : bits(64) -> unit

val IPAS2LE1IS_SysOpsWrite_5a72848dfefa19f3 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IPAS2LE1IS_SysOpsWrite_5a72848dfefa19f3 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_IPAS2LE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if not_bool(EL2Enabled()) then {
            return()
        } else {
            TLBI_IPAS2LE1IS(val_name);
            return()
        }
    } else ()
}

val TLBI_IPAS2LE1 : bits(64) -> unit

val IPAS2LE1_SysOpsWrite_10ca7ac6abdfed50 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IPAS2LE1_SysOpsWrite_10ca7ac6abdfed50 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_IPAS2LE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if not_bool(EL2Enabled()) then {
            return()
        } else {
            TLBI_IPAS2LE1(val_name);
            return()
        }
    } else ()
}

val DC_ISW : bits(64) -> unit

val ISW_SysOpsWrite_d5fceb001aa0aa7a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ISW_SysOpsWrite_d5fceb001aa0aa7a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TSW : bits(1) = Slice(HCR_EL2, 22, 1);
    let __HCR_EL2_SWIO : bits(1) = Slice(HCR_EL2, 1, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TSW == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_SWIO == 0b1 then {
            DC_CISW(val_name);
            return()
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) != 0b00 then {
            DC_CISW(val_name);
            return()
        } else {
            DC_ISW(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DC_ISW(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DC_ISW(val_name);
            return()
        }
    } else ()
}

val DC_IVAC : bits(64) -> unit

val IVAC_SysOpsWrite_41b93e0e56e4f107 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IVAC_SysOpsWrite_41b93e0e56e4f107 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TPCP : bits(1) = Slice(HCR_EL2, 23, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) != 0b00 then {
            DC_CIVAC(val_name);
            return()
        } else {
            DC_IVAC(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_IVAC(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_IVAC(val_name);
        return()
    } else ()
}

val IC_IVAU : bits(64) -> unit

val IVAU_SysOpsWrite_2dfe97b748dd324e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function IVAU_SysOpsWrite_2dfe97b748dd324e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_UCI : bits(1) = Slice(SCTLR_EL1, 26, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TPU : bits(1) = Slice(HCR_EL2, 24, 1);
    let __HCR_EL2_TOCU : bits(1) = Slice(HCR_EL2, 52, 1);
    let __SCTLR_EL2_UCI : bits(1) = Slice(SCTLR_EL2, 26, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_UCI == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TPU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TOCU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_UCI == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            IC_IVAU(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TPU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TOCU == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            IC_IVAU(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        IC_IVAU(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        IC_IVAU(val_name);
        return()
    } else ()
}

val CFP_RCTX : bits(64) -> unit

val RCTX_SysOpsWrite_bcc8cd10f2e68999 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RCTX_SysOpsWrite_bcc8cd10f2e68999 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_EnRCTX : bits(1) = Slice(SCTLR_EL1, 10, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __SCTLR_EL2_EnRCTX : bits(1) = Slice(SCTLR_EL2, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_EnRCTX == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_EnRCTX == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CFP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CFP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CFP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CFP_RCTX(val_name);
            return()
        }
    } else ()
}

val CPP_RCTX : bits(64) -> unit

val RCTX_SysOpsWrite_c287513d0d3e8e92 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RCTX_SysOpsWrite_c287513d0d3e8e92 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_EnRCTX : bits(1) = Slice(SCTLR_EL1, 10, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __SCTLR_EL2_EnRCTX : bits(1) = Slice(SCTLR_EL2, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_EnRCTX == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_EnRCTX == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            CPP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CPP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            CPP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            CPP_RCTX(val_name);
            return()
        }
    } else ()
}

val DVP_RCTX : bits(64) -> unit

val RCTX_SysOpsWrite_d614ec87236c038f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function RCTX_SysOpsWrite_d614ec87236c038f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_EnRCTX : bits(1) = Slice(SCTLR_EL1, 10, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __SCTLR_EL2_EnRCTX : bits(1) = Slice(SCTLR_EL2, 10, 1);
    if __PSTATE_EL == EL0 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_EnRCTX == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_EnRCTX == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DVP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DVP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            DVP_RCTX(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            DVP_RCTX(val_name);
            return()
        }
    } else ()
}

val AT_S12E0R : bits(64) -> unit

val AT_S1E0R : bits(64) -> unit

val S12E0R_SysOpsWrite_4df3d544cba811b7 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S12E0R_SysOpsWrite_4df3d544cba811b7 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00 then {
            AT_S1E0R(val_name);
            return()
        } else {
            AT_S12E0R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if EL2Enabled() & ((Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00) then {
            AT_S1E0R(val_name);
            return()
        } else if not_bool(EL2Enabled()) then {
            AT_S1E0R(val_name);
            return()
        } else {
            AT_S12E0R(val_name);
            return()
        }
    } else ()
}

val AT_S12E0W : bits(64) -> unit

val AT_S1E0W : bits(64) -> unit

val S12E0W_SysOpsWrite_1dbb37d4af097406 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S12E0W_SysOpsWrite_1dbb37d4af097406 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00 then {
            AT_S1E0W(val_name);
            return()
        } else {
            AT_S12E0W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if EL2Enabled() & ((Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00) then {
            AT_S1E0W(val_name);
            return()
        } else if not_bool(EL2Enabled()) then {
            AT_S1E0W(val_name);
            return()
        } else {
            AT_S12E0W(val_name);
            return()
        }
    } else ()
}

val AT_S12E1R : bits(64) -> unit

val AT_S1E1R : bits(64) -> unit

val S12E1R_SysOpsWrite_e44276c8f24d398f : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S12E1R_SysOpsWrite_e44276c8f24d398f (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00 then {
            AT_S1E1R(val_name);
            return()
        } else {
            AT_S12E1R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if EL2Enabled() & ((Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00) then {
            AT_S1E1R(val_name);
            return()
        } else if not_bool(EL2Enabled()) then {
            AT_S1E1R(val_name);
            return()
        } else {
            AT_S12E1R(val_name);
            return()
        }
    } else ()
}

val AT_S12E1W : bits(64) -> unit

val AT_S1E1W : bits(64) -> unit

val S12E1W_SysOpsWrite_c8b72d75cad90601 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S12E1W_SysOpsWrite_c8b72d75cad90601 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00 then {
            AT_S1E1W(val_name);
            return()
        } else {
            AT_S12E1W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if EL2Enabled() & ((Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | (Slice(HCR_EL2, 12, 1) @ Slice(HCR_EL2, 0, 1)) == 0b00) then {
            AT_S1E1W(val_name);
            return()
        } else if not_bool(EL2Enabled()) then {
            AT_S1E1W(val_name);
            return()
        } else {
            AT_S12E1W(val_name);
            return()
        }
    } else ()
}

val S1E0R_SysOpsWrite_0a1e21ea5b4c8722 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E0R_SysOpsWrite_0a1e21ea5b4c8722 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E0R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E0R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E0R(val_name);
            return()
        }
    } else ()
}

val S1E0W_SysOpsWrite_d102d49fd92af65a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E0W_SysOpsWrite_d102d49fd92af65a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E0W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E0W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E0W(val_name);
            return()
        }
    } else ()
}

val AT_S1E1RP : bits(64) -> unit

val S1E1RP_SysOpsWrite_4a6b1f71ee0182ab : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E1RP_SysOpsWrite_4a6b1f71ee0182ab (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1RP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1RP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E1RP(val_name);
            return()
        }
    } else ()
}

val S1E1R_SysOpsWrite_018a577644c5d23c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E1R_SysOpsWrite_018a577644c5d23c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E1R(val_name);
            return()
        }
    } else ()
}

val AT_S1E1WP : bits(64) -> unit

val S1E1WP_SysOpsWrite_bb1ddb9112effe2a : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E1WP_SysOpsWrite_bb1ddb9112effe2a (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1WP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1WP(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E1WP(val_name);
            return()
        }
    } else ()
}

val S1E1W_SysOpsWrite_df64f2f63c0911fd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E1W_SysOpsWrite_df64f2f63c0911fd (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E1W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E1W(val_name);
            return()
        }
    } else ()
}

val AT_S1E2R : bits(64) -> unit

val S1E2R_SysOpsWrite_5e865a96c06417c8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E2R_SysOpsWrite_5e865a96c06417c8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E2R(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E2R(val_name);
            return()
        }
    } else ()
}

val AT_S1E2W : bits(64) -> unit

val S1E2W_SysOpsWrite_1649806418453f02 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E2W_SysOpsWrite_1649806418453f02 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            AT_S1E2W(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E2W(val_name);
            return()
        }
    } else ()
}

val AT_S1E3R : bits(64) -> unit

val S1E3R_SysOpsWrite_6476f20e79e358be : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E3R_SysOpsWrite_6476f20e79e358be (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E3R(val_name);
            return()
        }
    } else ()
}

val AT_S1E3W : bits(64) -> unit

val S1E3W_SysOpsWrite_e92e083e28fa4dd0 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1E3W_SysOpsWrite_e92e083e28fa4dd0 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            AT_S1E3W(val_name);
            return()
        }
    } else ()
}

val S1_op1_Cn_Cm_op2_SysOpsWrite_d6b17d94c0df44bc : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function S1_op1_Cn_Cm_op2_SysOpsWrite_d6b17d94c0df44bc (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TIDCP : bits(1) = Slice(HCR_EL2, 20, 1);
    if __PSTATE_EL == EL1 then {
        if EL2Enabled() & __HCR_EL2_TIDCP == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            return()
        }
    } else {
        return()
    }
}

val TLBI_VAAE1IS : bits(64) -> unit

val VAAE1IS_SysOpsWrite_c22cd5a1dc8e7320 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAAE1IS_SysOpsWrite_c22cd5a1dc8e7320 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_TTLBIS : bits(1) = Slice(HCR_EL2, 54, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLBIS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TLBI_VAAE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAAE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAAE1IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VAAE1 : bits(64) -> unit

val VAAE1_SysOpsWrite_8498b4db5afbed38 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAAE1_SysOpsWrite_8498b4db5afbed38 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            TLBI_VAAE1IS(val_name);
            return()
        } else {
            TLBI_VAAE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAAE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAAE1(val_name);
            return()
        }
    } else ()
}

val TLBI_VAALE1IS : bits(64) -> unit

val VAALE1IS_SysOpsWrite_5c8056a5b649fe2e : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAALE1IS_SysOpsWrite_5c8056a5b649fe2e (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_TTLBIS : bits(1) = Slice(HCR_EL2, 54, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLBIS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TLBI_VAALE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAALE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAALE1IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VAALE1 : bits(64) -> unit

val VAALE1_SysOpsWrite_d3bec3a19881fb1c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAALE1_SysOpsWrite_d3bec3a19881fb1c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            TLBI_VAALE1IS(val_name);
            return()
        } else {
            TLBI_VAALE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAALE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAALE1(val_name);
            return()
        }
    } else ()
}

val TLBI_VAE1IS : bits(64) -> unit

val VAE1IS_SysOpsWrite_5eac1ac5cb4e76ff : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAE1IS_SysOpsWrite_5eac1ac5cb4e76ff (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_TTLBIS : bits(1) = Slice(HCR_EL2, 54, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLBIS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TLBI_VAE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAE1IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VAE1 : bits(64) -> unit

val VAE1_SysOpsWrite_09dbfc0bf1b19b11 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAE1_SysOpsWrite_09dbfc0bf1b19b11 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            TLBI_VAE1IS(val_name);
            return()
        } else {
            TLBI_VAE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAE1(val_name);
            return()
        }
    } else ()
}

val TLBI_VAE2IS : bits(64) -> unit

val VAE2IS_SysOpsWrite_f81411101129df7b : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAE2IS_SysOpsWrite_f81411101129df7b (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAE2IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAE2IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VAE2 : bits(64) -> unit

val VAE2_SysOpsWrite_78002df18993a4b5 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAE2_SysOpsWrite_78002df18993a4b5 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAE2(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAE2(val_name);
            return()
        }
    } else ()
}

val TLBI_VAE3IS : bits(64) -> unit

val VAE3IS_SysOpsWrite_7dc759c51bb69ced : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAE3IS_SysOpsWrite_7dc759c51bb69ced (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAE3IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VAE3 : bits(64) -> unit

val VAE3_SysOpsWrite_90b5c3b60d3bd152 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VAE3_SysOpsWrite_90b5c3b60d3bd152 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAE3(val_name);
            return()
        }
    } else ()
}

val TLBI_VALE1IS : bits(64) -> unit

val VALE1IS_SysOpsWrite_7bb7ad05a900b833 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VALE1IS_SysOpsWrite_7bb7ad05a900b833 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_TTLBIS : bits(1) = Slice(HCR_EL2, 54, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLBIS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TLBI_VALE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VALE1IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VALE1IS(val_name);
            return()
        }
    } else ()
}

val VALE1_SysOpsWrite_c1766c627b3960ca : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VALE1_SysOpsWrite_c1766c627b3960ca (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            TLBI_VALE1IS(val_name);
            return()
        } else {
            TLBI_VAAE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VAAE1(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VAAE1(val_name);
            return()
        }
    } else ()
}

val TLBI_VALE2IS : bits(64) -> unit

val VALE2IS_SysOpsWrite_a1084cefbce599af : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VALE2IS_SysOpsWrite_a1084cefbce599af (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VALE2IS(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VALE2IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VALE2 : bits(64) -> unit

val VALE2_SysOpsWrite_dce4b2b057d036da : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VALE2_SysOpsWrite_dce4b2b057d036da (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VALE2(val_name);
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if not_bool(EL2Enabled()) then {
            throw(Error_Undefined())
        } else if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VALE2(val_name);
            return()
        }
    } else ()
}

val TLBI_VALE3IS : bits(64) -> unit

val VALE3IS_SysOpsWrite_8b70cb86db2abfcd : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VALE3IS_SysOpsWrite_8b70cb86db2abfcd (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VALE3IS(val_name);
            return()
        }
    } else ()
}

val TLBI_VALE3 : bits(64) -> unit

val VALE3_SysOpsWrite_df1f91b1bea42ec8 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VALE3_SysOpsWrite_df1f91b1bea42ec8 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VALE3(val_name);
            return()
        }
    } else ()
}

val TLBI_VMALLE1IS : unit -> unit

val VMALLE1IS_SysOpsWrite_08cfba716c4ca8db : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VMALLE1IS_SysOpsWrite_08cfba716c4ca8db (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_TTLBIS : bits(1) = Slice(HCR_EL2, 54, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLBIS == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            TLBI_VMALLE1IS();
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VMALLE1IS();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VMALLE1IS();
            return()
        }
    } else ()
}

val TLBI_VMALLE1 : unit -> unit

val VMALLE1_SysOpsWrite_c64f2572b311d9b9 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VMALLE1_SysOpsWrite_c64f2572b311d9b9 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __HCR_EL2_TTLB : bits(1) = Slice(HCR_EL2, 25, 1);
    let __HCR_EL2_FB : bits(1) = Slice(HCR_EL2, 9, 1);
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL1 then {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            } else if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TTLB == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_FB == 0b1 then {
            TLBI_VMALLE1IS();
            return()
        } else {
            TLBI_VMALLE1();
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VMALLE1();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else {
            TLBI_VMALLE1();
            return()
        }
    } else ()
}

val TLBI_VMALLS12E1IS : unit -> unit

val VMALLS12E1IS_SysOpsWrite_92a1ba1461a19d4c : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VMALLS12E1IS_SysOpsWrite_92a1ba1461a19d4c (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VMALLS12E1IS();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if not_bool(EL2Enabled()) then {
            TLBI_VMALLE1IS();
            return()
        } else {
            TLBI_VMALLS12E1IS();
            return()
        }
    } else ()
}

val TLBI_VMALLS12E1 : unit -> unit

val VMALLS12E1_SysOpsWrite_8f5c303094061f20 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function VMALLS12E1_SysOpsWrite_8f5c303094061f20 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    if __PSTATE_EL == EL0 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL1 then {
        throw(Error_Undefined())
    } else if __PSTATE_EL == EL2 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            if TargetELForCapabilityExceptions() == EL2 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL3, UInt(0x18))
            }
        } else {
            TLBI_VMALLS12E1();
            return()
        }
    } else if __PSTATE_EL == EL3 then {
        if (HaveCapabilitiesExt() & not_bool(CapIsSystemAccessEnabled())) & not_bool(Halted()) then {
            AArch64_SystemAccessTrap(EL3, UInt(0x18))
        } else if not_bool(EL2Enabled()) then {
            TLBI_VMALLE1();
            return()
        } else {
            TLBI_VMALLS12E1();
            return()
        }
    } else ()
}

val DC_ZVA : bits(64) -> unit

val ZVA_SysOpsWrite_b40574bff0ba4354 : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function ZVA_SysOpsWrite_b40574bff0ba4354 (el, op0, op1, CRn, op2, CRm, val_name) = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    let __SCTLR_EL1_DZE : bits(1) = Slice(SCTLR_EL1, 14, 1);
    let __HCR_EL2_TGE : bits(1) = Slice(HCR_EL2, 27, 1);
    let __HCR_EL2_TDZ : bits(1) = Slice(HCR_EL2, 28, 1);
    let __SCTLR_EL2_DZE : bits(1) = Slice(SCTLR_EL2, 14, 1);
    if __PSTATE_EL == EL0 then {
        if (not_bool(ELUsingAArch32(EL1)) & not_bool(EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11)) & __SCTLR_EL1_DZE == 0b0 then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TGE == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) != 0b11) & __HCR_EL2_TDZ == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else if ((EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11) & __SCTLR_EL2_DZE == 0b0 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_ZVA(val_name);
            return()
        }
    } else if __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & __HCR_EL2_TDZ == 0b1 then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else {
            DC_ZVA(val_name);
            return()
        }
    } else if __PSTATE_EL == EL2 then {
        DC_ZVA(val_name);
        return()
    } else if __PSTATE_EL == EL3 then {
        DC_ZVA(val_name);
        return()
    } else ()
}

val AArch64_AutoGen_SysOpsWrite : (bits(2), bits(2), bits(3), bits(4), bits(3), bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_SysOpsWrite (el, op0, op1, CRn, op2, CRm, val_name) = {
    if (((CRm == 0b1110 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        CIVAC_SysOpsWrite_47ad60ecb930d217(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1100 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        CVAP_SysOpsWrite_a43f75867888e74a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        ZVA_SysOpsWrite_b40574bff0ba4354(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        IVAU_SysOpsWrite_2dfe97b748dd324e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b001 then {
        IVAC_SysOpsWrite_41b93e0e56e4f107(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1011 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        CVAU_SysOpsWrite_4a72bbc98a17973c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1010 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        CVAC_SysOpsWrite_c7d2e911c691cc6b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1101 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b001 then {
        CVADP_SysOpsWrite_9953ef108c01d34a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b010 then {
        S1E0R_SysOpsWrite_0a1e21ea5b4c8722(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b000 then {
        ALLE2_SysOpsWrite_19c7b5110a5efe1d(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b100) & op2 == 0b000 then {
        S1E2R_SysOpsWrite_5e865a96c06417c8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b001 then {
        IPAS2E1_SysOpsWrite_a65fef0d99f9428f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b000 then {
        ALLE2IS_SysOpsWrite_3a173239947b2c25(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0100 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b101 then {
        IPAS2LE1_SysOpsWrite_10ca7ac6abdfed50(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b001 then {
        VAE1IS_SysOpsWrite_5eac1ac5cb4e76ff(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b001 then {
        VAE2_SysOpsWrite_78002df18993a4b5(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b001 then {
        VAE2IS_SysOpsWrite_f81411101129df7b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b110) & op2 == 0b000 then {
        ALLE3_SysOpsWrite_5835ce2f987f3d36(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b100) & op2 == 0b001 then {
        S1E2W_SysOpsWrite_1649806418453f02(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0101 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b000 then {
        IALLU_SysOpsWrite_81563797a4921929(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b100) & op2 == 0b100 then {
        S12E1R_SysOpsWrite_e44276c8f24d398f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b100) & op2 == 0b101 then {
        S12E1W_SysOpsWrite_c8b72d75cad90601(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b100 then {
        RCTX_SysOpsWrite_bcc8cd10f2e68999(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b111 then {
        VAALE1IS_SysOpsWrite_5c8056a5b649fe2e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b101 then {
        RCTX_SysOpsWrite_d614ec87236c038f(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b100) & op2 == 0b110 then {
        S12E0R_SysOpsWrite_4df3d544cba811b7(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b110) & op2 == 0b001 then {
        VAE3_SysOpsWrite_90b5c3b60d3bd152(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b000 then {
        S1E1RP_SysOpsWrite_4a6b1f71ee0182ab(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b011) & op2 == 0b111 then {
        RCTX_SysOpsWrite_c287513d0d3e8e92(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b110 then {
        VMALLS12E1_SysOpsWrite_8f5c303094061f20(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b000 then {
        S1E1R_SysOpsWrite_018a577644c5d23c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b010 then {
        ASIDE1IS_SysOpsWrite_5a5dff91f113e41e(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b101 then {
        VALE1IS_SysOpsWrite_7bb7ad05a900b833(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b001 then {
        S1E1W_SysOpsWrite_df64f2f63c0911fd(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b100) & op2 == 0b111 then {
        S12E0W_SysOpsWrite_1dbb37d4af097406(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1001 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b001 then {
        S1E1WP_SysOpsWrite_bb1ddb9112effe2a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b110) & op2 == 0b101 then {
        VALE3IS_SysOpsWrite_8b70cb86db2abfcd(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b011 then {
        VAAE1IS_SysOpsWrite_c22cd5a1dc8e7320(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b110) & op2 == 0b001 then {
        S1E3W_SysOpsWrite_e92e083e28fa4dd0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b110 then {
        VMALLS12E1IS_SysOpsWrite_92a1ba1461a19d4c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b110) & op2 == 0b001 then {
        VAE3IS_SysOpsWrite_7dc759c51bb69ced(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b011 then {
        S1E0W_SysOpsWrite_d102d49fd92af65a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b010 then {
        ASIDE1_SysOpsWrite_7ba7a3df395925e0(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b110) & op2 == 0b101 then {
        VALE3_SysOpsWrite_df1f91b1bea42ec8(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b011 then {
        VAAE1_SysOpsWrite_8498b4db5afbed38(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b001 then {
        IPAS2E1IS_SysOpsWrite_ed4be1feae90b987(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b101 then {
        VALE1_SysOpsWrite_c1766c627b3960ca(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b100 then {
        ALLE1IS_SysOpsWrite_8b81b55e2116aad3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0000 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b101 then {
        IPAS2LE1IS_SysOpsWrite_5a72848dfefa19f3(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b101 then {
        VALE2_SysOpsWrite_dce4b2b057d036da(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if ((((match CRm {
      [_, _, _, _] => true,
      _ => false
    }) : bool & (match CRn {
      [bitone, _, bitone, bitone] => true,
      _ => false
    }) : bool) & op0 == 0b01) & (match op1 {
      [_, _, _] => true,
      _ => false
    }) : bool) & (match op2 {
      [_, _, _] => true,
      _ => false
    }) : bool then {
        S1_op1_Cn_Cm_op2_SysOpsWrite_d6b17d94c0df44bc(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b111 then {
        VAALE1_SysOpsWrite_d3bec3a19881fb1c(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b001 then {
        VAE1_SysOpsWrite_09dbfc0bf1b19b11(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b100 then {
        ALLE1_SysOpsWrite_69364bedc72cbe96(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b000 then {
        VMALLE1IS_SysOpsWrite_08cfba716c4ca8db(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b100) & op2 == 0b101 then {
        VALE2IS_SysOpsWrite_a1084cefbce599af(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0111 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b000) & op2 == 0b000 then {
        VMALLE1_SysOpsWrite_c64f2572b311d9b9(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0001 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b000 then {
        IALLUIS_SysOpsWrite_9a906c8365100aff(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1000 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b110) & op2 == 0b000 then {
        S1E3R_SysOpsWrite_6476f20e79e358be(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0011 & CRn == 0b1000) & op0 == 0b01) & op1 == 0b110) & op2 == 0b000 then {
        ALLE3IS_SysOpsWrite_e64b79b4c41910fb(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1110 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b010 then {
        CISW_SysOpsWrite_5321b1c3157dccce(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b0110 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b010 then {
        ISW_SysOpsWrite_d5fceb001aa0aa7a(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    if (((CRm == 0b1010 & CRn == 0b0111) & op0 == 0b01) & op1 == 0b000) & op2 == 0b010 then {
        CSW_SysOpsWrite_9544819da3ebaa1b(el, op0, op1, CRn, op2, CRm, val_name);
        return()
    } else ();
    throw(Error_Undefined())
}

val AArch64_SysInstr : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SysInstr (op0, op1, crn, crm, op2, val_name) = {
    AArch64_AutoGen_SysOpsWrite(PSTATE.EL, op0[1 .. 0], op1[2 .. 0], crn[3 .. 0], op2[2 .. 0], crm[3 .. 0], val_name)
}

val UndefinedFault : unit -> unit

val AArch64_SysInstrWithResult : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bits(64) effect {escape}

function AArch64_SysInstrWithResult (op0, op1, crn, crm, op2) = {
    if (Slice(op0, 0, 2) == 0b01 | Slice(op0, 0, 2) == 0b11) & (Slice(crn, 0, 4) == 0b1011 | Slice(crn, 0, 4) == 0b1111) then {
        throw(Error_ImplementationDefined(""))
    } else {
        UndefinedFault()
    };
    return(__UNKNOWN_bits(64))
}

enum AccType = {
  AccType_NORMAL,
  AccType_VEC,
  AccType_STREAM,
  AccType_VECSTREAM,
  AccType_ATOMIC,
  AccType_ATOMICRW,
  AccType_ORDERED,
  AccType_ORDEREDRW,
  AccType_ORDEREDATOMIC,
  AccType_ORDEREDATOMICRW,
  AccType_LIMITEDORDERED,
  AccType_UNPRIV,
  AccType_IFETCH,
  AccType_PTW,
  AccType_DC,
  AccType_DC_UNPRIV,
  AccType_IC,
  AccType_DCZVA,
  AccType_AT
}

enum MemType = {MemType_Normal, MemType_Device}

enum DeviceType = {
  DeviceType_GRE,
  DeviceType_nGRE,
  DeviceType_nGnRE,
  DeviceType_nGnRnE
}

val __UNKNOWN_DeviceType : unit -> DeviceType effect {undef}

function __UNKNOWN_DeviceType () = undefined

struct MemAttrHints = {attrs : bits(2), hints : bits(2), transient : bool}

val __UNKNOWN_MemAttrHints : unit -> MemAttrHints effect {undef}

function __UNKNOWN_MemAttrHints () = undefined

let MemAttr_NC : bits(2) = 0b00

let MemAttr_WT : bits(2) = 0b10

let MemAttr_WB : bits(2) = 0b11

let MemHint_No : bits(2) = 0b00

let MemHint_RA : bits(2) = 0b10

let MemHint_RWA : bits(2) = 0b11

struct MemoryAttributes = {
  memtype : MemType,
  device : DeviceType,
  inner : MemAttrHints,
  outer : MemAttrHints,
  readtagzero : bool,
  readtagfault : bool,
  readtagfaulttgen : bits(1),
  writetagfault : bool,
  iss2writetagfault : bool,
  shareable : bool,
  outershareable : bool
}

val __UNKNOWN_MemoryAttributes : unit -> MemoryAttributes effect {undef}

function __UNKNOWN_MemoryAttributes () = undefined

struct FullAddress = {address : bits(48), NS : bits(1)}

enum Fault = {
  Fault_None,
  Fault_AccessFlag,
  Fault_Alignment,
  Fault_Background,
  Fault_Domain,
  Fault_Permission,
  Fault_Translation,
  Fault_AddressSize,
  Fault_SyncExternal,
  Fault_SyncExternalOnWalk,
  Fault_SyncParity,
  Fault_SyncParityOnWalk,
  Fault_AsyncParity,
  Fault_AsyncExternal,
  Fault_Debug,
  Fault_TLBConflict,
  Fault_HWUpdateAccessFlag,
  Fault_CapTag,
  Fault_CapSeal,
  Fault_CapBounds,
  Fault_CapPerm,
  Fault_CapPagePerm,
  Fault_Lockdown,
  Fault_Exclusive,
  Fault_ICacheMaint
}

struct FaultRecord = {
  statuscode : Fault,
  acctype : AccType,
  ipaddress : bits(48),
  s2fs1walk : bool,
  write : bool,
  level : int,
  extflag : bits(1),
  secondstage : bool,
  domain : bits(4),
  errortype : bits(2),
  debugmoe : bits(4)
}

struct MPAMinfo = {mpam_ns : bits(1), partid : bits(16), pmg : bits(8)}

struct AddressDescriptor = {
  fault : FaultRecord,
  memattrs : MemoryAttributes,
  paddress : FullAddress,
  vaddress : bits(64)
}

struct AccessDescriptor = {
  acctype : AccType,
  mpam : MPAMinfo,
  page_table_walk : bool,
  secondstage : bool,
  s2fs1walk : bool,
  level : int
}

struct Permissions = {ap : bits(3), xn : bits(1), xxn : bits(1), pxn : bits(1)}

struct DescriptorUpdate = {
  AF : bool,
  AP : bool,
  SC : bool,
  descaddr : AddressDescriptor
}

struct TLBRecord = {
  perms : Permissions,
  nG : bits(1),
  domain : bits(4),
  contiguous : bool,
  level : int,
  blocksize : int,
  descupdate : DescriptorUpdate,
  CnP : bits(1),
  addrdesc : AddressDescriptor
}

enum MBReqDomain = {
  MBReqDomain_Nonshareable,
  MBReqDomain_InnerShareable,
  MBReqDomain_OuterShareable,
  MBReqDomain_FullSystem
}

enum MBReqTypes = {MBReqTypes_Reads, MBReqTypes_Writes, MBReqTypes_All}

enum PrefetchHint = {Prefetch_READ, Prefetch_WRITE, Prefetch_EXEC}

register EventRegister : bits(1)

enum FPExc = {
  FPExc_InvalidOp,
  FPExc_DivideByZero,
  FPExc_Overflow,
  FPExc_Underflow,
  FPExc_Inexact,
  FPExc_InputDenorm
}

enum FPRounding = {
  FPRounding_TIEEVEN,
  FPRounding_POSINF,
  FPRounding_NEGINF,
  FPRounding_ZERO,
  FPRounding_TIEAWAY,
  FPRounding_ODD
}

enum FPType = {
  FPType_Nonzero,
  FPType_Zero,
  FPType_Infinity,
  FPType_QNaN,
  FPType_SNaN
}

register _V : vector(32, inc, bits(128))

let DefaultPARTID : bits(16) = 0[15 .. 0]

let DefaultPMG : bits(8) = 0[7 .. 0]

struct TLBContext = {
  twostage : bool,
  secondstage : bool,
  asid : bits(16),
  vmid : bits(16),
  el : bits(2),
  secure : bool,
  t_sz : bits(6),
  granule_size : int
}

struct TLBLine = {
  address : bits(64),
  context : TLBContext,
  data : TLBRecord,
  valid_name : bool
}

val __UNKNOWN_TLBLine : unit -> TLBLine effect {undef}

function __UNKNOWN_TLBLine () = undefined

enum VirtualAddressType = {VA_Bits64, VA_Capability}

val __UNKNOWN_VirtualAddressType : unit -> VirtualAddressType effect {undef}

function __UNKNOWN_VirtualAddressType () = undefined

struct VirtualAddress = {
  vatype : VirtualAddressType,
  base : bits(129),
  offset : bits(64)
}

val __UNKNOWN_VirtualAddress : unit -> VirtualAddress effect {undef}

function __UNKNOWN_VirtualAddress () = undefined

let CAPABILITY_DBYTES : int(16) = 16

type CAPABILITY_DBYTES : Int = 16

let LOG2_CAPABILITY_DBYTES : int(4) = 4

enum CountOp = {CountOp_CLZ, CountOp_CLS, CountOp_CNT}

enum ExtendType = {
  ExtendType_SXTB,
  ExtendType_SXTH,
  ExtendType_SXTW,
  ExtendType_SXTX,
  ExtendType_UXTB,
  ExtendType_UXTH,
  ExtendType_UXTW,
  ExtendType_UXTX
}

enum FPMaxMinOp = {
  FPMaxMinOp_MAX,
  FPMaxMinOp_MIN,
  FPMaxMinOp_MAXNUM,
  FPMaxMinOp_MINNUM
}

enum FPUnaryOp = {FPUnaryOp_ABS, FPUnaryOp_MOV, FPUnaryOp_NEG, FPUnaryOp_SQRT}

enum FPConvOp = {
  FPConvOp_CVT_FtoI,
  FPConvOp_CVT_ItoF,
  FPConvOp_MOV_FtoI,
  FPConvOp_MOV_ItoF
}

enum MoveWideOp = {MoveWideOp_N, MoveWideOp_Z, MoveWideOp_K}

enum ShiftType = {ShiftType_LSL, ShiftType_LSR, ShiftType_ASR, ShiftType_ROR}

enum LogicalOp = {LogicalOp_AND, LogicalOp_EOR, LogicalOp_ORR}

enum MemOp = {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}

enum MemAtomicOp = {
  MemAtomicOp_ADD,
  MemAtomicOp_BIC,
  MemAtomicOp_EOR,
  MemAtomicOp_ORR,
  MemAtomicOp_SMAX,
  MemAtomicOp_SMIN,
  MemAtomicOp_UMAX,
  MemAtomicOp_UMIN,
  MemAtomicOp_SWP
}

enum SystemHintOp = {
  SystemHintOp_NOP,
  SystemHintOp_YIELD,
  SystemHintOp_WFE,
  SystemHintOp_WFI,
  SystemHintOp_SEV,
  SystemHintOp_SEVL,
  SystemHintOp_ESB,
  SystemHintOp_PSB,
  SystemHintOp_CSDB
}

enum PSTATEField = {
  PSTATEField_DAIFSet,
  PSTATEField_DAIFClr,
  PSTATEField_PAN,
  PSTATEField_UAO,
  PSTATEField_SSBS,
  PSTATEField_SP
}

enum VBitOp = {VBitOp_VBIF, VBitOp_VBIT, VBitOp_VBSL, VBitOp_VEOR}

enum CompareOp = {
  CompareOp_GT,
  CompareOp_GE,
  CompareOp_EQ,
  CompareOp_LE,
  CompareOp_LT
}

enum ImmediateOp = {
  ImmediateOp_MOVI,
  ImmediateOp_MVNI,
  ImmediateOp_ORR,
  ImmediateOp_BIC
}

enum ReduceOp = {
  ReduceOp_FMINNUM,
  ReduceOp_FMAXNUM,
  ReduceOp_FMIN,
  ReduceOp_FMAX,
  ReduceOp_FADD,
  ReduceOp_ADD
}

let DebugHalt_Breakpoint : bits(6) = 0b000111

let DebugHalt_Watchpoint : bits(6) = 0b101011

let DebugHalt_HaltInstruction : bits(6) = 0b101111

let CAP_NO_SEALING : bits(64) = Ones(64)

let CAP_SEAL_TYPE_RB : bits(64) = ZeroExtend(0b01, 64)

let CAP_SEAL_TYPE_LPB : bits(64) = ZeroExtend(0b10, 64)

let CAP_SEAL_TYPE_LB : bits(64) = ZeroExtend(0b11, 64)

let CAP_MAX_FIXED_SEAL_TYPE : int(3) = 3

let CAP_PERM_LOAD : bits(64) = ((1 << 17))[63 .. 0]

let CAP_PERM_STORE : bits(64) = ((1 << 16))[63 .. 0]

let CAP_PERM_LOAD_CAP : bits(64) = ((1 << 14))[63 .. 0]

let CAP_PERM_STORE_CAP : bits(64) = ((1 << 13))[63 .. 0]

let CAP_PERM_STORE_LOCAL : bits(64) = ((1 << 12))[63 .. 0]

let CAP_PERM_SEAL : bits(64) = ((1 << 11))[63 .. 0]

let CAP_PERM_UNSEAL : bits(64) = ((1 << 10))[63 .. 0]

let CAP_PERM_BRANCH_SEALED_PAIR : bits(64) = ((1 << 8))[63 .. 0]

let CAP_PERM_MUTABLE_LOAD : bits(64) = ((1 << 6))[63 .. 0]

let CAP_PERM_GLOBAL : bits(64) = 1[63 .. 0]

let CAP_PERM_NONE : bits(64) = 0[63 .. 0]

let CAP_OTYPE_NUM_BITS : int(CAP_OTYPE_HI_BIT - CAP_OTYPE_LO_BIT + 1) = CAP_OTYPE_HI_BIT - CAP_OTYPE_LO_BIT + 1

let CAP_LENGTH_NUM_BITS : int(CAP_VALUE_NUM_BITS + 1) = CAP_VALUE_NUM_BITS + 1

type CAP_LENGTH_NUM_BITS : Int = CAP_VALUE_NUM_BITS + 1

let CAP_MAX_OBJECT_TYPE : int = (1 << CAP_OTYPE_NUM_BITS) - 1

register __saved_exception_level : bits(2)

register __CNTControlBase : bits(48)

enum __InstrEnc = {__A64, __A32, __T16, __T32}

register __ThisInstr : bits(32)

register __ThisInstrEnc : __InstrEnc

union instr_ast = {
  Instr_BLRR_C_C : (bits(2), bits(5)),
  Instr_BLRS_C_C : (bits(2), bits(5)),
  Instr_BLRS_C_C_C : (bits(5), bits(2), bits(5)),
  Instr_BLR_C_C : (bits(2), bits(5)),
  Instr_BRR_C_C : (bits(2), bits(5)),
  Instr_BRS_C_C_C : (bits(5), bits(2), bits(5)),
  Instr_BRS_C_C : (bits(2), bits(5)),
  Instr_BR_C_C : (bits(2), bits(5)),
  Instr_RETR_C_C : (bits(2), bits(5)),
  Instr_RETS_C_C : (bits(2), bits(5)),
  Instr_RETS_C_C_C : (bits(5), bits(2), bits(5)),
  Instr_RET_C_C : (bits(2), bits(5)),
  Instr_BLR_CI_C : (bits(7), bits(5)),
  Instr_BR_CI_C : (bits(7), bits(5)),
  Instr_LDPBLR_C_C_C : (bits(2), bits(5), bits(5)),
  Instr_LDPBR_C_C_C : (bits(2), bits(5), bits(5)),
  Instr_ALDAR_C_R_C : (bits(1), bits(5), bits(5)),
  Instr_ALDR_C_RUI_C : (bits(1), bits(9), bits(2), bits(5), bits(5)),
  Instr_ALDR_C_RRB_C : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(5), bits(5)),
  Instr_ALDUR_C_RI_C : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)),
  Instr_CASAL_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)),
  Instr_CASA_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)),
  Instr_CASL_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)),
  Instr_CAS_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)),
  Instr_LDAPR_C_R_C : (bits(5), bits(5)),
  Instr_LDAR_C_R_C : (bits(1), bits(5), bits(5)),
  Instr_LDAXP_C_R_C : (bits(1), bits(5), bits(5), bits(5)),
  Instr_LDAXR_C_R_C : (bits(1), bits(5), bits(5)),
  Instr_LDNP_C_RIB_C : (bits(1), bits(7), bits(5), bits(5), bits(5)),
  Instr_LDP_CC_RIAW_C : (bits(1), bits(7), bits(5), bits(5), bits(5)),
  Instr_LDP_C_RIBW_C : (bits(1), bits(7), bits(5), bits(5), bits(5)),
  Instr_LDP_C_RIB_C : (bits(1), bits(7), bits(5), bits(5), bits(5)),
  Instr_LDR_C_I_C : (bits(17), bits(5)),
  Instr_LDR_C_RIAW_C : (bits(2), bits(9), bits(5), bits(5)),
  Instr_LDR_C_RIBW_C : (bits(2), bits(9), bits(5), bits(5)),
  Instr_LDR_C_RUIB_C : (bits(1), bits(12), bits(5), bits(5)),
  Instr_LDR_C_RRB_C : (bits(2), bits(5), bits(1), bits(1), bits(1), bits(5), bits(5)),
  Instr_LDTR_C_RIB_C : (bits(2), bits(9), bits(5), bits(5)),
  Instr_LDUR_C_RI_C : (bits(2), bits(9), bits(5), bits(5)),
  Instr_LDXP_C_R_C : (bits(1), bits(5), bits(5), bits(5)),
  Instr_LDXR_C_R_C : (bits(1), bits(5), bits(5)),
  Instr_SWPAL_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)),
  Instr_SWPA_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)),
  Instr_SWPL_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)),
  Instr_SWP_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)),
  Instr_LDCT_R_R__ : (bits(2), bits(5), bits(5)),
  Instr_Other : bits(32)
}

register __ThisInstrAbstract : instr_ast

val __SetThisInstr : bits(32) -> unit effect {wreg}

function __SetThisInstr opcode = {
    __ThisInstr = opcode;
    __ThisInstrAbstract = Instr_Other(opcode);
    return()
}

register __highest_el_aarch32 : bool

let __exclusive_granule_size : bits(4) = 0b0100

let CFG_ID_AA64PFR0_EL1_MPAM : bits(4) = 0b0001

val ClearPendingPhysicalSError : unit -> unit

val IsZeroBit : forall ('N : Int), 'N >= 0. bits('N) -> bits(1)

function IsZeroBit x = {
    return(if IsZero(x) then 0b1 else 0b0)
}

overload LSL = {sail_shiftleft}

overload LSR = {sail_shiftright}

overload ASR = {sail_arith_shiftright}

val ROR : forall ('N 'shift : Int), ('N > 0 & 'shift >= 0).
  (bits('N), int('shift)) -> bits('N)

function ROR (x, shift) = {
    if shift == 0 then x else let 'm = MOD(shift, 'N) in
      LSR(x, m) | LSL(x, 'N - m)
}

val Extend : forall 'M 'N ('is_unsigned : Bool),
  ('M >= 0 & 'N >= 'M | not('is_unsigned)) & ('M > 0 & 'N >= 'M | not(not('is_unsigned))).
  (bits('M), int('N), bool('is_unsigned)) -> bits('N)

function Extend (x, N, is_unsigned) = {
    return(if is_unsigned then ZeroExtend(x, N) else SignExtend(x, N))
}

val asl_Int : forall 'N ('is_unsigned : Bool),
  ('N > 0 | not(not('is_unsigned))).
  (bits('N), bool('is_unsigned)) -> int

function asl_Int (x, is_unsigned) = {
    let 'result = if is_unsigned then UInt(x) else SInt(x);
    return(result)
}

val LowestSetBit : forall ('N : Int). bits('N) -> int

function LowestSetBit x = {
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        if [x[i]] == 0b1 then {
            return(i)
        } else ()
    };
    return('N)
}

val HighestSetBit : forall ('N : Int). bits('N) -> int

function HighestSetBit x = {
    foreach (i from ('N - 1) to 0 by 1 in dec) {
        if [x[i]] == 0b1 then {
            return(i)
        } else ()
    };
    return(negate(1))
}

val BitCount : forall ('N : Int). bits('N) -> int

function BitCount x = {
    result : int = 0;
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        if [x[i]] == 0b1 then {
            result = result + 1
        } else ()
    };
    let 'result = result;
    return(result)
}

overload CountLeadingZeroBits = {count_leading_zeros}

val CountLeadingSignBits : forall ('N : Int), 'N > 1. bits('N) -> int

function CountLeadingSignBits x = {
    let x1 = sail_shiftright(x, 1);
    let x2 = [x with ('N - 1) = bitzero];
    CountLeadingZeroBits(EOR(x1, x2)) - 1
}

val Align__1 : forall ('x 'y : Int). (int('x), int('y)) -> int

val Align : forall ('N 'y : Int), 'N > 0. (bits('N), int('y)) -> bits('N)

function Align__1 (x, y) = {
    return(y * DIV(x, y))
}

function Align (x, y) = {
    return(Align__1(UInt(x), y)['N - 1 .. 0])
}

val Elem_read : forall 'N 'e 'size,
  (0 <= 'e * 'size & 'e * 'size <= 'e * 'size + 'size - 1 | not(('e >= 0 & ('e + 1) * 'size <= 'N))).
  (bits('N), int('e), int('size)) -> bits('size) effect {escape}

function Elem_read (vector_name, e, size) = {
    assert(e >= 0 & (e + 1) * size <= 'N);
    return(vector_name[e * size + size - 1 .. e * size])
}

val Elem_set : forall 'N 'e 'size,
  (0 <= 'e * 'size & 'e * 'size <= ('e + 1) * 'size - 1 | not(('e >= 0 & ('e + 1) * 'size <= 'N))).
  (bits('N), int('e), int('size), bits('size)) -> bits('N) effect {escape}

function Elem_set (vector_name__arg, e, size, value_name) = {
    vector_name : bits('N) = vector_name__arg;
    assert(e >= 0 & (e + 1) * size <= 'N);
    vector_name[(e + 1) * size - 1 .. e * size] = value_name;
    return(vector_name)
}

val DataSynchronizationBarrier : (MBReqDomain, MBReqTypes) -> unit

val DataMemoryBarrier : (MBReqDomain, MBReqTypes) -> unit

val SpeculativeStoreBypassBarrierToVA : unit -> unit

val SpeculativeStoreBypassBarrierToPA : unit -> unit

val Hint_Prefetch : forall ('stream : Bool)('target : Int).
  (bits(64), PrefetchHint, int('target), bool('stream)) -> unit

val BigEndian : unit -> bool effect {escape, rreg, undef}

function BigEndian () = {
    bigend : bool = undefined;
    if UsingAArch32() then {
        bigend = PSTATE.E != 0b0
    } else if PSTATE.EL == EL0 then {
        bigend = [SCTLR_read__1()[24]] != 0b0
    } else {
        bigend = [SCTLR_read__1()[25]] != 0b0
    };
    return(bigend)
}

val EffectiveTGEN : (bits(64), bits(2)) -> bits(1) effect {escape, rreg, undef}

function EffectiveTGEN (address, el) = {
    tgen : bits(1) = undefined;
    assert(HaveEL(el));
    let regime : bits(2) = S1TranslationRegime(el);
    assert(not_bool(ELUsingAArch32(regime)));
    match regime {
      ? if ? == EL1 => {
          tgen = if [address[55]] == 0b1 then Slice(CCTLR_EL1, 1, 1) else Slice(CCTLR_EL1, 0, 1)
      },
      ? if ? == EL2 => {
          if HaveVirtHostExt() & ELIsInHost(el) then {
              tgen = if [address[55]] == 0b1 then Slice(CCTLR_EL2, 1, 1) else Slice(CCTLR_EL2, 0, 1)
          } else {
              tgen = Slice(CCTLR_EL2, 0, 1)
          }
      },
      ? if ? == EL3 => {
          tgen = Slice(CCTLR_EL3, 0, 1)
      },
      _ => ()
    };
    return(tgen)
}

val _Mem_read : forall ('size : Int), 'size > 0.
  (AddressDescriptor, int('size), AccessDescriptor) -> bits(8 * 'size)

val _Mem_set : forall ('size : Int), 'size > 0.
  (AddressDescriptor, int('size), AccessDescriptor, bits(8 * 'size)) -> unit

overload BigEndianReverse = {reverse_endianness}

val DefaultMPAMinfo : forall ('secure : Bool).
  bool('secure) -> MPAMinfo effect {undef}

function DefaultMPAMinfo secure = {
    DefaultInfo : MPAMinfo = undefined;
    DefaultInfo.mpam_ns = if secure then 0b0 else 0b1;
    DefaultInfo.partid = DefaultPARTID;
    DefaultInfo.pmg = DefaultPMG;
    return(DefaultInfo)
}

val HaveMPAMExt : unit -> bool

function HaveMPAMExt () = {
    return(HasArchVersion(ARMv8p2) & __IMPDEF_boolean("Has MPAM extension"))
}

val MPAMisEnabled : unit -> bool effect {rreg, undef}

function MPAMisEnabled () = {
    let el : bits(2) = HighestEL();
    match el {
      ? if ? == EL3 => {
          return(Slice(MPAM3_EL3, 63, 1) == 0b1)
      },
      ? if ? == EL2 => {
          return(Slice(MPAM2_EL2_read(), 63, 1) == 0b1)
      },
      ? if ? == EL1 => {
          return(Slice(MPAM1_EL1_read(), 63, 1) == 0b1)
      },
      _ => {
          return(undefined : bool)
      }
    }
}

val mapvpmw : forall ('vpartid : Int).
  int('vpartid) -> bits(16) effect {rreg, undef}

function mapvpmw vpartid = {
    vpmw : bits(64) = undefined;
    let 'wd = DIV(vpartid, 4);
    match wd {
      0 => {
          vpmw = MPAMVPM0_EL2
      },
      1 => {
          vpmw = MPAMVPM1_EL2
      },
      2 => {
          vpmw = MPAMVPM2_EL2
      },
      3 => {
          vpmw = MPAMVPM3_EL2
      },
      4 => {
          vpmw = MPAMVPM4_EL2
      },
      5 => {
          vpmw = MPAMVPM5_EL2
      },
      6 => {
          vpmw = MPAMVPM6_EL2
      },
      7 => {
          vpmw = MPAMVPM7_EL2
      },
      _ => {
          vpmw = Zeros(64)
      }
    };
    let vpmw = vpmw;
    let 'vpme_lsb = REM(vpartid, 4) * 16;
    return(Slice(vpmw, vpme_lsb, 16))
}

val MAP_vPARTID : bits(16) -> (bits(16), bool) effect {escape, rreg, undef}

function MAP_vPARTID vpartid = {
    ret : bits(16) = undefined;
    err : bool = undefined;
    virt : int = UInt(vpartid);
    let 'vpmrmax = UInt(Slice(MPAMIDR_EL1, 18, 3));
    let 'vpartid_max = 4 * vpmrmax + 3;
    if virt > vpartid_max then {
        virt = MOD(virt, vpartid_max + 1)
    } else ();
    let 'virt = virt;
    assert(constraint((0 <= 'virt & 'virt < 32)));
    if [MPAMVPMV_EL2[virt]] == 0b1 then {
        ret = mapvpmw(virt);
        err = false
    } else if [MPAMVPMV_EL2[0]] == 0b1 then {
        ret = Slice(MPAMVPM0_EL2, 0, 16);
        err = false
    } else {
        ret = DefaultPARTID;
        err = true
    };
    let 'partid_max = UInt(Slice(MPAMIDR_EL1, 0, 16));
    if UInt(ret) > partid_max then {
        ret = DefaultPARTID;
        err = true
    } else ();
    let err = err;
    let ret = ret;
    return((ret, err))
}

val MPAMisVirtual : forall ('el : Int). int('el) -> bool effect {rreg}

function MPAMisVirtual el = {
    return(((Slice(MPAMIDR_EL1, 17, 1) == 0b1 & EL2Enabled()) & (Slice(HCR_EL2, 34, 1) == 0b0 | Slice(HCR_EL2, 27, 1) == 0b0)) & (el == 0 & Slice(MPAMHCR_EL2, 0, 1) == 0b1 | el == 1 & Slice(MPAMHCR_EL2, 1, 1) == 0b1))
}

val getMPAM_PARTID : forall ('InD : Bool)('MPAMn : Int).
  (int('MPAMn), bool('InD)) -> bits(16) effect {rreg, undef}

function getMPAM_PARTID (MPAMn, InD) = {
    partid : bits(16) = undefined;
    let el2avail : bool = EL2Enabled();
    if InD then {
        match MPAMn {
          3 => {
              partid = Slice(MPAM3_EL3, 0, 16)
          },
          2 => {
              partid = if el2avail then Slice(MPAM2_EL2_read(), 0, 16) else Zeros()
          },
          1 => {
              partid = Slice(MPAM1_EL1_read(), 0, 16)
          },
          0 => {
              partid = Slice(MPAM0_EL1, 0, 16)
          },
          _ => {
              partid = __UNKNOWN_bits(16)
          }
        }
    } else {
        match MPAMn {
          3 => {
              partid = Slice(MPAM3_EL3, 16, 16)
          },
          2 => {
              partid = if el2avail then Slice(MPAM2_EL2_read(), 16, 16) else Zeros()
          },
          1 => {
              partid = Slice(MPAM1_EL1_read(), 16, 16)
          },
          0 => {
              partid = Slice(MPAM0_EL1, 16, 16)
          },
          _ => {
              partid = __UNKNOWN_bits(16)
          }
        }
    };
    return(partid)
}

val genPARTID : forall ('InD : Bool)('el : Int).
  (int('el), bool('InD)) -> (bits(16), bool) effect {escape, rreg, undef}

function genPARTID (el, InD) = {
    let partidel : bits(16) = getMPAM_PARTID(el, InD);
    let 'partid_max = UInt(Slice(MPAMIDR_EL1, 0, 16));
    if UInt(partidel) > partid_max then {
        return((DefaultPARTID, true))
    } else ();
    if MPAMisVirtual(el) then {
        return(MAP_vPARTID(partidel))
    } else {
        return((partidel, false))
    }
}

val getMPAM_PMG : forall ('InD : Bool)('MPAMn : Int).
  (int('MPAMn), bool('InD)) -> bits(8) effect {rreg, undef}

function getMPAM_PMG (MPAMn, InD) = {
    pmg : bits(8) = undefined;
    let el2avail : bool = EL2Enabled();
    if InD then {
        match MPAMn {
          3 => {
              pmg = Slice(MPAM3_EL3, 32, 8)
          },
          2 => {
              pmg = if el2avail then Slice(MPAM2_EL2_read(), 32, 8) else Zeros()
          },
          1 => {
              pmg = Slice(MPAM1_EL1_read(), 32, 8)
          },
          0 => {
              pmg = Slice(MPAM0_EL1, 32, 8)
          },
          _ => {
              pmg = __UNKNOWN_bits(8)
          }
        }
    } else {
        match MPAMn {
          3 => {
              pmg = Slice(MPAM3_EL3, 40, 8)
          },
          2 => {
              pmg = if el2avail then Slice(MPAM2_EL2_read(), 40, 8) else Zeros()
          },
          1 => {
              pmg = Slice(MPAM1_EL1_read(), 40, 8)
          },
          0 => {
              pmg = Slice(MPAM0_EL1, 40, 8)
          },
          _ => {
              pmg = __UNKNOWN_bits(8)
          }
        }
    };
    return(pmg)
}

val genPMG : forall ('InD : Bool)('el : Int)('partid_err : Bool).
  (int('el), bool('InD), bool('partid_err)) -> bits(8) effect {rreg, undef}

function genPMG (el, InD, partid_err) = {
    let 'pmg_max = UInt(Slice(MPAMIDR_EL1, 32, 8));
    if partid_err then {
        return(DefaultPMG)
    } else ();
    let groupel : bits(8) = getMPAM_PMG(el, InD);
    if UInt(groupel) <= pmg_max then {
        return(groupel)
    } else ();
    return(DefaultPMG)
}

val genMPAM : forall ('InD : Bool)('el : Int)('secure : Bool).
  (int('el), bool('InD), bool('secure)) -> MPAMinfo effect {escape, rreg, undef}

function genMPAM (el, InD, secure) = {
    returnInfo : MPAMinfo = undefined;
    partidel : bits(16) = undefined;
    perr : bool = undefined;
    let gstplk : bool = ((el == 0 & EL2Enabled()) & Slice(MPAMHCR_EL2, 8, 1) == 0b1) & Slice(HCR_EL2, 27, 1) == 0b0;
    let 'eff_el = if gstplk then 1 else el;
    (partidel, perr) = genPARTID(eff_el, InD);
    let groupel : bits(8) = genPMG(eff_el, InD, perr);
    returnInfo.mpam_ns = if secure then 0b0 else 0b1;
    returnInfo.partid = partidel;
    returnInfo.pmg = groupel;
    return(returnInfo)
}

val GenMPAMcurEL : forall ('InD : Bool).
  bool('InD) -> MPAMinfo effect {escape, rreg, undef}

function GenMPAMcurEL InD = {
    mpamel : bits(2) = undefined;
    validEL_name : bool = undefined;
    let securempam : bool = IsSecure();
    if HaveMPAMExt() & MPAMisEnabled() then {
        let mpamel : bits(2) = PSTATE.EL;
        return(genMPAM(UInt(mpamel), InD, securempam))
    } else ();
    return(DefaultMPAMinfo(securempam))
}

val CreateAccessDescriptor : AccType -> AccessDescriptor effect {escape, rreg, undef}

function CreateAccessDescriptor acctype = {
    accdesc : AccessDescriptor = undefined;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype == AccType_IFETCH | acctype == AccType_IC);
    accdesc.page_table_walk = false;
    return(accdesc)
}

val CreateAccessDescriptorPTW : forall 'level ('s2fs1walk : Bool) ('secondstage : Bool).
  (AccType, bool('secondstage), bool('s2fs1walk), int('level)) -> AccessDescriptor effect {escape, rreg, undef}

function CreateAccessDescriptorPTW (acctype, secondstage, s2fs1walk, level) = {
    accdesc : AccessDescriptor = undefined;
    accdesc.acctype = acctype;
    accdesc.mpam = GenMPAMcurEL(acctype == AccType_IFETCH | acctype == AccType_IC);
    accdesc.page_table_walk = true;
    accdesc.s2fs1walk = s2fs1walk;
    accdesc.secondstage = secondstage;
    accdesc.level = level;
    return(accdesc)
}

val ProcessorID : unit -> int

val IsExclusiveLocal : forall ('processorid 'size : Int).
  (FullAddress, int('processorid), int('size)) -> bool

val IsExclusiveGlobal : forall ('processorid 'size : Int).
  (FullAddress, int('processorid), int('size)) -> bool

val MarkExclusiveLocal : forall ('processorid 'size : Int).
  (FullAddress, int('processorid), int('size)) -> unit

val MarkExclusiveGlobal : forall ('processorid 'size : Int).
  (FullAddress, int('processorid), int('size)) -> unit

val ClearExclusiveLocal : forall ('processorid : Int). int('processorid) -> unit

val ClearExclusiveByAddress : forall ('processorid 'size : Int).
  (FullAddress, int('processorid), int('size)) -> unit

val ExclusiveMonitorsStatus : unit -> bits(1)

val HaveFP16Ext : unit -> bool

val ELFromSPSR : bits(32) -> (bool, bits(2)) effect {rreg, undef}

function ELFromSPSR spsr = {
    el : bits(2) = undefined;
    valid_name : bool = undefined;
    if [spsr[4]] == 0b0 then {
        el = spsr[3 .. 2];
        if HighestELUsingAArch32() then {
            valid_name = false
        } else if not_bool(HaveEL(el)) then {
            valid_name = false
        } else if [spsr[1]] == 0b1 then {
            valid_name = false
        } else if el == EL0 & [spsr[0]] == 0b1 then {
            valid_name = false
        } else if (el == EL2 & HaveEL(EL3)) & Slice(SCR_EL3, 0, 1) == 0b0 then {
            valid_name = false
        } else {
            valid_name = true
        }
    } else {
        valid_name = false
    };
    if not_bool(valid_name) then {
        el = __UNKNOWN_bits(2)
    } else ();
    let el = el;
    return((valid_name, el))
}

val ELUsingAArch32K : bits(2) -> (bool, bool) effect {escape, rreg, undef}

function ELUsingAArch32K el = {
    return(ELStateUsingAArch32K(el, IsSecureBelowEL3()))
}

val IllegalExceptionReturn : bits(32) -> bool effect {escape, rreg, undef}

function IllegalExceptionReturn spsr = {
    known : bool = undefined;
    target : bits(2) = undefined;
    target_el_is_aarch32 : bool = undefined;
    valid_name : bool = undefined;
    (valid_name, target) = ELFromSPSR(spsr);
    if not_bool(valid_name) then {
        return(true)
    } else ();
    if UInt(target) > UInt(PSTATE.EL) then {
        return(true)
    } else ();
    let spsr_mode_is_aarch32 : bool = [spsr[4]] == 0b1;
    (known, target_el_is_aarch32) = ELUsingAArch32K(target);
    assert(known | target == EL0 & not_bool(ELUsingAArch32(EL1)));
    if known & spsr_mode_is_aarch32 != target_el_is_aarch32 then {
        return(true)
    } else ();
    if UsingAArch32() & not_bool(spsr_mode_is_aarch32) then {
        return(true)
    } else ();
    if ((HaveEL(EL2) & target == EL1) & not_bool(IsSecureBelowEL3())) & Slice(HCR_EL2, 27, 1) == 0b1 then {
        return(true)
    } else ();
    return(false)
}

val AArch64_GenerateDebugExceptionsFrom : forall ('secure : Bool).
  (bits(2), bool('secure), bits(1)) -> bool effect {escape, rreg, undef}

function AArch64_GenerateDebugExceptionsFrom (from, secure, mask) = {
    if (Slice(OSLSR_EL1, 1, 1) == 0b1 | DoubleLockStatus()) | Halted() then {
        return(false)
    } else ();
    let route_to_el2 : bool = (HaveEL(EL2) & not_bool(secure)) & (Slice(HCR_EL2, 27, 1) == 0b1 | Slice(MDCR_EL2, 8, 1) == 0b1);
    let target : bits(2) = if route_to_el2 then EL2 else EL1;
    enabled : bool = (not_bool(HaveEL(EL3)) | not_bool(secure)) | Slice(MDCR_EL3, 16, 1) == 0b0;
    if from == target then {
        enabled = (enabled & Slice(MDSCR_EL1, 13, 1) == 0b1) & mask == 0b0
    } else {
        enabled = enabled & UInt(target) > UInt(from)
    };
    return(enabled)
}

val AArch64_GenerateDebugExceptions : unit -> bool effect {escape, rreg, undef}

function AArch64_GenerateDebugExceptions () = {
    return(AArch64_GenerateDebugExceptionsFrom(PSTATE.EL, IsSecure(), PSTATE.D))
}

val DebugTargetFrom : forall ('secure : Bool).
  bool('secure) -> bits(2) effect {rreg, undef}

function DebugTargetFrom secure = {
    route_to_el2 : bool = undefined;
    target : bits(2) = undefined;
    if HaveEL(EL2) & not_bool(secure) then {
        route_to_el2 = Slice(MDCR_EL2, 8, 1) == 0b1 | Slice(HCR_EL2, 27, 1) == 0b1
    } else {
        route_to_el2 = false
    };
    if route_to_el2 then {
        target = EL2
    } else if (HaveEL(EL3) & HighestELUsingAArch32()) & secure then {
        target = EL3
    } else {
        target = EL1
    };
    return(target)
}

val Restarting : unit -> bool effect {rreg}

function Restarting () = {
    return(Slice(EDSCR, 0, 6) == 0b000001)
}

val DebugExceptionReturnSS : bits(32) -> bits(1) effect {escape, rreg, undef}

function DebugExceptionReturnSS spsr = {
    ELd : bits(2) = undefined;
    dest : bits(2) = undefined;
    enabled_at_dest : bool = undefined;
    enabled_at_source : bool = undefined;
    mask : bits(1) = undefined;
    secure : bool = undefined;
    valid_name : bool = undefined;
    assert((Halted() | Restarting()) | PSTATE.EL != EL0);
    SS_bit : bits(1) = 0b0;
    if Slice(MDSCR_EL1, 0, 1) == 0b1 then {
        if Restarting() then {
            enabled_at_source = false
        } else {
            enabled_at_source = AArch64_GenerateDebugExceptions()
        };
        if IllegalExceptionReturn(spsr) then {
            dest = PSTATE.EL
        } else {
            (valid_name, dest) = ELFromSPSR(spsr);
            assert(valid_name)
        };
        let secure : bool = IsSecureBelowEL3() | dest == EL3;
        let mask : bits(1) = [spsr[9]];
        let enabled_at_dest : bool = AArch64_GenerateDebugExceptionsFrom(dest, secure, mask);
        let ELd : bits(2) = DebugTargetFrom(secure);
        if (not_bool(ELUsingAArch32(ELd)) & not_bool(enabled_at_source)) & enabled_at_dest then {
            SS_bit = [spsr[21]]
        } else ()
    } else ();
    return(SS_bit)
}

val SetPSTATEFromPSR : bits(32) -> unit effect {escape, rreg, undef, wreg}

function SetPSTATEFromPSR spsr__arg = {
    spsr : bits(32) = spsr__arg;
    PSTATE.SS = DebugExceptionReturnSS(spsr);
    if IllegalExceptionReturn(spsr) then {
        PSTATE.IL = 0b1;
        if HaveSSBSExt() then {
            PSTATE.SSBS = __UNKNOWN_bits(1)
        } else ();
        if HaveCapabilitiesExt() & not_bool(IsAccessToCapabilitiesEnabledAtEL(PSTATE.EL)) then {
            PSTATE.C64 = 0b0
        } else ()
    } else {
        PSTATE.IL = [spsr[20]];
        PSTATE.nRW = 0b0;
        PSTATE.EL = spsr[3 .. 2];
        PSTATE.SP = [spsr[0]];
        if HaveSSBSExt() then {
            PSTATE.SSBS = [spsr[12]]
        } else ();
        if HaveCapabilitiesExt() then {
            if IsAccessToCapabilitiesEnabledAtEL(PSTATE.EL) then {
                PSTATE.C64 = [spsr[26]]
            } else {
                PSTATE.C64 = 0b0
            }
        } else ()
    };
    if PSTATE.IL == 0b1 & PSTATE.nRW == 0b1 then {
        if ConstrainUnpredictableBool(Unpredictable_ILZEROT) then {
            spsr[5] = Bit(0b0)
        } else ()
    } else ();
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = spsr[31 .. 28];
    if HavePANExt() then {
        PSTATE.PAN = [spsr[22]]
    } else ();
    if HaveUAOExt() then {
        PSTATE.UAO = [spsr[23]]
    } else ();
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = spsr[9 .. 6];
    return()
}

val Hint_Yield : unit -> unit

val SendEvent : unit -> unit

val SendEventLocal : unit -> unit effect {wreg}

function SendEventLocal () = {
    EventRegister = 0b1;
    return()
}

val ClearEventRegister : unit -> unit effect {wreg}

function ClearEventRegister () = {
    EventRegister = 0b0;
    return()
}

val IsEventRegisterSet : unit -> bool effect {rreg}

function IsEventRegisterSet () = {
    return(EventRegister == 0b1)
}

val EnterLowPowerState : unit -> unit

val WaitForEvent : unit -> unit effect {rreg}

function WaitForEvent () = {
    if EventRegister == 0b0 then {
        EnterLowPowerState()
    } else ();
    return()
}

val InterruptPending : unit -> bool

val WaitForInterrupt : unit -> unit

function WaitForInterrupt () = {
    EnterLowPowerState();
    return()
}

val InstructionSynchronizationBarrier : unit -> unit

val SpeculationBarrier : unit -> unit

val ConsumptionOfSpeculativeDataBarrier : unit -> unit

val TakeUnmaskedSErrorInterrupts : unit -> unit

val ConstrainUnpredictableInteger : forall ('high 'low : Int).
  (int('low), int('high), Unpredictable) -> (Constraint, int) effect {undef}

function ConstrainUnpredictableInteger (low, high, which) = {
    let c : Constraint = ConstrainUnpredictable(which);
    if c == Constraint_UNKNOWN then {
        return((c, low))
    } else {
        return((c, __UNKNOWN_integer()))
    }
}

val ConstrainUnpredictableBits : forall ('width : Int), 'width >= 0.
  (implicit('width), Unpredictable) -> (Constraint, bits('width)) effect {undef}

function ConstrainUnpredictableBits (width, which) = {
    let c : Constraint = ConstrainUnpredictable(which);
    if c == Constraint_UNKNOWN then {
        return((c, Zeros(width)))
    } else {
        return((c, __UNKNOWN_bits(width)))
    }
}

val HaveCRCExt : unit -> bool

function HaveCRCExt () = {
    return(HasArchVersion(ARMv8p1) | __IMPDEF_boolean("Have CRC extension"))
}

val BitReverse : forall ('N : Int). bits('N) -> bits('N) effect {undef}

function BitReverse data = {
    result : bits('N) = undefined;
    foreach (i from 0 to ('N - 1) by 1 in inc) {
        result['N - i - 1] = Bit([data[i]])
    };
    return(result)
}

val Poly32Mod2 : forall ('N : Int), 'N > 32. (bits('N), bits(32)) -> bits(32)

function Poly32Mod2 (data__arg, poly) = {
    data : bits('N) = data__arg;
    foreach (i from ('N - 1) to 32 by 1 in dec) {
        if [data[i]] == 0b1 then {
            let data_eor_poly = EOR(data, (ZeroExtend(poly) << (i - 32)));
            data[i - 1 .. 0] = data_eor_poly[i - 1 .. 0]
        } else ()
    };
    return(data[31 .. 0])
}

val HaveAESExt : unit -> bool

function HaveAESExt () = {
    return(__IMPDEF_boolean("Has AES Crypto instructions"))
}

val HaveBit128PMULLExt : unit -> bool

function HaveBit128PMULLExt () = {
    return(__IMPDEF_boolean("Has 128-bit form of PMULL instructions"))
}

val HaveSHA1Ext : unit -> bool

function HaveSHA1Ext () = {
    return(__IMPDEF_boolean("Has SHA1 Crypto instructions"))
}

val HaveSHA256Ext : unit -> bool

function HaveSHA256Ext () = {
    return(__IMPDEF_boolean("Has SHA256 Crypto instructions"))
}

val HaveSHA512Ext : unit -> bool

function HaveSHA512Ext () = {
    if not_bool(HasArchVersion(ARMv8p2)) | not_bool(HaveSHA1Ext() & HaveSHA256Ext()) then {
        return(false)
    } else ();
    return(__IMPDEF_boolean("Has SHA512 Crypto instructions"))
}

val HaveSHA3Ext : unit -> bool

function HaveSHA3Ext () = {
    if not_bool(HasArchVersion(ARMv8p2)) | not_bool(HaveSHA1Ext() & HaveSHA256Ext()) then {
        return(false)
    } else ();
    return(__IMPDEF_boolean("Has SHA3 Crypto instructions"))
}

val HaveSM3Ext : unit -> bool

function HaveSM3Ext () = {
    if not_bool(HasArchVersion(ARMv8p2)) then {
        return(false)
    } else ();
    return(__IMPDEF_boolean("Has SM3 Crypto instructions"))
}

val HaveSM4Ext : unit -> bool

function HaveSM4Ext () = {
    if not_bool(HasArchVersion(ARMv8p2)) then {
        return(false)
    } else ();
    return(__IMPDEF_boolean("Has SM4 Crypto instructions"))
}

val ROL : forall ('N 'shift : Int).
  (bits('N), int('shift)) -> bits('N) effect {escape}

function ROL (x, shift) = {
    assert(shift >= 0 & shift <= 'N);
    if shift == 0 then {
        return(x)
    } else ();
    return(ROR(x, 'N - shift))
}

val AESShiftRows : bits(128) -> bits(128)

function AESShiftRows op = {
    return(((((((((((((((Slice(op, 88, 8) @ Slice(op, 48, 8)) @ Slice(op, 8, 8)) @ Slice(op, 96, 8)) @ Slice(op, 56, 8)) @ Slice(op, 16, 8)) @ Slice(op, 104, 8)) @ Slice(op, 64, 8)) @ Slice(op, 24, 8)) @ Slice(op, 112, 8)) @ Slice(op, 72, 8)) @ Slice(op, 32, 8)) @ Slice(op, 120, 8)) @ Slice(op, 80, 8)) @ Slice(op, 40, 8)) @ Slice(op, 0, 8))
}

val AESInvShiftRows : bits(128) -> bits(128)

function AESInvShiftRows op = {
    return(((((((((((((((Slice(op, 24, 8) @ Slice(op, 48, 8)) @ Slice(op, 72, 8)) @ Slice(op, 96, 8)) @ Slice(op, 120, 8)) @ Slice(op, 16, 8)) @ Slice(op, 40, 8)) @ Slice(op, 64, 8)) @ Slice(op, 88, 8)) @ Slice(op, 112, 8)) @ Slice(op, 8, 8)) @ Slice(op, 32, 8)) @ Slice(op, 56, 8)) @ Slice(op, 80, 8)) @ Slice(op, 104, 8)) @ Slice(op, 0, 8))
}

val AESSubBytes : bits(128) -> bits(128) effect {undef}

function AESSubBytes op = {
    let GF2 : bits(2048) = ((((((((((((((0x16bb54b00f2d99416842e6bf0d89a18c @ 0xdf2855cee9871e9b948ed9691198f8e1) @ 0x9e1dc186b95735610ef6034866b53e70) @ 0x8a8bbd4b1f74dde8c6b4a61c2e2578ba) @ 0x08ae7a65eaf4566ca94ed58d6d37c8e7) @ 0x79e4959162acd3c25c2406490a3a32e0) @ 0xdb0b5ede14b8ee4688902a22dc4f8160) @ 0x73195d643d7ea7c41744975fec130ccd) @ 0xd2f3ff1021dab6bcf5389d928f40a351) @ 0xa89f3c507f02f94585334d43fbaaefd0) @ 0xcf584c4a39becb6a5bb1fc20ed00d153) @ 0x842fe329b3d63b52a05a6e1b1a2c8309) @ 0x75b227ebe28012079a059618c323c704) @ 0x1531d871f1e5a534ccf73f362693fdb7) @ 0xc072a49cafa2d4adf04759fa7dc982ca) @ 0x76abd7fe2b670130c56f6bf27b777c63;
    out : bits(128) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        out = SetSlice(8, out, i * 8, Slice(GF2, UInt(Slice(op, i * 8, 8)) * 8, 8))
    };
    return(out)
}

val AESInvSubBytes : bits(128) -> bits(128) effect {undef}

function AESInvSubBytes op = {
    let GF2_inv : bits(2048) = ((((((((((((((0x7d0c2155631469e126d677ba7e042b17 @ 0x619953833cbbebc8b0f52aae4d3be0a0) @ 0xef9cc9939f7ae52d0d4ab519a97f5160) @ 0x5fec8027591012b131c7078833a8dd1f) @ 0xf45acd78fec0db9a2079d2c64b3e56fc) @ 0x1bbe18aa0e62b76f89c5291d711af147) @ 0x6edf751ce837f9e28535ade72274ac96) @ 0x73e6b4f0cecff297eadc674f4111913a) @ 0x6b8a130103bdafc1020f3fca8f1e2cd0) @ 0x0645b3b80558e4f70ad3bc8c00abd890) @ 0x849d8da75746155edab9edfd5048706c) @ 0x92b6655dcc5ca4d41698688664f6f872) @ 0x25d18b6d49a25b76b224d92866a12e08) @ 0x4ec3fa420b954cee3d23c2a632947b54) @ 0xcbe9dec444438e3487ff2f9b8239e37c) @ 0xfbd7f3819ea340bf38a53630d56a0952;
    out : bits(128) = undefined;
    foreach (i from 0 to 15 by 1 in inc) {
        out = SetSlice(8, out, i * 8, Slice(GF2_inv, UInt(Slice(op, i * 8, 8)) * 8, 8))
    };
    return(out)
}

val FFmul02 : bits(8) -> bits(8)

function FFmul02 b = {
    let FFmul_02 : bits(2048) = ((((((((((((((0xE5E7E1E3EDEFE9EBF5F7F1F3FDFFF9FB @ 0xC5C7C1C3CDCFC9CBD5D7D1D3DDDFD9DB) @ 0xA5A7A1A3ADAFA9ABB5B7B1B3BDBFB9BB) @ 0x858781838D8F898B959791939D9F999B) @ 0x656761636D6F696B757771737D7F797B) @ 0x454741434D4F494B555751535D5F595B) @ 0x252721232D2F292B353731333D3F393B) @ 0x050701030D0F090B151711131D1F191B) @ 0xFEFCFAF8F6F4F2F0EEECEAE8E6E4E2E0) @ 0xDEDCDAD8D6D4D2D0CECCCAC8C6C4C2C0) @ 0xBEBCBAB8B6B4B2B0AEACAAA8A6A4A2A0) @ 0x9E9C9A98969492908E8C8A8886848280) @ 0x7E7C7A78767472706E6C6A6866646260) @ 0x5E5C5A58565452504E4C4A4846444240) @ 0x3E3C3A38363432302E2C2A2826242220) @ 0x1E1C1A18161412100E0C0A0806040200;
    return(Slice(FFmul_02, UInt(b) * 8, 8))
}

val FFmul03 : bits(8) -> bits(8)

function FFmul03 b = {
    let FFmul_03 : bits(2048) = ((((((((((((((0x1A191C1F16151013020104070E0D080B @ 0x2A292C2F26252023323134373E3D383B) @ 0x7A797C7F76757073626164676E6D686B) @ 0x4A494C4F46454043525154575E5D585B) @ 0xDAD9DCDFD6D5D0D3C2C1C4C7CECDC8CB) @ 0xEAE9ECEFE6E5E0E3F2F1F4F7FEFDF8FB) @ 0xBAB9BCBFB6B5B0B3A2A1A4A7AEADA8AB) @ 0x8A898C8F86858083929194979E9D989B) @ 0x818287848D8E8B88999A9F9C95969390) @ 0xB1B2B7B4BDBEBBB8A9AAAFACA5A6A3A0) @ 0xE1E2E7E4EDEEEBE8F9FAFFFCF5F6F3F0) @ 0xD1D2D7D4DDDEDBD8C9CACFCCC5C6C3C0) @ 0x414247444D4E4B48595A5F5C55565350) @ 0x717277747D7E7B78696A6F6C65666360) @ 0x212227242D2E2B28393A3F3C35363330) @ 0x111217141D1E1B18090A0F0C05060300;
    return(Slice(FFmul_03, UInt(b) * 8, 8))
}

val FFmul09 : bits(8) -> bits(8)

function FFmul09 b = {
    let FFmul_09 : bits(2048) = ((((((((((((((0x464F545D626B70790E071C152A233831 @ 0xD6DFC4CDF2FBE0E99E978C85BAB3A8A1) @ 0x7D746F6659504B42353C272E1118030A) @ 0xEDE4FFF6C9C0DBD2A5ACB7BE8188939A) @ 0x3039222B141D060F78716A635C554E47) @ 0xA0A9B2BB848D969FE8E1FAF3CCC5DED7) @ 0x0B0219102F263D34434A5158676E757C) @ 0x9B928980BFB6ADA4D3DAC1C8F7FEE5EC) @ 0xAAA3B8B18E879C95E2EBF0F9C6CFD4DD) @ 0x3A3328211E170C05727B6069565F444D) @ 0x9198838AB5BCA7AED9D0CBC2FDF4EFE6) @ 0x0108131A252C373E49405B526D647F76) @ 0xDCD5CEC7F8F1EAE3949D868FB0B9A2AB) @ 0x4C455E5768617A73040D161F2029323B) @ 0xE7EEF5FCC3CAD1D8AFA6BDB48B829990) @ 0x777E656C535A41483F362D241B120900;
    return(Slice(FFmul_09, UInt(b) * 8, 8))
}

val FFmul0B : bits(8) -> bits(8)

function FFmul0B b = {
    let FFmul_0B : bits(2048) = ((((((((((((((0xA3A8B5BE8F849992FBF0EDE6D7DCC1CA @ 0x1318050E3F3429224B405D56676C717A) @ 0xD8D3CEC5F4FFE2E9808B969DACA7BAB1) @ 0x68637E75444F5259303B262D1C170A01) @ 0x555E434879726F640D061B10212A373C) @ 0xE5EEF3F8C9C2DFD4BDB6ABA0919A878C) @ 0x2E2538330209141F767D606B5A514C47) @ 0x9E958883B2B9A4AFC6CDD0DBEAE1FCF7) @ 0x545F424978736E650C071A11202B363D) @ 0xE4EFF2F9C8C3DED5BCB7AAA1909B868D) @ 0x2F2439320308151E777C616A5B504D46) @ 0x9F948982B3B8A5AEC7CCD1DAEBE0FDF6) @ 0xA2A9B4BF8E859893FAF1ECE7D6DDC0CB) @ 0x1219040F3E3528234A415C57666D707B) @ 0xD9D2CFC4F5FEE3E8818A979CADA6BBB0) @ 0x69627F74454E5358313A272C1D160B00;
    return(Slice(FFmul_0B, UInt(b) * 8, 8))
}

val FFmul0D : bits(8) -> bits(8)

function FFmul0D b = {
    let FFmul_0D : bits(2048) = ((((((((((((((0x979A8D80A3AEB9B4FFF2E5E8CBC6D1DC @ 0x474A5D50737E69642F2235381B16010C) @ 0x2C21363B1815020F44495E53707D6A67) @ 0xFCF1E6EBC8C5D2DF94998E83A0ADBAB7) @ 0xFAF7E0EDCEC3D4D9929F8885A6ABBCB1) @ 0x2A27303D1E130409424F5855767B6C61) @ 0x414C5B5675786F622924333E1D10070A) @ 0x919C8B86A5A8BFB2F9F4E3EECDC0D7DA) @ 0x4D40575A7974636E25283F32111C0B06) @ 0x9D90878AA9A4B3BEF5F8EFE2C1CCDBD6) @ 0xF6FBECE1C2CFD8D59E938489AAA7B0BD) @ 0x262B3C31121F08054E4354597A77606D) @ 0x202D3A3714190E034845525F7C71666B) @ 0xF0FDEAE7C4C9DED39895828FACA1B6BB) @ 0x9B96818CAFA2B5B8F3FEE9E4C7CADDD0) @ 0x4B46515C7F726568232E3934171A0D00;
    return(Slice(FFmul_0D, UInt(b) * 8, 8))
}

val FFmul0E : bits(8) -> bits(8)

function FFmul0E b = {
    let FFmul_0E : bits(2048) = ((((((((((((((0x8D83919FB5BBA9A7FDF3E1EFC5CBD9D7 @ 0x6D63717F555B49471D13010F252B3937) @ 0x56584A446E60727C26283A341E10020C) @ 0xB6B8AAA48E80929CC6C8DAD4FEF0E2EC) @ 0x202E3C321816040A505E4C426866747A) @ 0xC0CEDCD2F8F6E4EAB0BEACA28886949A) @ 0xFBF5E7E9C3CDDFD18B859799B3BDAFA1) @ 0x1B150709232D3F316B657779535D4F41) @ 0xCCC2D0DEF4FAE8E6BCB2A0AE848A9896) @ 0x2C22303E141A08065C52404E646A7876) @ 0x17190B052F21333D67697B755F51434D) @ 0xF7F9EBE5CFC1D3DD87899B95BFB1A3AD) @ 0x616F7D735957454B111F0D032927353B) @ 0x818F9D93B9B7A5ABF1FFEDE3C9C7D5DB) @ 0xBAB4A6A8828C9E90CAC4D6D8F2FCEEE0) @ 0x5A544648626C7E702A243638121C0E00;
    return(Slice(FFmul_0E, UInt(b) * 8, 8))
}

val AESMixColumns : bits(128) -> bits(128) effect {undef}

function AESMixColumns op = {
    let in0 : bits(32) = ((Slice(op, 96, 8) @ Slice(op, 64, 8)) @ Slice(op, 32, 8)) @ Slice(op, 0, 8);
    let in1 : bits(32) = ((Slice(op, 104, 8) @ Slice(op, 72, 8)) @ Slice(op, 40, 8)) @ Slice(op, 8, 8);
    let in2 : bits(32) = ((Slice(op, 112, 8) @ Slice(op, 80, 8)) @ Slice(op, 48, 8)) @ Slice(op, 16, 8);
    let in3 : bits(32) = ((Slice(op, 120, 8) @ Slice(op, 88, 8)) @ Slice(op, 56, 8)) @ Slice(op, 24, 8);
    out0 : bits(32) = undefined;
    out1 : bits(32) = undefined;
    out2 : bits(32) = undefined;
    out3 : bits(32) = undefined;
    foreach (c from 0 to 3 by 1 in inc) {
        out0 = SetSlice(8, out0, c * 8, EOR(EOR(EOR(FFmul02(Slice(in0, c * 8, 8)), FFmul03(Slice(in1, c * 8, 8))), Slice(in2, c * 8, 8)), Slice(in3, c * 8, 8)));
        out1 = SetSlice(8, out1, c * 8, EOR(EOR(EOR(Slice(in0, c * 8, 8), FFmul02(Slice(in1, c * 8, 8))), FFmul03(Slice(in2, c * 8, 8))), Slice(in3, c * 8, 8)));
        out2 = SetSlice(8, out2, c * 8, EOR(EOR(EOR(Slice(in0, c * 8, 8), Slice(in1, c * 8, 8)), FFmul02(Slice(in2, c * 8, 8))), FFmul03(Slice(in3, c * 8, 8))));
        out3 = SetSlice(8, out3, c * 8, EOR(EOR(EOR(FFmul03(Slice(in0, c * 8, 8)), Slice(in1, c * 8, 8)), Slice(in2, c * 8, 8)), FFmul02(Slice(in3, c * 8, 8))))
    };
    return(((((((((((((((Slice(out3, 3 * 8, 8) @ Slice(out2, 3 * 8, 8)) @ Slice(out1, 3 * 8, 8)) @ Slice(out0, 3 * 8, 8)) @ Slice(out3, 2 * 8, 8)) @ Slice(out2, 2 * 8, 8)) @ Slice(out1, 2 * 8, 8)) @ Slice(out0, 2 * 8, 8)) @ Slice(out3, 1 * 8, 8)) @ Slice(out2, 1 * 8, 8)) @ Slice(out1, 1 * 8, 8)) @ Slice(out0, 1 * 8, 8)) @ Slice(out3, 0 * 8, 8)) @ Slice(out2, 0 * 8, 8)) @ Slice(out1, 0 * 8, 8)) @ Slice(out0, 0 * 8, 8))
}

val AESInvMixColumns : bits(128) -> bits(128) effect {undef}

function AESInvMixColumns op = {
    let in0 : bits(32) = ((Slice(op, 96, 8) @ Slice(op, 64, 8)) @ Slice(op, 32, 8)) @ Slice(op, 0, 8);
    let in1 : bits(32) = ((Slice(op, 104, 8) @ Slice(op, 72, 8)) @ Slice(op, 40, 8)) @ Slice(op, 8, 8);
    let in2 : bits(32) = ((Slice(op, 112, 8) @ Slice(op, 80, 8)) @ Slice(op, 48, 8)) @ Slice(op, 16, 8);
    let in3 : bits(32) = ((Slice(op, 120, 8) @ Slice(op, 88, 8)) @ Slice(op, 56, 8)) @ Slice(op, 24, 8);
    out0 : bits(32) = undefined;
    out1 : bits(32) = undefined;
    out2 : bits(32) = undefined;
    out3 : bits(32) = undefined;
    foreach (c from 0 to 3 by 1 in inc) {
        out0 = SetSlice(8, out0, c * 8, EOR(EOR(EOR(FFmul0E(Slice(in0, c * 8, 8)), FFmul0B(Slice(in1, c * 8, 8))), FFmul0D(Slice(in2, c * 8, 8))), FFmul09(Slice(in3, c * 8, 8))));
        out1 = SetSlice(8, out1, c * 8, EOR(EOR(EOR(FFmul09(Slice(in0, c * 8, 8)), FFmul0E(Slice(in1, c * 8, 8))), FFmul0B(Slice(in2, c * 8, 8))), FFmul0D(Slice(in3, c * 8, 8))));
        out2 = SetSlice(8, out2, c * 8, EOR(EOR(EOR(FFmul0D(Slice(in0, c * 8, 8)), FFmul09(Slice(in1, c * 8, 8))), FFmul0E(Slice(in2, c * 8, 8))), FFmul0B(Slice(in3, c * 8, 8))));
        out3 = SetSlice(8, out3, c * 8, EOR(EOR(EOR(FFmul0B(Slice(in0, c * 8, 8)), FFmul0D(Slice(in1, c * 8, 8))), FFmul09(Slice(in2, c * 8, 8))), FFmul0E(Slice(in3, c * 8, 8))))
    };
    return(((((((((((((((Slice(out3, 3 * 8, 8) @ Slice(out2, 3 * 8, 8)) @ Slice(out1, 3 * 8, 8)) @ Slice(out0, 3 * 8, 8)) @ Slice(out3, 2 * 8, 8)) @ Slice(out2, 2 * 8, 8)) @ Slice(out1, 2 * 8, 8)) @ Slice(out0, 2 * 8, 8)) @ Slice(out3, 1 * 8, 8)) @ Slice(out2, 1 * 8, 8)) @ Slice(out1, 1 * 8, 8)) @ Slice(out0, 1 * 8, 8)) @ Slice(out3, 0 * 8, 8)) @ Slice(out2, 0 * 8, 8)) @ Slice(out1, 0 * 8, 8)) @ Slice(out0, 0 * 8, 8))
}

val SHAchoose : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAchoose (x, y, z) = {
    return(EOR(EOR(y, z) & x, z))
}

val SHAparity : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAparity (x, y, z) = {
    return(EOR(EOR(x, y), z))
}

val SHAmajority : (bits(32), bits(32), bits(32)) -> bits(32)

function SHAmajority (x, y, z) = {
    return(x & y | (x | y) & z)
}

val SHAhashSIGMA0 : bits(32) -> bits(32)

function SHAhashSIGMA0 x = {
    return(EOR(EOR(ROR(x, 2), ROR(x, 13)), ROR(x, 22)))
}

val SHAhashSIGMA1 : bits(32) -> bits(32)

function SHAhashSIGMA1 x = {
    return(EOR(EOR(ROR(x, 6), ROR(x, 11)), ROR(x, 25)))
}

val SHA256hash : forall ('part1 : Bool).
  (bits(128), bits(128), bits(128), bool('part1)) -> bits(128) effect {escape, undef}

function SHA256hash (X__arg, Y__arg, W, part1) = {
    X : bits(128) = X__arg;
    Y : bits(128) = Y__arg;
    chs : bits(32) = undefined;
    maj : bits(32) = undefined;
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        chs = SHAchoose(Y[31 .. 0], Y[63 .. 32], Y[95 .. 64]);
        maj = SHAmajority(X[31 .. 0], X[63 .. 32], X[95 .. 64]);
        t = Y[127 .. 96] + SHAhashSIGMA1(Y[31 .. 0]) + chs + Elem_read(W, e, 32);
        X[127 .. 96] = t + X[127 .. 96];
        Y[127 .. 96] = t + SHAhashSIGMA0(X[31 .. 0]) + maj;
        (Y @ X) = ROL(Y @ X, 32)
    };
    return(if part1 then X else Y)
}

val Sbox : bits(8) -> bits(8)

function Sbox sboxin = {
    let sboxstring : bits(2048) = 0xd690e9fecce13db716b614c228fb2c052b679a762abe04c3aa441326498606999c4250f491ef987a33540b43edcfac62e4b31ca9c908e89580df94fa758f3fa64707a7fcf37317ba83593c19e6854fa8686b81b27164da8bf8eb0f4b70569d351e240e5e6358d1a225227c3b01217887d40046579fd327524c3602e7a0c4c89eeabf8ad240c738b5a3f7f2cef96115a1e0ae5da49b341a55ad933230f58cb1e31df6e22e8266ca60c02923ab0d534e6fd5db3745defd8e2f03ff6a726d6c5b518d1baf92bbddbc7f11d95c411f105ad80ac13188a5cd7bbd2d74d012b8e5b4b08969974a0c96777e65b9f109c56ec68418f07dec3adc4d2079ee5f3ed7cb3948;
    let sboxin = UInt(sboxin);
    let sboxout : bits(8) = sboxstring[(255 - sboxin) * 8 + 7 .. (255 - sboxin) * 8];
    return(sboxout)
}

val RecipEstimate : forall ('a : Int). int('a) -> int effect {escape}

function RecipEstimate a__arg = {
    a : int = a__arg;
    assert(256 <= a & a < 512);
    let 'a = a * 2 + 1;
    let 'b = DIV(2 ^ 19, a);
    let 'r = DIV(b + 1, 2);
    assert(256 <= r & r < 512);
    return(r)
}

val UnsignedRecipEstimate : forall ('N : Int), 'N in {16, 32}.
  bits('N) -> bits('N) effect {escape, undef}

function UnsignedRecipEstimate operand = {
    estimate : int = undefined;
    result : bits('N) = undefined;
    assert('N == 16 | 'N == 32);
    if [operand['N - 1]] == 0b0 then {
        result = Ones('N)
    } else {
        match 'N {
          16 => {
              estimate = RecipEstimate(UInt(operand[15 .. 7]))
          },
          32 => {
              estimate = RecipEstimate(UInt(operand[31 .. 23]))
          },
          _ => ()
        };
        let 'estimate = estimate;
        result = estimate[8 .. 0] @ Zeros('N - 9)
    };
    return(result)
}

val RecipSqrtEstimate : forall ('a : Int). int('a) -> int effect {escape}

function RecipSqrtEstimate a__arg = {
    a : int = a__arg;
    assert(128 <= a & a < 512);
    if a < 256 then {
        a = a * 2 + 1
    } else {
        a = (((a >> 1)) << 1);
        a = (a + 1) * 2
    };
    let 'a = a;
    b : int = 512;
    while a * (b + 1) * (b + 1) < pow2(28) do {
        b = b + 1
    };
    let 'b = b;
    let 'r = DIV(b + 1, 2);
    assert(256 <= r & r < 512);
    return(r)
}

val UnsignedRSqrtEstimate : forall ('N : Int), 'N in {16, 32}.
  bits('N) -> bits('N) effect {escape, undef}

function UnsignedRSqrtEstimate operand = {
    estimate : int = undefined;
    result : bits('N) = undefined;
    assert('N == 16 | 'N == 32);
    if operand['N - 1 .. 'N - 2] == 0b00 then {
        result = Ones('N)
    } else {
        match 'N {
          16 => {
              estimate = RecipSqrtEstimate(UInt(operand[15 .. 7]))
          },
          32 => {
              estimate = RecipSqrtEstimate(UInt(operand[31 .. 23]))
          },
          _ => ()
        };
        let 'estimate = estimate;
        result = estimate[8 .. 0] @ Zeros('N - 9)
    };
    return(result)
}

val SignedSatQ : forall ('N 'i : Int), 'N - 1 >= 0.
  (int('i), int('N)) -> (bits('N), bool) effect {undef}

function SignedSatQ (i, N) = {
    result : int = undefined;
    saturated : bool = undefined;
    if i > pow2(N - 1) - 1 then {
        result = pow2(N - 1) - 1;
        saturated = true
    } else if i < negate(2 ^ (N - 1)) then {
        result = negate(2 ^ (N - 1));
        saturated = true
    } else {
        result = i;
        saturated = false
    };
    let 'result = result;
    return((result[N - 1 .. 0], saturated))
}

val UnsignedSatQ : forall ('N 'i : Int), 'N >= 0.
  (int('i), int('N)) -> (bits('N), bool) effect {escape, undef}

val UnsignedSatQ__1 : forall 'M 'N 'i,
  ('N >= 0 | not('N <= 'M)).
  (int('i), int('N), int('M)) -> (bits('M), bool) effect {escape, undef}

function UnsignedSatQ__1 (i, N, M) = {
    result : int = undefined;
    saturated : bool = undefined;
    assert(N <= M);
    if i > pow2(N) - 1 then {
        result = pow2(N) - 1;
        saturated = true
    } else if i < 0 then {
        result = 0;
        saturated = true
    } else {
        result = i;
        saturated = false
    };
    let 'result = result;
    assert(constraint(0 <= 'M - 1));
    return((result[M - 1 .. 0], saturated))
}

function UnsignedSatQ (i, N) = {
    return(UnsignedSatQ__1(i, N, N))
}

val SatQ : forall 'N 'i ('is_unsigned : Bool),
  ('N >= 0 | not('is_unsigned)) & ('N - 1 >= 0 | not(not('is_unsigned))).
  (int('i), int('N), bool('is_unsigned)) -> (bits('N), bool) effect {escape, undef}

function SatQ (i, N, is_unsigned) = {
    result : bits('N) = undefined;
    sat : bool = undefined;
    (result, sat) = if is_unsigned then UnsignedSatQ(i, N) else SignedSatQ(i, N);
    return((result, sat))
}

val AdvSIMDExpandImm : (bits(1), bits(4), bits(8)) -> bits(64) effect {escape, rreg, undef}

function AdvSIMDExpandImm (op, cmode, imm8) = {
    imm32 : bits(32) = undefined;
    imm64 : bits(64) = undefined;
    imm8a : bits(8) = undefined;
    imm8b : bits(8) = undefined;
    imm8c : bits(8) = undefined;
    imm8d : bits(8) = undefined;
    imm8e : bits(8) = undefined;
    imm8f : bits(8) = undefined;
    imm8g : bits(8) = undefined;
    imm8h : bits(8) = undefined;
    match cmode[3 .. 1] {
      0b000 => {
          imm64 = Replicate(Zeros(24) @ imm8, 2)
      },
      0b001 => {
          imm64 = Replicate((Zeros(16) @ imm8) @ Zeros(8), 2)
      },
      0b010 => {
          imm64 = Replicate((Zeros(8) @ imm8) @ Zeros(16), 2)
      },
      0b011 => {
          imm64 = Replicate(imm8 @ Zeros(24), 2)
      },
      0b100 => {
          imm64 = Replicate(Zeros(8) @ imm8, 4)
      },
      0b101 => {
          imm64 = Replicate(imm8 @ Zeros(8), 4)
      },
      0b110 => {
          if [cmode[0]] == 0b0 then {
              imm64 = Replicate((Zeros(16) @ imm8) @ Ones(8), 2)
          } else {
              imm64 = Replicate((Zeros(8) @ imm8) @ Ones(16), 2)
          }
      },
      0b111 => {
          if [cmode[0]] == 0b0 & op == 0b0 then {
              imm64 = Replicate(imm8, 8)
          } else ();
          if [cmode[0]] == 0b0 & op == 0b1 then {
              let imm8a : bits(8) = Replicate([imm8[7]], 8);
              let imm8b : bits(8) = Replicate([imm8[6]], 8);
              let imm8c : bits(8) = Replicate([imm8[5]], 8);
              let imm8d : bits(8) = Replicate([imm8[4]], 8);
              let imm8e : bits(8) = Replicate([imm8[3]], 8);
              let imm8f : bits(8) = Replicate([imm8[2]], 8);
              let imm8g : bits(8) = Replicate([imm8[1]], 8);
              let imm8h : bits(8) = Replicate([imm8[0]], 8);
              imm64 = ((((((imm8a @ imm8b) @ imm8c) @ imm8d) @ imm8e) @ imm8f) @ imm8g) @ imm8h
          } else ();
          if [cmode[0]] == 0b1 & op == 0b0 then {
              let imm32 : bits(32) = ((([imm8[7]] @ not_vec([imm8[6]])) @ Replicate([imm8[6]], 5)) @ imm8[5 .. 0]) @ Zeros(19);
              imm64 = Replicate(imm32, 2)
          } else ();
          if [cmode[0]] == 0b1 & op == 0b1 then {
              if UsingAArch32() then {
                  ReservedEncoding()
              } else ();
              imm64 = ((([imm8[7]] @ not_vec([imm8[6]])) @ Replicate([imm8[6]], 8)) @ imm8[5 .. 0]) @ Zeros(48)
          } else ()
      }
    };
    return(imm64)
}

val PolynomialMult : forall 'M 'N,
  'M + 'N >= 0 & ('N >= 0 & 'M + 'N >= 'N).
  (bits('M), bits('N)) -> bits('M + 'N)

function PolynomialMult (op1, op2) = {
    result : bits('M + 'N) = Zeros('M + 'N);
    let extended_op2 : bits('M + 'N) = ZeroExtend(op2, 'M + 'N);
    foreach (i from 0 to ('M - 1) by 1 in inc) {
        if [op1[i]] == 0b1 then {
            result = EOR(result, LSL(extended_op2, i))
        } else ()
    };
    return(result)
}

val AddWithCarry : forall ('N : Int), 'N > 0.
  (bits('N), bits('N), bits(1)) -> (bits('N), bits(4))

function AddWithCarry (x, y, carry_in) = {
    let 'unsigned_sum = UInt(x) + UInt(y) + UInt(carry_in);
    let 'signed_sum = SInt(x) + SInt(y) + UInt(carry_in);
    let result : bits('N) = unsigned_sum['N - 1 .. 0];
    let n : bits(1) = [result['N - 1]];
    let z : bits(1) = if IsZero(result) then 0b1 else 0b0;
    let c : bits(1) = if UInt(result) == unsigned_sum then 0b0 else 0b1;
    let v : bits(1) = if SInt(result) == signed_sum then 0b0 else 0b1;
    return((result, ((n @ z) @ c) @ v))
}

val FPInfinity : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits(1)) -> bits('N) effect {escape}

function FPInfinity (N, sign) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits('E) = Ones(E);
    let frac : bits('F) = Zeros(F);
    return((sign @ exp) @ frac)
}

val FPMaxNormal : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits(1)) -> bits('N) effect {escape}

function FPMaxNormal (N, sign) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits('E) = Ones(E - 1) @ 0b0;
    let frac : bits('F) = Ones(F);
    return((sign @ exp) @ frac)
}

val AArch64_FPTrappedException : forall ('element : Int)('is_ase : Bool).
  (bool('is_ase), int('element), bits(8)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_FPTrappedException (is_ase, element, accumulated_exceptions) = {
    exception : ExceptionRecord = ExceptionSyndrome(Exception_FPTrappedException);
    if is_ase then {
        if __IMPDEF_boolean("vector instructions set TFV to 1") then {
            exception.syndrome[23 .. 23] = 0b1
        } else {
            exception.syndrome[23 .. 23] = 0b0
        }
    } else {
        exception.syndrome[23 .. 23] = 0b1
    };
    exception.syndrome[10 .. 8] = __UNKNOWN_bits(3);
    if [exception.syndrome[23]] == 0b1 then {
        (exception.syndrome[7 .. 7] @ exception.syndrome[4 .. 0]) = accumulated_exceptions[7 .. 7] @ accumulated_exceptions[4 .. 0]
    } else {
        (exception.syndrome[7 .. 7] @ exception.syndrome[4 .. 0]) = __UNKNOWN_bits(6)
    };
    let route_to_el2 : bool = EL2Enabled() & Slice(HCR_EL2, 27, 1) == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val FPProcessException : (FPExc, bits(32)) -> unit effect {escape, rreg, undef, wreg}

function FPProcessException (exception, fpcr) = {
    cumul : {|0, 1, 2, 3, 4, 7|} = 0;
    match exception {
      FPExc_InvalidOp => {
          cumul = 0
      },
      FPExc_DivideByZero => {
          cumul = 1
      },
      FPExc_Overflow => {
          cumul = 2
      },
      FPExc_Underflow => {
          cumul = 3
      },
      FPExc_Inexact => {
          cumul = 4
      },
      FPExc_InputDenorm => {
          cumul = 7
      }
    };
    let 'cumul = cumul;
    let 'enable = cumul + 8;
    if [fpcr[enable]] == 0b1 then {
        let exception_syndrome : bits(8) = ((1 << cumul))[7 .. 0];
        AArch64_FPTrappedException(false, 0, exception_syndrome)
    } else {
        FPSR[cumul .. cumul] = 0b1
    };
    return()
}

val FPZero : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits(1)) -> bits('N) effect {escape}

function FPZero (N, sign) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits('E) = Zeros(E);
    let frac : bits('F) = Zeros(F);
    return((sign @ exp) @ frac)
}

val FPRoundBase : forall 'N ('isbfloat : Bool),
  'N in {16, 32, 64}.
  (implicit('N), real, bits(32), FPRounding, bool('isbfloat)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundBase (N, op, fpcr, rounding, isbfloat) = {
    E : {|5, 8, 11|} = 5;
    F : {|7, 10, 23, 52|} = 7;
    mantissa : real = undefined;
    minimum_exp : int = undefined;
    overflow_to_inf : bool = undefined;
    round_up : bool = undefined;
    sign : bits(1) = undefined;
    assert(N == 16 | N == 32 | N == 64);
    assert(op != 0.0);
    assert(rounding != FPRounding_TIEAWAY);
    result : bits('N) = undefined;
    if N == 16 then {
        minimum_exp = negate(14);
        E = 5;
        F = 10
    } else if N == 32 & isbfloat then {
        minimum_exp = negate(126);
        E = 8;
        F = 7
    } else if N == 32 then {
        minimum_exp = negate(126);
        E = 8;
        F = 23
    } else {
        minimum_exp = negate(1022);
        E = 11;
        F = 52
    };
    let 'minimum_exp = minimum_exp;
    let 'F = F;
    let 'E = E;
    if op < 0.0 then {
        sign = 0b1;
        mantissa = neg_real(op)
    } else {
        sign = 0b0;
        mantissa = op
    };
    exponent : int = 0;
    while mantissa < 1.0 do {
        mantissa = mantissa * 2.0;
        exponent = exponent - 1
    };
    while mantissa >= 2.0 do {
        mantissa = mantissa / 2.0;
        exponent = exponent + 1
    };
    let 'exponent = exponent;
    if ([fpcr[24]] == 0b1 & N != 16 | [fpcr[19]] == 0b1 & N == 16) & exponent < minimum_exp then {
        FPSR = SetSlice(1, FPSR, 3, 0b1);
        return(FPZero(N, sign))
    } else ();
    biased_exp : int = Max(exponent - minimum_exp + 1, 0);
    if biased_exp == 0 then {
        mantissa = mantissa / 2.0 ^ (minimum_exp - exponent)
    } else ();
    let mantissa = mantissa;
    int_mant : int = RoundDown(mantissa * 2.0 ^ F);
    error : real = mantissa * 2.0 ^ F - Real(int_mant);
    if biased_exp == 0 & (error != 0.0 | [fpcr[11]] == 0b1) then {
        FPProcessException(FPExc_Underflow, fpcr)
    } else ();
    match rounding {
      FPRounding_TIEEVEN => {
          round_up = error > 0.5 | error == 0.5 & [int_mant[0]] == 0b1;
          overflow_to_inf = true
      },
      FPRounding_POSINF => {
          round_up = error != 0.0 & sign == 0b0;
          overflow_to_inf = sign == 0b0
      },
      FPRounding_NEGINF => {
          round_up = error != 0.0 & sign == 0b1;
          overflow_to_inf = sign == 0b1
      },
      FPRounding_ZERO => {
          round_up = false;
          overflow_to_inf = false
      },
      FPRounding_ODD => {
          round_up = false;
          overflow_to_inf = false
      },
      _ => ()
    };
    if round_up then {
        int_mant = int_mant + 1;
        if int_mant == pow2(F) then {
            biased_exp = 1
        } else ();
        if int_mant == pow2(F + 1) then {
            biased_exp = biased_exp + 1;
            int_mant = DIV(int_mant, 2)
        } else ()
    } else ();
    let 'biased_exp = biased_exp;
    if error != 0.0 & rounding == FPRounding_ODD then {
        int_mant = [int_mant with 0 .. 0 = 0b1]
    } else ();
    let 'int_mant = int_mant;
    if N != 16 | [fpcr[26]] == 0b0 then {
        if biased_exp >= pow2(E) - 1 then {
            result = if overflow_to_inf then FPInfinity(N, sign) else FPMaxNormal(N, sign);
            FPProcessException(FPExc_Overflow, fpcr);
            error = 1.0
        } else {
            assert(constraint('N - ('E + 'F + 1) >= 0));
            result = ((sign @ biased_exp[E - 1 .. 0]) @ int_mant[F - 1 .. 0]) @ Zeros(N - (E + F + 1))
        }
    } else {
        if biased_exp >= pow2(E) then {
            result = sign @ Ones(N - 1);
            FPProcessException(FPExc_InvalidOp, fpcr);
            error = 0.0
        } else {
            assert(constraint('N - ('E + 'F + 1) >= 0));
            result = ((sign @ biased_exp[E - 1 .. 0]) @ int_mant[F - 1 .. 0]) @ Zeros(N - (E + F + 1))
        }
    };
    if error != 0.0 then {
        FPProcessException(FPExc_Inexact, fpcr)
    } else ();
    return(result)
}

val FPDecodeRounding : bits(2) -> FPRounding effect {undef}

function FPDecodeRounding rmode = {
    match rmode {
      0b00 => {
          return(FPRounding_TIEEVEN)
      },
      0b01 => {
          return(FPRounding_POSINF)
      },
      0b10 => {
          return(FPRounding_NEGINF)
      },
      0b11 => {
          return(FPRounding_ZERO)
      },
      _ => {
          return(undefined : FPRounding)
      }
    }
}

val FPRoundingMode : bits(32) -> FPRounding effect {undef}

function FPRoundingMode fpcr = {
    return(FPDecodeRounding(Slice(fpcr, 22, 2)))
}

val FPRound : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), real, bits(32), FPRounding) -> bits('N) effect {escape, rreg, undef, wreg}

val FPRound__1 : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), real, bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRound (N, op, fpcr__arg, rounding) = {
    fpcr : bits(32) = fpcr__arg;
    fpcr[26] = Bit(0b0);
    let isbfloat : bool = false;
    return(FPRoundBase(N, op, fpcr, rounding, isbfloat))
}

function FPRound__1 (N, op, fpcr) = {
    return(FPRound(N, op, fpcr, FPRoundingMode(fpcr)))
}

val FixedToFP : forall 'M 'N 'fbits ('is_unsigned : Bool),
  ('N in {16, 32, 64} & 'M in {16, 32, 64}).
  (implicit('N), bits('M), int('fbits), bool('is_unsigned), bits(32), FPRounding) -> bits('N) effect {escape, rreg, undef, wreg}

function FixedToFP (N, op, fbits, is_unsigned, fpcr, rounding) = {
    assert(N == 16 | N == 32 | N == 64);
    assert('M == 16 | 'M == 32 | 'M == 64);
    result : bits('N) = undefined;
    assert(fbits >= 0);
    assert(rounding != FPRounding_ODD);
    let 'int_operand = asl_Int(op, is_unsigned);
    let real_operand : real = Real(int_operand) / 2.0 ^ fbits;
    if real_operand == 0.0 then {
        result = FPZero(N, 0b0)
    } else {
        result = FPRound(N, real_operand, fpcr, rounding)
    };
    return(result)
}

val FPAbs : forall ('N : Int), 'N in {16, 32, 64}.
  bits('N) -> bits('N) effect {escape}

function FPAbs op = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    return(0b0 @ op['N - 2 .. 0])
}

val FPDefaultNaN : forall ('N : Int), 'N in {16, 32, 64}.
  implicit('N) -> bits('N) effect {escape}

function FPDefaultNaN N = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let sign : bits(1) = 0b0;
    let exp : bits('E) = Ones(E);
    let frac : bits('F) = 0b1 @ Zeros(F - 1);
    return((sign @ exp) @ frac)
}

val FPProcessNaN : forall ('N : Int), 'N in {16, 32, 64}.
  (FPType, bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPProcessNaN (fptype, op, fpcr) = {
    topfrac : {|9, 22, 51|} = 9;
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(fptype == FPType_QNaN | fptype == FPType_SNaN);
    match 'N {
      16 => {
          topfrac = 9
      },
      32 => {
          topfrac = 22
      },
      64 => {
          topfrac = 51
      },
      _ => ()
    };
    let 'topfrac = topfrac;
    result : bits('N) = op;
    if fptype == FPType_SNaN then {
        assert(constraint('topfrac < 'N));
        result[topfrac] = Bit(0b1);
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else ();
    if [fpcr[25]] == 0b1 then {
        result = FPDefaultNaN('N)
    } else ();
    return(result)
}

val FPProcessNaNs : forall ('N : Int), 'N in {16, 32, 64}.
  (FPType, FPType, bits('N), bits('N), bits(32)) -> (bool, bits('N)) effect {escape, rreg, undef, wreg}

function FPProcessNaNs (type1, type2, op1, op2, fpcr) = {
    done : bool = undefined;
    result : bits('N) = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else if type2 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type2, op2, fpcr)
    } else if type1 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else if type2 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN(type2, op2, fpcr)
    } else {
        done = false;
        result = Zeros()
    };
    return((done, result))
}

val FPUnpackBase : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits(32)) -> (FPType, bits(1), real) effect {escape, rreg, undef, wreg}

function FPUnpackBase (fpval, fpcr) = {
    exp16 : bits(5) = undefined;
    exp32 : bits(8) = undefined;
    exp64 : bits(11) = undefined;
    fptype : FPType = undefined;
    frac16 : bits(10) = undefined;
    frac32 : bits(23) = undefined;
    frac64 : bits(52) = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    if 'N == 16 then {
        sign = [fpval[15]];
        let exp16 : bits(5) = fpval[14 .. 10];
        let frac16 : bits(10) = fpval[9 .. 0];
        if IsZero(exp16) then {
            if IsZero(frac16) | [fpcr[19]] == 0b1 then {
                fptype = FPType_Zero;
                value_name = 0.0
            } else {
                fptype = FPType_Nonzero;
                value_name = 2.0 ^ negate(14) * (Real(UInt(frac16)) * 2.0 ^ negate(10))
            }
        } else if IsOnes(exp16) & [fpcr[26]] == 0b0 then {
            if IsZero(frac16) then {
                fptype = FPType_Infinity;
                value_name = 2.0 ^ 1000000
            } else {
                fptype = if [frac16[9]] == 0b1 then FPType_QNaN else FPType_SNaN;
                value_name = 0.0
            }
        } else {
            fptype = FPType_Nonzero;
            value_name = 2.0 ^ (UInt(exp16) - 15) * (1.0 + Real(UInt(frac16)) * 2.0 ^ negate(10))
        }
    } else if 'N == 32 then {
        sign = [fpval[31]];
        let exp32 : bits(8) = fpval[30 .. 23];
        let frac32 : bits(23) = fpval[22 .. 0];
        if IsZero(exp32) then {
            if IsZero(frac32) | [fpcr[24]] == 0b1 then {
                fptype = FPType_Zero;
                value_name = 0.0;
                if not_bool(IsZero(frac32)) then {
                    FPProcessException(FPExc_InputDenorm, fpcr)
                } else ()
            } else {
                fptype = FPType_Nonzero;
                value_name = 2.0 ^ negate(126) * (Real(UInt(frac32)) * 2.0 ^ negate(23))
            }
        } else if IsOnes(exp32) then {
            if IsZero(frac32) then {
                fptype = FPType_Infinity;
                value_name = 2.0 ^ 1000000
            } else {
                fptype = if [frac32[22]] == 0b1 then FPType_QNaN else FPType_SNaN;
                value_name = 0.0
            }
        } else {
            fptype = FPType_Nonzero;
            value_name = 2.0 ^ (UInt(exp32) - 127) * (1.0 + Real(UInt(frac32)) * 2.0 ^ negate(23))
        }
    } else {
        sign = [fpval[63]];
        let exp64 : bits(11) = fpval[62 .. 52];
        let frac64 : bits(52) = fpval[51 .. 0];
        if IsZero(exp64) then {
            if IsZero(frac64) | [fpcr[24]] == 0b1 then {
                fptype = FPType_Zero;
                value_name = 0.0;
                if not_bool(IsZero(frac64)) then {
                    FPProcessException(FPExc_InputDenorm, fpcr)
                } else ()
            } else {
                fptype = FPType_Nonzero;
                value_name = 2.0 ^ negate(1022) * (Real(UInt(frac64)) * 2.0 ^ negate(52))
            }
        } else if IsOnes(exp64) then {
            if IsZero(frac64) then {
                fptype = FPType_Infinity;
                value_name = 2.0 ^ 1000000
            } else {
                fptype = if [frac64[51]] == 0b1 then FPType_QNaN else FPType_SNaN;
                value_name = 0.0
            }
        } else {
            fptype = FPType_Nonzero;
            value_name = 2.0 ^ (UInt(exp64) - 1023) * (1.0 + Real(UInt(frac64)) * 2.0 ^ negate(52))
        }
    };
    if sign == 0b1 then {
        value_name = neg_real(value_name)
    } else ();
    let value_name = value_name;
    return((fptype, sign, value_name))
}

val FPUnpack : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits(32)) -> (FPType, bits(1), real) effect {escape, rreg, undef, wreg}

function FPUnpack (fpval, fpcr__arg) = {
    fpcr : bits(32) = fpcr__arg;
    fp_type : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    fpcr[26] = Bit(0b0);
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr);
    return((fp_type, sign, value_name))
}

val FPAdd : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPAdd (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == not_vec(sign2) then {
            result = FPDefaultNaN('N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b0 then {
            result = FPInfinity('N, 0b0)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b1 then {
            result = FPInfinity('N, 0b1)
        } else if (zero1 & zero2) & sign1 == sign2 then {
            result = FPZero('N, sign1)
        } else {
            let result_value : real = value1_name + value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                result = FPZero('N, result_sign)
            } else {
                result = FPRound('N, result_value, fpcr, rounding)
            }
        }
    } else ();
    return(result)
}

val FPCompare : forall 'N ('signal_nans : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits('N), bool('signal_nans), bits(32)) -> bits(4) effect {escape, rreg, undef, wreg}

function FPCompare (op1, op2, signal_nans, fpcr) = {
    result : bits(4) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = 0b0011;
        if (type1 == FPType_SNaN | type2 == FPType_SNaN) | signal_nans then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else ()
    } else {
        if value1_name == value2_name then {
            result = 0b0110
        } else if value1_name < value2_name then {
            result = 0b1000
        } else {
            result = 0b0010
        }
    };
    return(result)
}

val FPCompareEQ : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bool effect {escape, rreg, undef, wreg}

function FPCompareEQ (op1, op2, fpcr) = {
    result : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = false;
        if type1 == FPType_SNaN | type2 == FPType_SNaN then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else ()
    } else {
        result = value1_name == value2_name
    };
    return(result)
}

val FPCompareGE : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bool effect {escape, rreg, undef, wreg}

function FPCompareGE (op1, op2, fpcr) = {
    result : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = false;
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = value1_name >= value2_name
    };
    return(result)
}

val FPCompareGT : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bool effect {escape, rreg, undef, wreg}

function FPCompareGT (op1, op2, fpcr) = {
    result : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    if ((type1 == FPType_SNaN | type1 == FPType_QNaN) | type2 == FPType_SNaN) | type2 == FPType_QNaN then {
        result = false;
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = value1_name > value2_name
    };
    return(result)
}

val FPConvertNaN : forall 'M 'N,
  ('N in {16, 32, 64} & 'M in {16, 32, 64}).
  (implicit('M), bits('N)) -> bits('M) effect {escape, undef}

function FPConvertNaN (M, op) = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(M == 16 | M == 32 | M == 64);
    result : bits('M) = undefined;
    frac : bits(51) = undefined;
    let sign : bits(1) = [op['N - 1]];
    match 'N {
      64 => {
          frac = op[50 .. 0]
      },
      32 => {
          frac = op[21 .. 0] @ Zeros(29)
      },
      16 => {
          frac = op[8 .. 0] @ Zeros(42)
      },
      _ => ()
    };
    match M {
      64 => {
          result = (sign @ Ones(M - 52)) @ frac
      },
      32 => {
          result = (sign @ Ones(M - 23)) @ frac[50 .. 29]
      },
      16 => {
          result = (sign @ Ones(M - 10)) @ frac[50 .. 42]
      },
      _ => ()
    };
    return(result)
}

val FPRoundCV : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), real, bits(32), FPRounding) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundCV (N, op, fpcr__arg, rounding) = {
    fpcr : bits(32) = fpcr__arg;
    fpcr[19] = Bit(0b0);
    let isbfloat : bool = false;
    return(FPRoundBase(N, op, fpcr, rounding, isbfloat))
}

val FPUnpackCV : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits(32)) -> (FPType, bits(1), real) effect {escape, rreg, undef, wreg}

function FPUnpackCV (fpval, fpcr__arg) = {
    fpcr : bits(32) = fpcr__arg;
    fp_type : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    fpcr[19] = Bit(0b0);
    (fp_type, sign, value_name) = FPUnpackBase(fpval, fpcr);
    return((fp_type, sign, value_name))
}

val FPConvert : forall 'M 'N,
  ('M in {16, 32, 64} & 'N in {16, 32, 64}).
  (implicit('M), bits('N), bits(32), FPRounding) -> bits('M) effect {escape, rreg, undef, wreg}

val FPConvert__1 : forall 'M 'N,
  ('M in {16, 32, 64} & 'N in {16, 32, 64}).
  (implicit('M), bits('N), bits(32)) -> bits('M) effect {escape, rreg, undef, wreg}

function FPConvert (M, op, fpcr, rounding) = {
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert(M == 16 | M == 32 | M == 64);
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('M) = undefined;
    (fptype, sign, value_name) = FPUnpackCV(op, fpcr);
    let alt_hp : bool = M == 16 & [fpcr[26]] == 0b1;
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        if alt_hp then {
            result = FPZero(M, sign)
        } else if [fpcr[25]] == 0b1 then {
            result = FPDefaultNaN(M)
        } else {
            result = FPConvertNaN(M, op)
        };
        if fptype == FPType_SNaN | alt_hp then {
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else ()
    } else if fptype == FPType_Infinity then {
        if alt_hp then {
            result = sign @ Ones(M - 1);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else {
            result = FPInfinity(M, sign)
        }
    } else if fptype == FPType_Zero then {
        result = FPZero(M, sign)
    } else {
        result = FPRoundCV(M, value_name, fpcr, rounding)
    };
    return(result)
}

function FPConvert__1 (M, op, fpcr) = {
    return(FPConvert(M, op, fpcr, FPRoundingMode(fpcr)))
}

val FPDiv : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPDiv (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & inf2 | zero1 & zero2 then {
            result = FPDefaultNaN('N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 | zero2 then {
            result = FPInfinity('N, EOR(sign1, sign2));
            if not_bool(inf1) then {
                FPProcessException(FPExc_DivideByZero, fpcr)
            } else ()
        } else if zero1 | inf2 then {
            result = FPZero('N, EOR(sign1, sign2))
        } else {
            result = FPRound__1('N, value1_name / value2_name, fpcr)
        }
    } else ();
    return(result)
}

val FPMax : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMax (op1, op2, fpcr) = {
    done : bool = undefined;
    fptype : FPType = undefined;
    result : bits('N) = undefined;
    sign : bits(1) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value_name : real = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        if value1_name > value2_name then {
            (fptype, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (fptype, sign, value_name) = (type2, sign2, value2_name)
        };
        if fptype == FPType_Infinity then {
            result = FPInfinity('N, sign)
        } else if fptype == FPType_Zero then {
            let sign : bits(1) = sign1 & sign2;
            result = FPZero('N, sign)
        } else {
            result = FPRound__1('N, value_name, fpcr)
        }
    } else ();
    return(result)
}

val FPMaxNum : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMaxNum (op1__arg, op2__arg, fpcr) = {
    op1 : bits('N) = op1__arg;
    op2 : bits('N) = op2__arg;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, __ignore_4, __ignore_5) = FPUnpack(op1, fpcr);
    (type2, __ignore_6, __ignore_7) = FPUnpack(op2, fpcr);
    if type1 == FPType_QNaN & type2 != FPType_QNaN then {
        op1 = FPInfinity('N, 0b1)
    } else if type1 != FPType_QNaN & type2 == FPType_QNaN then {
        op2 = FPInfinity('N, 0b1)
    } else ();
    return(FPMax(op1, op2, fpcr))
}

val FPMin : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMin (op1, op2, fpcr) = {
    done : bool = undefined;
    fptype : FPType = undefined;
    result : bits('N) = undefined;
    sign : bits(1) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value_name : real = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        if value1_name < value2_name then {
            (fptype, sign, value_name) = (type1, sign1, value1_name)
        } else {
            (fptype, sign, value_name) = (type2, sign2, value2_name)
        };
        if fptype == FPType_Infinity then {
            result = FPInfinity('N, sign)
        } else if fptype == FPType_Zero then {
            let sign : bits(1) = sign1 | sign2;
            result = FPZero('N, sign)
        } else {
            result = FPRound__1('N, value_name, fpcr)
        }
    } else ();
    return(result)
}

val FPMinNum : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMinNum (op1__arg, op2__arg, fpcr) = {
    op1 : bits('N) = op1__arg;
    op2 : bits('N) = op2__arg;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, __ignore_8, __ignore_9) = FPUnpack(op1, fpcr);
    (type2, __ignore_10, __ignore_11) = FPUnpack(op2, fpcr);
    if type1 == FPType_QNaN & type2 != FPType_QNaN then {
        op1 = FPInfinity('N, 0b0)
    } else if type1 != FPType_QNaN & type2 == FPType_QNaN then {
        op2 = FPInfinity('N, 0b0)
    } else ();
    return(FPMin(op1, op2, fpcr))
}

val FPMul : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMul (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPDefaultNaN('N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 | inf2 then {
            result = FPInfinity('N, EOR(sign1, sign2))
        } else if zero1 | zero2 then {
            result = FPZero('N, EOR(sign1, sign2))
        } else {
            result = FPRound__1('N, value1_name * value2_name, fpcr)
        }
    } else ();
    return(result)
}

val FPProcessNaNs3 : forall ('N : Int), 'N in {16, 32, 64}.
  (FPType, FPType, FPType, bits('N), bits('N), bits('N), bits(32)) -> (bool, bits('N)) effect {escape, rreg, undef, wreg}

function FPProcessNaNs3 (type1, type2, type3, op1, op2, op3, fpcr) = {
    done : bool = undefined;
    result : bits('N) = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    if type1 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else if type2 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type2, op2, fpcr)
    } else if type3 == FPType_SNaN then {
        done = true;
        result = FPProcessNaN(type3, op3, fpcr)
    } else if type1 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN(type1, op1, fpcr)
    } else if type2 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN(type2, op2, fpcr)
    } else if type3 == FPType_QNaN then {
        done = true;
        result = FPProcessNaN(type3, op3, fpcr)
    } else {
        done = false;
        result = Zeros()
    };
    return((done, result))
}

val FPMulAdd : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMulAdd (addend, op1, op2, fpcr) = {
    done : bool = undefined;
    infA : bool = undefined;
    infP : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    signA : bits(1) = undefined;
    signP : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    typeA : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    valueA_name : real = undefined;
    zeroA : bool = undefined;
    zeroP : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (typeA, signA, valueA_name) = FPUnpack(addend, fpcr);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    let inf1 : bool = type1 == FPType_Infinity;
    let zero1 : bool = type1 == FPType_Zero;
    let inf2 : bool = type2 == FPType_Infinity;
    let zero2 : bool = type2 == FPType_Zero;
    (done, result) = FPProcessNaNs3(typeA, type1, type2, addend, op1, op2, fpcr);
    if typeA == FPType_QNaN & (inf1 & zero2 | zero1 & inf2) then {
        result = FPDefaultNaN('N);
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else ();
    if not_bool(done) then {
        let infA : bool = typeA == FPType_Infinity;
        let zeroA : bool = typeA == FPType_Zero;
        let signP : bits(1) = EOR(sign1, sign2);
        let infP : bool = inf1 | inf2;
        let zeroP : bool = zero1 | zero2;
        if (inf1 & zero2 | zero1 & inf2) | (infA & infP) & signA != signP then {
            result = FPDefaultNaN('N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if infA & signA == 0b0 | infP & signP == 0b0 then {
            result = FPInfinity('N, 0b0)
        } else if infA & signA == 0b1 | infP & signP == 0b1 then {
            result = FPInfinity('N, 0b1)
        } else if (zeroA & zeroP) & signA == signP then {
            result = FPZero('N, signA)
        } else {
            let result_value : real = valueA_name + value1_name * value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                result = FPZero('N, result_sign)
            } else {
                result = FPRound__1('N, result_value, fpcr)
            }
        }
    } else ();
    return(result)
}

val FPTwo : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits(1)) -> bits('N) effect {escape}

function FPTwo (N, sign) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 1)) = 0b1 @ Zeros(E - 1);
    let frac : bits('F) = Zeros(F);
    return((sign @ exp) @ frac)
}

val FPMulX : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPMulX (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPTwo('N, EOR(sign1, sign2))
        } else if inf1 | inf2 then {
            result = FPInfinity('N, EOR(sign1, sign2))
        } else if zero1 | zero2 then {
            result = FPZero('N, EOR(sign1, sign2))
        } else {
            result = FPRound__1('N, value1_name * value2_name, fpcr)
        }
    } else ();
    return(result)
}

val FPNeg : forall ('N : Int), 'N in {16, 32, 64}.
  bits('N) -> bits('N) effect {escape}

function FPNeg op = {
    assert('N == 16 | 'N == 32 | 'N == 64);
    return(not_vec([op['N - 1]]) @ op['N - 2 .. 0])
}

val FPOnePointFive : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits(1)) -> bits('N) effect {escape}

function FPOnePointFive (N, sign) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - (E + 1);
    let exp : bits(1 + ('E - 1)) = 0b0 @ Ones(E - 1);
    let frac : bits(1 + ('F - 1)) = 0b1 @ Zeros(F - 1);
    return((sign @ exp) @ frac)
}

val FPRecipEstimate : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecipEstimate (operand, fpcr) = {
    estimate : int = undefined;
    exp : int = undefined;
    fptype : FPType = undefined;
    fraction : bits(52) = undefined;
    overflow_to_inf : bool = undefined;
    result : bits('N) = undefined;
    result_exp : int = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (fptype, sign, value_name) = FPUnpack(operand, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, operand, fpcr)
    } else if fptype == FPType_Infinity then {
        result = FPZero('N, sign)
    } else if fptype == FPType_Zero then {
        result = FPInfinity('N, sign);
        FPProcessException(FPExc_DivideByZero, fpcr)
    } else if ('N == 16 & Abs(value_name) < 2.0 ^ negate(16) | 'N == 32 & Abs(value_name) < 2.0 ^ negate(128)) | 'N == 64 & Abs(value_name) < 2.0 ^ negate(1024) then {
        match FPRoundingMode(fpcr) {
          FPRounding_TIEEVEN => {
              overflow_to_inf = true
          },
          FPRounding_POSINF => {
              overflow_to_inf = sign == 0b0
          },
          FPRounding_NEGINF => {
              overflow_to_inf = sign == 0b1
          },
          FPRounding_ZERO => {
              overflow_to_inf = false
          },
          _ => ()
        };
        result = if overflow_to_inf then FPInfinity('N, sign) else FPMaxNormal('N, sign);
        FPProcessException(FPExc_Overflow, fpcr);
        FPProcessException(FPExc_Inexact, fpcr)
    } else if ([fpcr[24]] == 0b1 & 'N != 16 | [fpcr[19]] == 0b1 & 'N == 16) & (('N == 16 & Abs(value_name) >= 2.0 ^ 14 | 'N == 32 & Abs(value_name) >= 2.0 ^ 126) | 'N == 64 & Abs(value_name) >= 2.0 ^ 1022) then {
        result = FPZero('N, sign);
        FPSR = SetSlice(1, FPSR, 3, 0b1)
    } else {
        match 'N {
          16 => {
              fraction = operand[9 .. 0] @ Zeros(42);
              exp = UInt(operand[14 .. 10])
          },
          32 => {
              fraction = operand[22 .. 0] @ Zeros(29);
              exp = UInt(operand[30 .. 23])
          },
          64 => {
              fraction = operand[51 .. 0];
              exp = UInt(operand[62 .. 52])
          },
          _ => ()
        };
        if exp == 0 then {
            if [fraction[51]] == 0b0 then {
                exp = negate(1);
                fraction = fraction[49 .. 0] @ 0b00
            } else {
                fraction = fraction[50 .. 0] @ 0b0
            }
        } else ();
        let 'exp = exp;
        let 'scaled = UInt(0b1 @ fraction[51 .. 44]);
        match 'N {
          16 => {
              result_exp = 29 - exp
          },
          32 => {
              result_exp = 253 - exp
          },
          64 => {
              result_exp = 2045 - exp
          },
          _ => ()
        };
        let 'estimate = RecipEstimate(scaled);
        fraction : bits(52) = estimate[7 .. 0] @ Zeros(44);
        if result_exp == 0 then {
            fraction = 0b1 @ fraction[51 .. 1]
        } else if result_exp == negate(1) then {
            fraction = 0b01 @ fraction[51 .. 2];
            result_exp = 0
        } else ();
        let 'result_exp = result_exp;
        match 'N {
          16 => {
              result = (sign @ result_exp['N - 12 .. 0]) @ fraction[51 .. 42]
          },
          32 => {
              result = (sign @ result_exp['N - 25 .. 0]) @ fraction[51 .. 29]
          },
          64 => {
              result = (sign @ result_exp['N - 54 .. 0]) @ fraction[51 .. 0]
          },
          _ => ()
        }
    };
    return(result)
}

val FPRecpX : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecpX (N, op, fpcr) = {
    esize : {|5, 8, 11|} = 5;
    fptype : FPType = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    match 'N {
      16 => {
          esize = 5
      },
      32 => {
          esize = 8
      },
      64 => {
          esize = 11
      }
    };
    let 'esize = esize;
    result : bits('N) = undefined;
    exp : bits('esize) = undefined;
    let frac : bits('N - ('esize + 1)) = Zeros();
    match 'N {
      16 => {
          assert(constraint((10 <= 10 + '_esize - 1 & 10 + '_esize - 1 < 'N | not('N == 16))));
          exp = op[10 + esize - 1 .. 10]
      },
      32 => {
          assert(constraint((23 <= 23 + '_esize - 1 & 23 + '_esize - 1 < 'N | not('N == 32))));
          exp = op[23 + esize - 1 .. 23]
      },
      64 => {
          exp = op[52 + esize - 1 .. 52]
      }
    };
    let exp = exp;
    let max_exp : bits('esize) = Ones(esize) - 1;
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, op, fpcr)
    } else {
        if IsZero(exp) then {
            result = (sign @ max_exp) @ frac
        } else {
            result = (sign @ not_vec(exp)) @ frac
        }
    };
    return(result)
}

val FPRoundInt : forall 'N ('exact : Bool),
  'N in {16, 32, 64}.
  (bits('N), bits(32), FPRounding, bool('exact)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRoundInt (op, fpcr, rounding, exact) = {
    error : real = undefined;
    fptype : FPType = undefined;
    int_result : int = undefined;
    real_result : real = undefined;
    result : bits('N) = undefined;
    round_up : bool = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert(rounding != FPRounding_ODD);
    assert('N == 16 | 'N == 32 | 'N == 64);
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, op, fpcr)
    } else if fptype == FPType_Infinity then {
        result = FPInfinity('N, sign)
    } else if fptype == FPType_Zero then {
        result = FPZero('N, sign)
    } else {
        int_result : int = RoundDown(value_name);
        let error : real = value_name - Real(int_result);
        match rounding {
          FPRounding_TIEEVEN => {
              round_up = error > 0.5 | error == 0.5 & [int_result[0]] == 0b1
          },
          FPRounding_POSINF => {
              round_up = error != 0.0
          },
          FPRounding_NEGINF => {
              round_up = false
          },
          FPRounding_ZERO => {
              round_up = error != 0.0 & int_result < 0
          },
          FPRounding_TIEAWAY => {
              round_up = error > 0.5 | error == 0.5 & int_result >= 0
          },
          _ => ()
        };
        if round_up then {
            int_result = int_result + 1
        } else ();
        let 'int_result = int_result;
        let real_result : real = Real(int_result);
        if real_result == 0.0 then {
            result = FPZero('N, sign)
        } else {
            result = FPRound('N, real_result, fpcr, FPRounding_ZERO)
        };
        if error != 0.0 & exact then {
            FPProcessException(FPExc_Inexact, fpcr)
        } else ()
    };
    return(result)
}

val FPRSqrtEstimate : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRSqrtEstimate (operand, fpcr) = {
    estimate : int = undefined;
    exp : int = undefined;
    fptype : FPType = undefined;
    fraction : bits(52) = undefined;
    result : bits('N) = undefined;
    result_exp : int = undefined;
    scaled : int = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (fptype, sign, value_name) = FPUnpack(operand, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, operand, fpcr)
    } else if fptype == FPType_Zero then {
        result = FPInfinity('N, sign);
        FPProcessException(FPExc_DivideByZero, fpcr)
    } else if sign == 0b1 then {
        result = FPDefaultNaN('N);
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else if fptype == FPType_Infinity then {
        result = FPZero('N, 0b0)
    } else {
        match 'N {
          16 => {
              fraction = operand[9 .. 0] @ Zeros(42);
              exp = UInt(operand[14 .. 10])
          },
          32 => {
              fraction = operand[22 .. 0] @ Zeros(29);
              exp = UInt(operand[30 .. 23])
          },
          64 => {
              fraction = operand[51 .. 0];
              exp = UInt(operand[62 .. 52])
          },
          _ => ()
        };
        if exp == 0 then {
            while [fraction[51]] == 0b0 do {
                fraction = fraction[50 .. 0] @ 0b0;
                exp = exp - 1
            };
            fraction = fraction[50 .. 0] @ 0b0
        } else ();
        let 'exp = exp;
        if [exp[0]] == 0b0 then {
            scaled = UInt(0b1 @ fraction[51 .. 44])
        } else {
            scaled = UInt(0b01 @ fraction[51 .. 45])
        };
        let 'scaled = scaled;
        match 'N {
          16 => {
              result_exp = DIV(44 - exp, 2)
          },
          32 => {
              result_exp = DIV(380 - exp, 2)
          },
          64 => {
              result_exp = DIV(3068 - exp, 2)
          },
          _ => ()
        };
        let 'result_exp = result_exp;
        let 'estimate = RecipSqrtEstimate(scaled);
        match 'N {
          16 => {
              result = ((0b0 @ result_exp['N - 12 .. 0]) @ estimate[7 .. 0]) @ Zeros(2)
          },
          32 => {
              result = ((0b0 @ result_exp['N - 25 .. 0]) @ estimate[7 .. 0]) @ Zeros(15)
          },
          64 => {
              result = ((0b0 @ result_exp['N - 54 .. 0]) @ estimate[7 .. 0]) @ Zeros(44)
          },
          _ => ()
        }
    };
    return(result)
}

val FPSqrt : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPSqrt (op, fpcr) = {
    fptype : FPType = undefined;
    result : bits('N) = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        result = FPProcessNaN(fptype, op, fpcr)
    } else if fptype == FPType_Zero then {
        result = FPZero('N, sign)
    } else if fptype == FPType_Infinity & sign == 0b0 then {
        result = FPInfinity('N, sign)
    } else if sign == 0b1 then {
        result = FPDefaultNaN('N);
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else {
        result = FPRound__1('N, sqrt(value_name), fpcr)
    };
    return(result)
}

val FPSub : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N), bits(32)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPSub (op1, op2, fpcr) = {
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result : bits('N) = undefined;
    result_sign : bits(1) = undefined;
    result_value : real = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    let rounding : FPRounding = FPRoundingMode(fpcr);
    (type1, sign1, value1_name) = FPUnpack(op1, fpcr);
    (type2, sign2, value2_name) = FPUnpack(op2, fpcr);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, fpcr);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if (inf1 & inf2) & sign1 == sign2 then {
            result = FPDefaultNaN('N);
            FPProcessException(FPExc_InvalidOp, fpcr)
        } else if inf1 & sign1 == 0b0 | inf2 & sign2 == 0b1 then {
            result = FPInfinity('N, 0b0)
        } else if inf1 & sign1 == 0b1 | inf2 & sign2 == 0b0 then {
            result = FPInfinity('N, 0b1)
        } else if (zero1 & zero2) & sign1 == not_vec(sign2) then {
            result = FPZero('N, sign1)
        } else {
            let result_value : real = value1_name - value2_name;
            if result_value == 0.0 then {
                let result_sign : bits(1) = if rounding == FPRounding_NEGINF then 0b1 else 0b0;
                result = FPZero('N, result_sign)
            } else {
                result = FPRound('N, result_value, fpcr, rounding)
            }
        }
    } else ();
    return(result)
}

val FPToFixed : forall 'M 'N 'fbits ('is_unsigned : Bool),
  ('N in {16, 32, 64} & 'M in {16, 32, 64}).
  (implicit('M), bits('N), int('fbits), bool('is_unsigned), bits(32), FPRounding) -> bits('M) effect {escape, rreg, undef, wreg}

function FPToFixed (M, op, fbits, is_unsigned, fpcr, rounding) = {
    fptype : FPType = undefined;
    overflow : bool = undefined;
    result : bits('M) = undefined;
    round_up : bool = undefined;
    sign : bits(1) = undefined;
    value_name : real = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    assert(M == 16 | M == 32 | M == 64);
    assert(fbits >= 0);
    assert(rounding != FPRounding_ODD);
    (fptype, sign, value_name) = FPUnpack(op, fpcr);
    if fptype == FPType_SNaN | fptype == FPType_QNaN then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else ();
    let value_name : real = value_name * 2.0 ^ fbits;
    int_result : int = RoundDown(value_name);
    let error : real = value_name - Real(int_result);
    match rounding {
      FPRounding_TIEEVEN => {
          round_up = error > 0.5 | error == 0.5 & [int_result[0]] == 0b1
      },
      FPRounding_POSINF => {
          round_up = error != 0.0
      },
      FPRounding_NEGINF => {
          round_up = false
      },
      FPRounding_ZERO => {
          round_up = error != 0.0 & int_result < 0
      },
      FPRounding_TIEAWAY => {
          round_up = error > 0.5 | error == 0.5 & int_result >= 0
      },
      _ => ()
    };
    if round_up then {
        int_result = int_result + 1
    } else ();
    let 'int_result = int_result;
    (result, overflow) = SatQ(int_result, M, is_unsigned);
    if overflow then {
        FPProcessException(FPExc_InvalidOp, fpcr)
    } else if error != 0.0 then {
        FPProcessException(FPExc_Inexact, fpcr)
    } else ();
    return(result)
}

val VFPExpandImm : forall ('N : Int), 'N in {16, 32, 64}.
  (implicit('N), bits(8)) -> bits('N) effect {escape}

function VFPExpandImm (N, imm8) = {
    assert(N == 16 | N == 32 | N == 64);
    let 'E = if N == 16 then 5 else if N == 32 then 8 else 11;
    let 'F = N - E - 1;
    let sign : bits(1) = [imm8[7]];
    let exp : bits(1 + ('E - 3) + 2) = (not_vec([imm8[6]]) @ Replicate([imm8[6]], E - 3)) @ imm8[5 .. 4];
    let frac : bits(4 + ('F - 4)) = imm8[3 .. 0] @ Zeros(F - 4);
    return((sign @ exp) @ frac)
}

val BranchXToCapability : (bits(129), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BranchXToCapability (target__arg, branch_type) = {
    target : bits(129) = target__arg;
    PSTATE.C64 = [target[0]];
    target[0] = Bit(0b0);
    BranchToCapability(target, branch_type)
}

val CapUnsignedGreaterThanOrEqual : forall ('N : Int).
  (bits('N), bits('N)) -> bool

function CapUnsignedGreaterThanOrEqual (a, b) = {
    return(UInt(a) >= UInt(b))
}

val CapIsRepresentableFast : (bits(129), bits(CAP_VALUE_NUM_BITS)) -> bool effect {undef}

function CapIsRepresentableFast (c, increment_name__arg) = {
    increment_name : bits(CAP_VALUE_NUM_BITS) = increment_name__arg;
    B3 : bits(0 + (CAP_MW - 1 - (CAP_MW - 3) + 1)) = undefined;
    R : bits(16) = undefined;
    R3 : bits(3) = undefined;
    a_mid : bits(0 + (CAP_MW - 1 - 0 + 1)) = undefined;
    diff : bits(16) = undefined;
    diff1 : bits(16) = undefined;
    i_mid : bits(0 + (CAP_MW - 1 - 0 + 1)) = undefined;
    i_top : bits(64) = undefined;
    let 'exp = CapGetExponent(c);
    if exp >= CAP_MAX_EXPONENT - 2 then {
        return(true)
    } else {
        a : bits(CAP_VALUE_NUM_BITS) = CapGetValue(c);
        let a : bits(CAP_VALUE_NUM_BITS) = CapBoundsAddress(a);
        let increment_name : bits(CAP_VALUE_NUM_BITS) = CapBoundsAddress(increment_name);
        let i_top : bits(64) = ASR(increment_name, exp + CAP_MW);
        let i_mid : bits(0 + (CAP_MW - 1 - 0 + 1)) = LSR(increment_name, exp)[CAP_MW - 1 .. 0];
        let a_mid : bits(0 + (CAP_MW - 1 - 0 + 1)) = LSR(a, exp)[CAP_MW - 1 .. 0];
        let B3 : bits(0 + (CAP_MW - 1 - (CAP_MW - 3) + 1)) = CapGetBottom(c)[CAP_MW - 1 .. CAP_MW - 3];
        let R3 : bits(3) = B3 - 0b001;
        let R : bits(16) = R3 @ Zeros(CAP_MW - 3);
        let diff : bits(16) = R - a_mid;
        let diff1 : bits(16) = diff - 1;
        if i_top == 0 then {
            return(CapUnsignedLessThan(i_mid, diff1))
        } else if i_top == Ones(CAP_VALUE_NUM_BITS) then {
            return(CapUnsignedGreaterThanOrEqual(i_mid, diff) & R != a_mid)
        } else {
            return(false)
        }
    }
}

val CapAdd : (bits(129), bits(CAP_VALUE_NUM_BITS)) -> bits(129) effect {undef}

val CapAdd__1 : forall ('increment_name : Int).
  (bits(129), int('increment_name)) -> bits(129) effect {undef}

function CapAdd (c, increment_name) = {
    newc : bits(129) = c;
    newc[CAP_VALUE_HI_BIT .. CAP_VALUE_LO_BIT] = CapGetValue(c) + increment_name;
    if not_bool(CapIsRepresentableFast(c, increment_name)) then {
        newc[CAP_TAG_BIT] = Bit(0b0)
    } else ();
    if CapIsExponentOutOfRange(c) then {
        newc[CAP_TAG_BIT] = Bit(0b0)
    } else ();
    if CapBoundsUsesValue(CapGetExponent(c)) & [CapGetValue(c)[CAP_FLAGS_LO_BIT - 1]] != [CapGetValue(newc)[CAP_FLAGS_LO_BIT - 1]] then {
        newc[CAP_TAG_BIT] = Bit(0b0)
    } else ();
    return(newc)
}

function CapAdd__1 (c, increment_name) = {
    return(CapAdd(c, increment_name[CAP_VALUE_NUM_BITS - 1 .. 0]))
}

val BranchToOffset : (bits(64), BranchType) -> unit effect {escape, rreg, undef, wreg}

function BranchToOffset (offset, branch_type) = {
    Hint_Branch(branch_type);
    assert(not_bool(UsingAArch32()));
    let new_pcc : bits(129) = CapAdd(PCC, offset);
    PCC = BranchAddr(new_pcc, PSTATE.EL);
    _PC = CapGetValue(PCC);
    __BranchTaken = true;
    return()
}

val NextInstrAddr : forall ('N : Int), 'N > 0. int('N) -> bits('N)

val ResetExternalDebugRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

val SPSR_read : unit -> bits(32) effect {escape, rreg, undef}

function SPSR_read () = {
    result : bits(32) = undefined;
    match PSTATE.EL {
      ? if ? == EL1 => {
          result = SPSR_EL1
      },
      ? if ? == EL2 => {
          result = SPSR_EL2
      },
      ? if ? == EL3 => {
          result = SPSR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(result)
}

val IsFault : AddressDescriptor -> bool

function IsFault addrdesc = {
    return(addrdesc.fault.statuscode != Fault_None)
}

val IPAValid : FaultRecord -> bool effect {escape}

function IPAValid fault = {
    assert(fault.statuscode != Fault_None);
    if fault.s2fs1walk then {
        return(fault.statuscode == Fault_AccessFlag | fault.statuscode == Fault_Permission | fault.statuscode == Fault_Translation | fault.statuscode == Fault_AddressSize)
    } else if fault.secondstage then {
        return(fault.statuscode == Fault_AccessFlag | fault.statuscode == Fault_Translation | fault.statuscode == Fault_AddressSize)
    } else {
        return(false)
    }
}

val IsExternalAbort : Fault -> bool effect {escape}

val IsExternalAbort__1 : FaultRecord -> bool effect {escape}

function IsExternalAbort statuscode = {
    assert(statuscode != Fault_None);
    return(statuscode == Fault_SyncExternal | statuscode == Fault_SyncParity | statuscode == Fault_SyncExternalOnWalk | statuscode == Fault_SyncParityOnWalk | statuscode == Fault_AsyncExternal | statuscode == Fault_AsyncParity)
}

function IsExternalAbort__1 fault = {
    return(IsExternalAbort(fault.statuscode))
}

val IsExternalSyncAbort : Fault -> bool effect {escape}

val IsExternalSyncAbort__1 : FaultRecord -> bool effect {escape}

function IsExternalSyncAbort statuscode = {
    assert(statuscode != Fault_None);
    return(statuscode == Fault_SyncExternal | statuscode == Fault_SyncParity | statuscode == Fault_SyncExternalOnWalk | statuscode == Fault_SyncParityOnWalk)
}

function IsExternalSyncAbort__1 fault = {
    return(IsExternalSyncAbort(fault.statuscode))
}

val IsDebugException : FaultRecord -> bool effect {escape}

function IsDebugException fault = {
    assert(fault.statuscode != Fault_None);
    return(fault.statuscode == Fault_Debug)
}

val IsSecondStage : FaultRecord -> bool effect {escape}

function IsSecondStage fault = {
    assert(fault.statuscode != Fault_None);
    return(fault.secondstage)
}

val EncodeLDFSC : forall ('level : Int).
  (Fault, int('level)) -> bits(6) effect {escape, undef}

function EncodeLDFSC (statuscode, level) = {
    result : bits(6) = undefined;
    match statuscode {
      Fault_AddressSize => {
          result = 0b0000 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_AccessFlag => {
          result = 0b0010 @ level[1 .. 0];
          assert(level == 1 | level == 2 | level == 3)
      },
      Fault_Permission => {
          result = 0b0011 @ level[1 .. 0];
          assert(level == 1 | level == 2 | level == 3)
      },
      Fault_Translation => {
          result = 0b0001 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_SyncExternal => {
          result = 0b010000
      },
      Fault_SyncExternalOnWalk => {
          result = 0b0101 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_SyncParity => {
          result = 0b011000
      },
      Fault_SyncParityOnWalk => {
          result = 0b0111 @ level[1 .. 0];
          assert(level == 0 | level == 1 | level == 2 | level == 3)
      },
      Fault_AsyncParity => {
          result = 0b011001
      },
      Fault_AsyncExternal => {
          result = 0b010001
      },
      Fault_Alignment => {
          result = 0b100001
      },
      Fault_Debug => {
          result = 0b100010
      },
      Fault_TLBConflict => {
          result = 0b110000
      },
      Fault_HWUpdateAccessFlag => {
          result = 0b110001
      },
      Fault_CapTag => {
          result = 0b101000
      },
      Fault_CapSeal => {
          result = 0b101001
      },
      Fault_CapBounds => {
          result = 0b101010
      },
      Fault_CapPerm => {
          result = 0b101011
      },
      Fault_CapPagePerm => {
          result = 0b101100
      },
      Fault_Lockdown => {
          result = 0b110100
      },
      Fault_Exclusive => {
          result = 0b110101
      },
      _ => {
          Unreachable()
      }
    };
    return(result)
}

val LSInstructionSyndrome : unit -> bits(11)

val HaveAtomicExt : unit -> bool

function HaveAtomicExt () = {
    return(HasArchVersion(ARMv8p1))
}

val AArch64_HaveHPDExt : unit -> bool

function AArch64_HaveHPDExt () = {
    return(HasArchVersion(ARMv8p1))
}

val HaveQRDMLAHExt : unit -> bool

function HaveQRDMLAHExt () = {
    return(HasArchVersion(ARMv8p1))
}

val HaveAccessFlagUpdateExt : unit -> bool

function HaveAccessFlagUpdateExt () = {
    return(HasArchVersion(ARMv8p1))
}

val HaveDirtyBitModifierExt : unit -> bool

function HaveDirtyBitModifierExt () = {
    return(HasArchVersion(ARMv8p1))
}

val HaveCommonNotPrivateTransExt : unit -> bool

function HaveCommonNotPrivateTransExt () = {
    return(HasArchVersion(ARMv8p2))
}

val HaveExtendedExecuteNeverExt : unit -> bool

function HaveExtendedExecuteNeverExt () = {
    return(HasArchVersion(ARMv8p2))
}

val Have52BitVAExt : unit -> bool

function Have52BitVAExt () = {
    return(HasArchVersion(ARMv8p2) & __IMPDEF_boolean("Has large 52-bit VA support"))
}

val HavePrivATExt : unit -> bool

function HavePrivATExt () = {
    return(HasArchVersion(ARMv8p2))
}

val HaveStatisticalProfiling : unit -> bool

function HaveStatisticalProfiling () = {
    return(HasArchVersion(ARMv8p2))
}

val HaveDOTPExt : unit -> bool

function HaveDOTPExt () = {
    return(HasArchVersion(ARMv8p2) & __IMPDEF_boolean("Has Dot Product extension"))
}

val HaveSBExt : unit -> bool

function HaveSBExt () = {
    return(__IMPDEF_boolean("Has SB extension"))
}

val TLBReset : unit -> unit

val TLBLookup : forall ('secondstage : Bool).
  (bits(64), bool('secondstage), AccType) -> TLBLine

val TLBCache : forall ('secondstage : Bool).
  (bits(64), bool('secondstage), AccType, TLBRecord) -> unit

val AArch64_UndefinedFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_UndefinedFault () = {
    let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & Slice(HCR_EL2, 27, 1) == 0b1;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val PAMax : unit -> int

function PAMax () = {
    return(__IMPDEF_integer("Maximum Physical Address Size"))
}

val Have16bitVMID : unit -> bool

function Have16bitVMID () = {
    return(HaveEL(EL2) & __IMPDEF_boolean("Has 16-bit VMID"))
}

val HasS2Translation : unit -> bool effect {escape, rreg, undef}

function HasS2Translation () = {
    return((EL2Enabled() & not_bool(IsInHost())) & (PSTATE.EL == EL0 | PSTATE.EL == EL1))
}

val MemAttrDefaults : MemoryAttributes -> MemoryAttributes effect {undef}

function MemAttrDefaults memattrs__arg = {
    memattrs : MemoryAttributes = memattrs__arg;
    if memattrs.memtype == MemType_Device then {
        memattrs.inner = __UNKNOWN_MemAttrHints();
        memattrs.outer = __UNKNOWN_MemAttrHints();
        memattrs.shareable = true;
        memattrs.outershareable = true
    } else {
        memattrs.device = __UNKNOWN_DeviceType();
        if memattrs.inner.attrs == MemAttr_NC & memattrs.outer.attrs == MemAttr_NC then {
            memattrs.shareable = true;
            memattrs.outershareable = true
        } else ()
    };
    memattrs.readtagzero = false;
    memattrs.writetagfault = false;
    memattrs.readtagfault = false;
    memattrs.readtagfaulttgen = __UNKNOWN_bits(1);
    memattrs.iss2writetagfault = false;
    return(memattrs)
}

val S1CacheDisabled : AccType -> bool effect {escape, rreg, undef}

function S1CacheDisabled acctype = {
    let enable : bits(1) = if acctype == AccType_IFETCH then [SCTLR_read__1()[12]] else [SCTLR_read__1()[2]];
    return(enable == 0b0)
}

val S2CacheDisabled : AccType -> bool effect {rreg}

function S2CacheDisabled acctype = {
    let disable : bits(1) = if acctype == AccType_IFETCH then Slice(HCR_EL2, 33, 1) else Slice(HCR_EL2, 32, 1);
    return(disable == 0b1)
}

val CombineS1S2LCSC : (MemoryAttributes, MemoryAttributes, MemoryAttributes) -> MemoryAttributes effect {escape}

function CombineS1S2LCSC (new_attr__arg, s1_attr, s2_attr) = {
    new_attr : MemoryAttributes = new_attr__arg;
    new_attr.readtagzero = s1_attr.readtagzero | s2_attr.readtagzero;
    new_attr.readtagfault = s1_attr.readtagfault & not_bool(s2_attr.readtagzero);
    new_attr.readtagfaulttgen = s1_attr.readtagfaulttgen;
    new_attr.writetagfault = s1_attr.writetagfault | s2_attr.writetagfault;
    assert(not_bool(s1_attr.iss2writetagfault));
    new_attr.iss2writetagfault = not_bool(s1_attr.writetagfault) & s2_attr.iss2writetagfault;
    return(new_attr)
}

val CombineS1S2Device : (DeviceType, DeviceType) -> DeviceType effect {undef}

function CombineS1S2Device (s1device, s2device) = {
    result : DeviceType = undefined;
    if s2device == DeviceType_nGnRnE | s1device == DeviceType_nGnRnE then {
        result = DeviceType_nGnRnE
    } else if s2device == DeviceType_nGnRE | s1device == DeviceType_nGnRE then {
        result = DeviceType_nGnRE
    } else if s2device == DeviceType_nGRE | s1device == DeviceType_nGRE then {
        result = DeviceType_nGRE
    } else {
        result = DeviceType_GRE
    };
    return(result)
}

val CombineS1S2AttrHints : (MemAttrHints, MemAttrHints) -> MemAttrHints effect {undef}

function CombineS1S2AttrHints (s1desc, s2desc) = {
    result : MemAttrHints = undefined;
    if s2desc.attrs == 0b01 | s1desc.attrs == 0b01 then {
        result.attrs = __UNKNOWN_bits(2)
    } else if s2desc.attrs == MemAttr_NC | s1desc.attrs == MemAttr_NC then {
        result.attrs = MemAttr_NC
    } else if s2desc.attrs == MemAttr_WT | s1desc.attrs == MemAttr_WT then {
        result.attrs = MemAttr_WT
    } else {
        result.attrs = MemAttr_WB
    };
    result.hints = s1desc.hints;
    result.transient = s1desc.transient;
    return(result)
}

val ShortConvertAttrsHints : forall ('secondstage : Bool).
  (bits(2), AccType, bool('secondstage)) -> MemAttrHints effect {escape, rreg, undef}

function ShortConvertAttrsHints (RGN, acctype, secondstage) = {
    result : MemAttrHints = undefined;
    if not_bool(secondstage) & S1CacheDisabled(acctype) | secondstage & S2CacheDisabled(acctype) then {
        result.attrs = MemAttr_NC;
        result.hints = MemHint_No
    } else {
        match RGN {
          0b00 => {
              result.attrs = MemAttr_NC;
              result.hints = MemHint_No
          },
          0b01 => {
              result.attrs = MemAttr_WB;
              result.hints = MemHint_RWA
          },
          0b10 => {
              result.attrs = MemAttr_WT;
              result.hints = MemHint_RA
          },
          0b11 => {
              result.attrs = MemAttr_WB;
              result.hints = MemHint_RA
          }
        }
    };
    result.transient = false;
    return(result)
}

val LongConvertAttrsHints : (bits(4), AccType) -> MemAttrHints effect {escape, rreg, undef}

function LongConvertAttrsHints (attrfield, acctype) = {
    assert(not_bool(IsZero(attrfield)));
    result : MemAttrHints = undefined;
    if S1CacheDisabled(acctype) then {
        result.attrs = MemAttr_NC;
        result.hints = MemHint_No
    } else {
        if attrfield[3 .. 2] == 0b00 then {
            result.attrs = MemAttr_WT;
            result.hints = attrfield[1 .. 0];
            result.transient = true
        } else if attrfield[3 .. 0] == 0b0100 then {
            result.attrs = MemAttr_NC;
            result.hints = MemHint_No;
            result.transient = false
        } else if attrfield[3 .. 2] == 0b01 then {
            result.attrs = MemAttr_WB;
            result.hints = attrfield[1 .. 0];
            result.transient = true
        } else {
            result.attrs = attrfield[3 .. 2];
            result.hints = attrfield[1 .. 0];
            result.transient = false
        }
    };
    return(result)
}

val S2ConvertAttrsHints : (bits(2), AccType) -> MemAttrHints effect {escape, undef}

function S2ConvertAttrsHints (attr, acctype) = {
    assert(not_bool(IsZero(attr)));
    result : MemAttrHints = undefined;
    match attr {
      0b01 => {
          result.attrs = MemAttr_NC;
          result.hints = MemHint_No
      },
      0b10 => {
          result.attrs = MemAttr_WT;
          result.hints = MemHint_RWA
      },
      0b11 => {
          result.attrs = MemAttr_WB;
          result.hints = MemHint_RWA
      },
      _ => ()
    };
    result.transient = false;
    return(result)
}

val S2AttrDecode : (bits(2), bits(4), AccType) -> MemoryAttributes effect {escape, undef}

function S2AttrDecode (SH, attr, acctype) = {
    memattrs : MemoryAttributes = undefined;
    if attr[3 .. 2] == 0b00 then {
        memattrs.memtype = MemType_Device;
        match attr[1 .. 0] {
          0b00 => {
              memattrs.device = DeviceType_nGnRnE
          },
          0b01 => {
              memattrs.device = DeviceType_nGnRE
          },
          0b10 => {
              memattrs.device = DeviceType_nGRE
          },
          0b11 => {
              memattrs.device = DeviceType_GRE
          }
        }
    } else if attr[1 .. 0] != 0b00 then {
        memattrs.memtype = MemType_Normal;
        memattrs.outer = S2ConvertAttrsHints(attr[3 .. 2], acctype);
        memattrs.inner = S2ConvertAttrsHints(attr[1 .. 0], acctype);
        memattrs.shareable = [SH[1]] == 0b1;
        memattrs.outershareable = SH == 0b10
    } else {
        memattrs = __UNKNOWN_MemoryAttributes()
    };
    return(MemAttrDefaults(memattrs))
}

val WalkAttrDecode : forall ('secondstage : Bool).
  (bits(2), bits(2), bits(2), bool('secondstage)) -> MemoryAttributes effect {escape, rreg, undef}

function WalkAttrDecode (SH, ORGN, IRGN, secondstage) = {
    memattrs : MemoryAttributes = undefined;
    let acctype : AccType = AccType_NORMAL;
    memattrs.memtype = MemType_Normal;
    memattrs.inner = ShortConvertAttrsHints(IRGN, acctype, secondstage);
    memattrs.outer = ShortConvertAttrsHints(ORGN, acctype, secondstage);
    memattrs.shareable = [SH[1]] == 0b1;
    memattrs.outershareable = SH == 0b10;
    return(MemAttrDefaults(memattrs))
}

val X_set : forall 'n 'width,
  'width in {32, 64}.
  (implicit('width), int('n), bits('width)) -> unit effect {escape, wreg}

function X_set (width, n, value_name) = {
    assert(n >= 0 & n <= 31);
    assert(width == 32 | width == 64);
    if n != 31 then {
        _R_set(n) = ZeroExtend(value_name)
    } else ();
    return()
}

val X_read : forall 'n 'width,
  'width in {8, 16, 32, 64}.
  (implicit('width), int('n)) -> bits('width) effect {escape, rreg}

function X_read (width, n) = {
    assert(n >= 0 & n <= 31);
    assert(width == 8 | width == 16 | width == 32 | width == 64);
    if n != 31 then {
        return(_R_read(n)[width - 1 .. 0])
    } else {
        return(Zeros(width))
    }
}

val C_set : forall ('n : Int).
  (int('n), bits(129)) -> unit effect {escape, wreg}

function C_set (n, value_name) = {
    assert(n >= 0 & n <= 31);
    if n != 31 then {
        _R_set(n) = ZeroExtend(value_name)
    } else ();
    return()
}

val CapNull : unit -> bits(129)

function CapNull () = {
    let c : bits(129) = Zeros(129);
    return(c)
}

val C_read : forall ('n : Int). int('n) -> bits(129) effect {escape, rreg}

function C_read n = {
    assert(n >= 0 & n <= 31);
    if n != 31 then {
        return(_R_read(n)[128 .. 0])
    } else {
        return(CapNull())
    }
}

register SP_EL3 : bits(129)

val SP_set : forall ('width : Int), 'width in {32, 64}.
  (implicit('width), bits('width)) -> unit effect {escape, rreg, wreg}

function SP_set (width, value_name) = {
    assert(width == 32 | width == 64);
    if IsInRestricted() then {
        RSP_EL0 = ZeroExtend(value_name)
    } else if PSTATE.SP == 0b0 then {
        SP_EL0 = ZeroExtend(value_name)
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              SP_EL0 = ZeroExtend(value_name)
          },
          ? if ? == EL1 => {
              SP_EL1 = ZeroExtend(value_name)
          },
          ? if ? == EL2 => {
              SP_EL2 = ZeroExtend(value_name)
          },
          ? if ? == EL3 => {
              SP_EL3 = ZeroExtend(value_name)
          },
          _ => ()
        }
    };
    return()
}

val SP_read : forall 'width,
  'width in {8, 16, 32, 64}.
  implicit('width) -> bits('width) effect {escape, rreg, undef}

function SP_read width = {
    assert(width == 8 | width == 16 | width == 32 | width == 64);
    if IsInRestricted() then {
        return(RSP_EL0[width - 1 .. 0])
    } else if PSTATE.SP == 0b0 then {
        return(SP_EL0[width - 1 .. 0])
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              return(SP_EL0[width - 1 .. 0])
          },
          ? if ? == EL1 => {
              return(SP_EL1[width - 1 .. 0])
          },
          ? if ? == EL2 => {
              return(SP_EL2[width - 1 .. 0])
          },
          ? if ? == EL3 => {
              return(SP_EL3[width - 1 .. 0])
          },
          _ => {
              return(undefined : bits('width))
          }
        }
    }
}

val CSP_set : bits(129) -> unit effect {rreg, wreg}

function CSP_set value_name = {
    if IsInRestricted() then {
        RSP_EL0 = value_name
    } else if PSTATE.SP == 0b0 then {
        SP_EL0 = value_name
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              SP_EL0 = value_name
          },
          ? if ? == EL1 => {
              SP_EL1 = value_name
          },
          ? if ? == EL2 => {
              SP_EL2 = value_name
          },
          ? if ? == EL3 => {
              SP_EL3 = value_name
          },
          _ => ()
        }
    };
    return()
}

val CSP_read : unit -> bits(129) effect {rreg, undef}

function CSP_read () = {
    if IsInRestricted() then {
        return(RSP_EL0)
    } else if PSTATE.SP == 0b0 then {
        return(SP_EL0)
    } else {
        match PSTATE.EL {
          ? if ? == EL0 => {
              return(SP_EL0)
          },
          ? if ? == EL1 => {
              return(SP_EL1)
          },
          ? if ? == EL2 => {
              return(SP_EL2)
          },
          ? if ? == EL3 => {
              return(SP_EL3)
          },
          _ => {
              return(undefined : bits(129))
          }
        }
    }
}

val V_set : forall 'n 'width,
  'width in {8, 16, 32, 64, 128}.
  (implicit('width), int('n), bits('width)) -> unit effect {escape, wreg}

function V_set (width, n, value_name) = {
    assert(n >= 0 & n <= 31);
    assert(width == 8 | width == 16 | width == 32 | width == 64 | width == 128);
    _V[n] = ZeroExtend(value_name);
    return()
}

val V_read : forall 'n 'width,
  'width in {8, 16, 32, 64, 128}.
  (implicit('width), int('n)) -> bits('width) effect {escape, rreg}

function V_read (width, n) = {
    assert(n >= 0 & n <= 31);
    assert(width == 8 | width == 16 | width == 32 | width == 64 | width == 128);
    return(_V[n][width - 1 .. 0])
}

val Vpart_read : forall ('n 'part 'width : Int).
  (implicit('width), int('n), int('part)) -> bits('width) effect {escape, rreg}

function Vpart_read (width, n, part) = {
    assert(n >= 0 & n <= 31);
    assert(part == 0 | part == 1);
    if part == 0 then {
        assert(width == 8 | width == 16 | width == 32 | width == 64);
        return(_V[n][width - 1 .. 0])
    } else {
        assert(width == 32 | width == 64);
        return(_V[n][width * 2 - 1 .. width])
    }
}

val Vpart_set : forall ('n 'part 'width : Int).
  (implicit('width), int('n), int('part), bits('width)) -> unit effect {escape, wreg}

function Vpart_set (width, n, part, value_name) = {
    assert(n >= 0 & n <= 31);
    assert(part == 0 | part == 1);
    if part == 0 then {
        assert(width == 8 | width == 16 | width == 32 | width == 64);
        _V[n] = ZeroExtend(value_name)
    } else {
        assert(width == 64);
        _V[n][width * 2 - 1 .. width] = value_name[width - 1 .. 0]
    }
}

val PC_read : unit -> bits(64) effect {rreg}

function PC_read () = {
    return(CapGetValue(PCC))
}

val AArch64_SPAlignmentFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_SPAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_SPAlignment);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else if EL2Enabled() & Slice(HCR_EL2, 27, 1) == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val CheckSPAlignment : unit -> unit effect {escape, rreg, undef, wreg}

function CheckSPAlignment () = {
    stack_align_check : bool = undefined;
    let sp : bits(64) = SP_read(64);
    if PSTATE.EL == EL0 then {
        stack_align_check = [SCTLR_read__1()[4]] != 0b0
    } else {
        stack_align_check = [SCTLR_read__1()[3]] != 0b0
    };
    if stack_align_check & sp != Align(sp, 16) then {
        AArch64_SPAlignmentFault()
    } else ();
    return()
}

val IsInC64 : unit -> bool effect {rreg}

function IsInC64 () = {
    return(PSTATE.C64 == 0b1)
}

val VAFromBits64 : bits(64) -> VirtualAddress effect {undef}

function VAFromBits64 b = {
    v : VirtualAddress = undefined;
    v.vatype = VA_Bits64;
    v.offset = b;
    return(v)
}

val VAFromCapability : bits(129) -> VirtualAddress effect {undef}

function VAFromCapability c = {
    v : VirtualAddress = undefined;
    v.vatype = VA_Capability;
    v.base = c;
    return(v)
}

val BaseReg_read : forall ('is_prefetch : Bool)('n : Int).
  (int('n), bool('is_prefetch)) -> VirtualAddress effect {escape, rreg, undef, wreg}

val BaseReg_read__1 : forall ('n : Int).
  int('n) -> VirtualAddress effect {escape, rreg, undef, wreg}

function BaseReg_read (n, is_prefetch) = {
    if not_bool(IsInC64()) then {
        address : bits(64) = undefined;
        if n == 31 then {
            if not_bool(is_prefetch) then {
                CheckSPAlignment()
            } else ();
            address = SP_read(64)
        } else {
            address = X_read(64, n)
        };
        return(VAFromBits64(address))
    } else {
        address : bits(129) = undefined;
        if n == 31 then {
            if not_bool(is_prefetch) then {
                CheckSPAlignment()
            } else ();
            address = CSP_read()
        } else {
            address = C_read(n)
        };
        return(VAFromCapability(address))
    }
}

function BaseReg_read__1 n = {
    return(BaseReg_read(n, false))
}

val AltBaseReg_read : forall ('is_prefetch : Bool)('n : Int).
  (int('n), bool('is_prefetch)) -> VirtualAddress effect {escape, rreg, undef, wreg}

val AltBaseReg_read__1 : forall ('n : Int).
  int('n) -> VirtualAddress effect {escape, rreg, undef, wreg}

function AltBaseReg_read (n, is_prefetch) = {
    if not_bool(IsInC64()) then {
        address : bits(129) = undefined;
        if n == 31 then {
            if not_bool(is_prefetch) then {
                CheckSPAlignment()
            } else ();
            address = CSP_read()
        } else {
            address = C_read(n)
        };
        return(VAFromCapability(address))
    } else {
        address : bits(64) = undefined;
        if n == 31 then {
            if not_bool(is_prefetch) then {
                CheckSPAlignment()
            } else ();
            address = SP_read(64)
        } else {
            address = X_read(64, n)
        };
        return(VAFromBits64(address))
    }
}

function AltBaseReg_read__1 n = {
    return(AltBaseReg_read(n, false))
}

val VAIsBits64 : VirtualAddress -> bool

function VAIsBits64 v = {
    return(v.vatype == VA_Bits64)
}

val VAToBits64 : VirtualAddress -> bits(64) effect {escape}

function VAToBits64 v = {
    assert(VAIsBits64(v));
    return(v.offset)
}

val VAIsCapability : VirtualAddress -> bool

function VAIsCapability v = {
    return(v.vatype == VA_Capability)
}

val VAToCapability : VirtualAddress -> bits(129) effect {escape}

function VAToCapability v = {
    assert(VAIsCapability(v));
    return(v.base)
}

val BaseReg_set : forall ('n : Int).
  (int('n), VirtualAddress) -> unit effect {escape, rreg, wreg}

function BaseReg_set (n, address) = {
    if not_bool(IsInC64()) then {
        if n == 31 then {
            SP_set(64) = VAToBits64(address)
        } else {
            X_set(64, n) = VAToBits64(address)
        }
    } else {
        if n == 31 then {
            CSP_set() = VAToCapability(address)
        } else {
            C_set(n) = VAToCapability(address)
        }
    }
}

val AArch64_ResetGeneralRegisters : unit -> unit effect {escape, wreg}

function AArch64_ResetGeneralRegisters () = {
    foreach (i from 0 to 30 by 1 in inc) {
        C_set(i) = CapNull()
    };
    return()
}

val AArch64_ResetSIMDFPRegisters : unit -> unit effect {escape, wreg}

function AArch64_ResetSIMDFPRegisters () = {
    foreach (i from 0 to 31 by 1 in inc) {
        V_set(128, i) = __UNKNOWN_bits(128)
    };
    return()
}

val AArch64_ResetSpecialRegisters : unit -> unit effect {wreg}

function AArch64_ResetSpecialRegisters () = {
    SP_EL0 = __UNKNOWN_bits(129);
    SP_EL1 = __UNKNOWN_bits(129);
    ELR_EL1 = __UNKNOWN_bits(129);
    SPSR_EL1 = __UNKNOWN_bits(32);
    if HaveEL(EL2) then {
        SP_EL2 = __UNKNOWN_bits(129);
        ELR_EL2 = __UNKNOWN_bits(129);
        SPSR_EL2 = __UNKNOWN_bits(32)
    } else ();
    if HaveEL(EL3) then {
        SP_EL3 = __UNKNOWN_bits(129);
        ELR_EL3 = __UNKNOWN_bits(129);
        SPSR_EL3 = __UNKNOWN_bits(32)
    } else ();
    if HaveAArch32EL(EL1) then {
        SPSR_fiq = __UNKNOWN_bits(32);
        SPSR_irq = __UNKNOWN_bits(32);
        SPSR_abt = __UNKNOWN_bits(32);
        SPSR_und = __UNKNOWN_bits(32)
    } else ();
    DSPSR_EL0 = __UNKNOWN_bits(32);
    CDLR_EL0 = __UNKNOWN_bits(129);
    return()
}

val FAR_read : bits(2) -> bits(64) effect {escape, rreg, undef}

val FAR_read__1 : unit -> bits(64) effect {escape, rreg, undef}

function FAR_read regime = {
    r : bits(64) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = FAR_EL1
      },
      ? if ? == EL2 => {
          r = FAR_EL2
      },
      ? if ? == EL3 => {
          r = FAR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function FAR_read__1 () = {
    return(FAR_read(S1TranslationRegime__1()))
}

val ELR_read : bits(2) -> bits(64) effect {escape, rreg, undef}

val ELR_read__1 : unit -> bits(64) effect {escape, rreg, undef}

function ELR_read el = {
    r : bits(64) = undefined;
    match el {
      ? if ? == EL1 => {
          r = ELR_EL1[63 .. 0]
      },
      ? if ? == EL2 => {
          r = ELR_EL2[63 .. 0]
      },
      ? if ? == EL3 => {
          r = ELR_EL3[63 .. 0]
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function ELR_read__1 () = {
    assert(PSTATE.EL != EL0);
    return(ELR_read(PSTATE.EL))
}

val CELR_read : bits(2) -> bits(129) effect {escape, rreg, undef}

val CELR_read__1 : unit -> bits(129) effect {escape, rreg, undef}

function CELR_read el = {
    r : bits(129) = undefined;
    match el {
      ? if ? == EL1 => {
          r = ELR_EL1
      },
      ? if ? == EL2 => {
          r = ELR_EL2
      },
      ? if ? == EL3 => {
          r = ELR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function CELR_read__1 () = {
    return(CELR_read(PSTATE.EL))
}

val ESR_read : bits(2) -> bits(32) effect {escape, rreg, undef}

val ESR_read__1 : unit -> bits(32) effect {escape, rreg, undef}

function ESR_read regime = {
    r : bits(32) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = ESR_EL1
      },
      ? if ? == EL2 => {
          r = ESR_EL2
      },
      ? if ? == EL3 => {
          r = ESR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function ESR_read__1 () = {
    return(ESR_read(S1TranslationRegime__1()))
}

val MAIR_read : bits(2) -> bits(64) effect {escape, rreg, undef}

val MAIR_read__1 : unit -> bits(64) effect {escape, rreg, undef}

function MAIR_read regime = {
    r : bits(64) = undefined;
    match regime {
      ? if ? == EL1 => {
          r = MAIR_EL1
      },
      ? if ? == EL2 => {
          r = MAIR_EL2
      },
      ? if ? == EL3 => {
          r = MAIR_EL3
      },
      _ => {
          Unreachable()
      }
    };
    return(r)
}

function MAIR_read__1 () = {
    return(MAIR_read(S1TranslationRegime__1()))
}

val CPACR_read : unit -> bits(32) effect {escape, rreg, undef}

function CPACR_read () = {
    r : bits(32) = undefined;
    if IsInHost() then {
        r = CPTR_EL2;
        return(r)
    } else ();
    let r : bits(32) = CPACR_EL1;
    return(r)
}

val AArch64_CheckSystemAccess : (bits(2), bits(3), bits(4), bits(4), bits(3), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckSystemAccess (op0, op1, crn, crm, op2, rt, read) = {
    rcs_el0_trap : bool = undefined;
    let unallocated : bool = false;
    need_secure : bool = false;
    min_EL : bits(2) = undefined;
    if ((((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & Slice(HCR_EL2, 20, 1) == 0b1) & (match op0 {
      [_, bitone] => true,
      _ => false
    }) : bool) & (match crn {
      [bitone, _, bitone, bitone] => true,
      _ => false
    }) : bool then {
        let rcs_el0_trap : bool = __IMPDEF_boolean("Reserved Control Space EL0 Trapped");
        if PSTATE.EL == EL1 | rcs_el0_trap then {
            AArch64_SystemAccessTrap(EL2, UInt(0x18))
        } else ()
    } else ();
    match op1 {
      [bitzero, bitzero, _] => {
          min_EL = EL1
      },
      0b010 => {
          min_EL = EL1
      },
      0b011 => {
          min_EL = EL0
      },
      0b100 => {
          min_EL = EL2
      },
      0b101 => {
          if not_bool(HaveVirtHostExt()) then {
              throw(Error_Undefined())
          } else ();
          min_EL = EL2
      },
      0b110 => {
          min_EL = EL3
      },
      0b111 => {
          min_EL = EL1;
          need_secure = true;
          if ((op0 == 0b11 & crn == 0b0100) & crm == 0b0001) & op2 == 0b011 then {
              min_EL = EL0;
              need_secure = false
          } else ()
      }
    };
    let min_EL = min_EL;
    if UInt(PSTATE.EL) < UInt(min_EL) then {
        throw(Error_Undefined())
    } else if need_secure & not_bool(IsSecure()) then {
        throw(Error_Undefined())
    } else ()
}

val AArch64_SysInstrWithCapability : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2), bits(129)) -> unit

val AArch64_SysInstrInputIsCapability : forall 'crm 'crn 'op0 'op1 'op2.
  (int('op0), int('op1), int('crn), int('crm), int('op2)) -> bool effect {rreg}

function AArch64_SysInstrInputIsCapability (op0, op1, crn, crm, op2) = {
    return(PSTATE.C64 == 0b1 & (((op0 == 1 & op1 == 0) & crn == 7) & crm == 6 | (((op0 == 1 & op1 == 3) & crn == 7) & (crm == 4 | crm == 5 | crm == 10 | crm == 11 | crm == 12 | crm == 13 | crm == 14)) & op2 == 1))
}

val AArch64_ExecutingATS1xPInstr : unit -> bool effect {undef}

function AArch64_ExecutingATS1xPInstr () = {
    CRm : bits(4) = undefined;
    CRn : bits(4) = undefined;
    op1 : bits(3) = undefined;
    op2 : bits(3) = undefined;
    if not_bool(HavePrivATExt()) then {
        return(false)
    } else ();
    let instr : bits(32) = ThisInstr();
    if Slice(instr, 22, 10) == 0b1101010100 then {
        let op1 : bits(3) = Slice(instr, 16, 3);
        let CRn : bits(4) = Slice(instr, 12, 4);
        let CRm : bits(4) = Slice(instr, 8, 4);
        let op2 : bits(3) = Slice(instr, 5, 3);
        return(((op1 == 0b000 & CRn == 0b0111) & CRm == 0b1001) & (op2 == 0b000 | op2 == 0b001))
    } else {
        return(false)
    }
}

val AArch64_CreateFaultRecord : forall 'level ('s2fs1walk : Bool) ('secondstage : Bool) ('write : Bool).
  (Fault, bits(48), int('level), AccType, bool('write), bits(1), bits(2), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_CreateFaultRecord (statuscode, ipaddress, level, acctype, write, extflag, errortype, secondstage, s2fs1walk) = {
    fault : FaultRecord = undefined;
    fault.statuscode = statuscode;
    fault.domain = __UNKNOWN_bits(4);
    fault.debugmoe = __UNKNOWN_bits(4);
    fault.errortype = errortype;
    fault.ipaddress = ipaddress;
    fault.level = level;
    fault.acctype = acctype;
    fault.write = write;
    fault.extflag = extflag;
    fault.secondstage = secondstage;
    fault.s2fs1walk = s2fs1walk;
    return(fault)
}

val AArch64_FaultSyndrome : forall ('d_side : Bool).
  (bool('d_side), FaultRecord) -> bits(25) effect {escape, undef}

function AArch64_FaultSyndrome (d_side, fault) = {
    assert(fault.statuscode != Fault_None);
    iss : bits(25) = Zeros();
    if HaveRASExt() & IsExternalSyncAbort__1(fault) then {
        iss[12 .. 11] = fault.errortype
    } else ();
    if d_side then {
        if IsSecondStage(fault) & not_bool(fault.s2fs1walk) then {
            iss[24 .. 14] = LSInstructionSyndrome()
        } else ();
        if fault.acctype == AccType_DC | fault.acctype == AccType_DC_UNPRIV | fault.acctype == AccType_IC | fault.acctype == AccType_AT then {
            iss[8] = Bit(0b1);
            iss[6] = Bit(0b1)
        } else {
            iss[6] = Bit(if fault.write then 0b1 else 0b0)
        }
    } else ();
    if IsExternalAbort__1(fault) then {
        iss[9] = Bit(fault.extflag)
    } else ();
    iss[7] = Bit(if fault.s2fs1walk then 0b1 else 0b0);
    iss[5 .. 0] = EncodeLDFSC(fault.statuscode, fault.level);
    return(iss)
}

val AArch64_AbortSyndrome : (Exception, FaultRecord, bits(64)) -> ExceptionRecord effect {escape, undef}

function AArch64_AbortSyndrome (exceptype, fault, vaddress) = {
    exception : ExceptionRecord = ExceptionSyndrome(exceptype);
    let d_side : bool = exceptype == Exception_DataAbort | exceptype == Exception_Watchpoint;
    exception.syndrome = AArch64_FaultSyndrome(d_side, fault);
    exception.vaddress = ZeroExtend(vaddress);
    if IPAValid(fault) then {
        exception.ipavalid = true;
        exception.ipaddress = fault.ipaddress
    } else {
        exception.ipavalid = false
    };
    return(exception)
}

val AArch64_BreakpointException : FaultRecord -> unit effect {escape, rreg, undef, wreg}

function AArch64_BreakpointException fault = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (Slice(HCR_EL2, 27, 1) == 0b1 | Slice(MDCR_EL2, 8, 1) == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let vaddress : bits(64) = __UNKNOWN_bits(64);
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_Breakpoint, fault, vaddress);
    if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_DataAbort : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_DataAbort (vaddress, fault) = {
    cap_target_el : bits(2) = undefined;
    if fault.statuscode == Fault_CapTag | fault.statuscode == Fault_CapSeal | fault.statuscode == Fault_CapPerm | fault.statuscode == Fault_CapBounds then {
        cap_target_el = TargetELForCapabilityExceptions()
    } else {
        cap_target_el = EL0
    };
    let route_to_el3 : bool = (HaveEL(EL3) & Slice(SCR_EL3, 3, 1) == 0b1) & IsExternalAbort__1(fault) | cap_target_el == EL3;
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (((Slice(HCR_EL2, 27, 1) == 0b1 | (HaveRASExt() & Slice(HCR_EL2, 37, 1) == 0b1) & IsExternalAbort__1(fault)) | cap_target_el == EL2) | IsSecondStage(fault));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_DataAbort, fault, vaddress);
    if PSTATE.EL == EL3 | route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_InstructionAbort : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_InstructionAbort (vaddress, fault) = {
    cap_target_el : bits(2) = undefined;
    if fault.statuscode == Fault_CapTag | fault.statuscode == Fault_CapSeal | fault.statuscode == Fault_CapPerm | fault.statuscode == Fault_CapBounds then {
        cap_target_el = TargetELForCapabilityExceptions()
    } else {
        cap_target_el = EL0
    };
    let route_to_el3 : bool = (HaveEL(EL3) & Slice(SCR_EL3, 3, 1) == 0b1) & IsExternalAbort__1(fault) | cap_target_el == EL3;
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & ((Slice(HCR_EL2, 27, 1) == 0b1 | IsSecondStage(fault)) | (HaveRASExt() & Slice(HCR_EL2, 37, 1) == 0b1) & IsExternalAbort__1(fault));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_InstructionAbort, fault, vaddress);
    if PSTATE.EL == EL3 | route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_WatchpointException : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_WatchpointException (vaddress, fault) = {
    assert(PSTATE.EL != EL3);
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (Slice(HCR_EL2, 27, 1) == 0b1 | Slice(MDCR_EL2, 8, 1) == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = AArch64_AbortSyndrome(Exception_Watchpoint, fault, vaddress);
    if PSTATE.EL == EL2 | route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_Abort : (bits(64), FaultRecord) -> unit effect {escape, rreg, undef, wreg}

function AArch64_Abort (vaddress, fault) = {
    if IsDebugException(fault) then {
        if fault.acctype == AccType_IFETCH then {
            AArch64_BreakpointException(fault)
        } else {
            AArch64_WatchpointException(vaddress, fault)
        }
    } else if fault.acctype == AccType_IFETCH then {
        AArch64_InstructionAbort(vaddress, fault)
    } else {
        AArch64_DataAbort(vaddress, fault)
    }
}

val AArch64_AlignmentFault : forall ('iswrite 'secondstage : Bool).
  (AccType, bool('iswrite), bool('secondstage)) -> FaultRecord effect {undef}

function AArch64_AlignmentFault (acctype, iswrite, secondstage) = {
    let ipaddress : bits(48) = __UNKNOWN_bits(48);
    let 'level = __UNKNOWN_integer();
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    let s2fs1walk : bool = __UNKNOWN_boolean();
    return(AArch64_CreateFaultRecord(Fault_Alignment, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val AArch64_CheckAlignment : forall ('alignment : Int)('iswrite : Bool).
  (bits(64), int('alignment), AccType, bool('iswrite)) -> bool effect {escape, rreg, undef, wreg}

function AArch64_CheckAlignment (address, alignment, acctype, iswrite) = {
    secondstage : bool = undefined;
    let aligned : bool = address == Align(address, alignment);
    let atomic : bool = acctype == AccType_ATOMIC | acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    let ordered : bool = acctype == AccType_ORDERED | acctype == AccType_ORDEREDRW | acctype == AccType_LIMITEDORDERED | acctype == AccType_ORDEREDATOMIC | acctype == AccType_ORDEREDATOMICRW;
    vector_name = acctype == AccType_VEC;
    let check : bool = (atomic | ordered) | [SCTLR_read__1()[1]] == 0b1;
    if check & not_bool(aligned) then {
        let secondstage : bool = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    } else ();
    return(aligned)
}

val AArch64_BreakpointValueMatch : forall ('linked_to : Bool)('n : Int).
  (int('n), bits(64), bool('linked_to)) -> bool effect {escape, rreg, undef}

function AArch64_BreakpointValueMatch (n__arg, vaddress, linked_to) = {
    n : int = n__arg;
    BVR_match : bool = undefined;
    BXVR_match : bool = undefined;
    bvr_vmid : bits(16) = undefined;
    byte : int = undefined;
    byte_select_match : bool = undefined;
    c : Constraint = undefined;
    top : int = undefined;
    vmid : bits(16) = undefined;
    if n > UInt(Slice(ID_AA64DFR0_EL1, 12, 4)) then {
        (c, n) = ConstrainUnpredictableInteger(0, UInt(Slice(ID_AA64DFR0_EL1, 12, 4)), Unpredictable_BPNOTIMPL);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return(false)
        } else ()
    } else ();
    let 'n = n;
    assert(constraint((0 <= 'n & 'n < 16)));
    if Slice(DBGBCR_EL1[n], 0, 1) == 0b0 then {
        return(false)
    } else ();
    let context_aware : bool = n >= UInt(Slice(ID_AA64DFR0_EL1, 12, 4)) - UInt(Slice(ID_AA64DFR0_EL1, 28, 4));
    dbgtype : bits(4) = Slice(DBGBCR_EL1[n], 20, 4);
    if (((match dbgtype {
      [bitzero, bitone, bitone, _] => true,
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool & not_bool(HaveVirtHostExt()) | (match dbgtype {
      [bitzero, bitone, bitzero, _] => true,
      _ => false
    }) : bool) | not_bool((match dbgtype {
      [bitzero, _, bitzero, _] => true,
      _ => false
    }) : bool) & not_bool(context_aware)) | (match dbgtype {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool & not_bool(HaveEL(EL2)) then {
        (c, dbgtype) = ConstrainUnpredictableBits(0 + 4, Unpredictable_RESBPTYPE);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return(false)
        } else ()
    } else ();
    let match_addr : bool = (match dbgtype {
      [bitzero, _, bitzero, _] => true,
      _ => false
    }) : bool;
    let match_vmid : bool = (match dbgtype {
      [bitone, bitzero, _, _] => true,
      _ => false
    }) : bool;
    let match_cid : bool = (match dbgtype {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool;
    let match_cid1 : bool = (match dbgtype {
      [bitone, bitzero, bitone, _] => true,
      [_, bitone, bitone, _] => true,
      _ => false
    }) : bool;
    let match_cid2 : bool = (match dbgtype {
      [bitone, bitone, _, _] => true,
      _ => false
    }) : bool;
    let linked : bool = (match dbgtype {
      [_, _, _, bitone] => true,
      _ => false
    }) : bool;
    if linked_to & (not_bool(linked) | match_addr) then {
        return(false)
    } else ();
    if (not_bool(linked_to) & linked) & not_bool(match_addr) then {
        return(false)
    } else ();
    if match_addr then {
        let 'byte = UInt(vaddress[1 .. 0]);
        if HaveAnyAArch32() then {
            assert(byte == 0 | byte == 2);
            byte_select_match = [Slice(DBGBCR_EL1[n], 5, 4)[byte]] == 0b1
        } else {
            assert(byte == 0);
            byte_select_match = true
        };
        let 'top = AddrTop(vaddress, PSTATE.EL);
        BVR_match = vaddress[top .. 2] == DBGBVR_EL1[n][top .. 2] & byte_select_match
    } else if match_cid then {
        if IsInHost() then {
            BVR_match = CONTEXTIDR_EL2 == DBGBVR_EL1[n][31 .. 0]
        } else {
            BVR_match = (PSTATE.EL == EL0 | PSTATE.EL == EL1) & CONTEXTIDR_EL1 == DBGBVR_EL1[n][31 .. 0]
        }
    } else if match_cid1 then {
        BVR_match = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost())) & CONTEXTIDR_EL1 == DBGBVR_EL1[n][31 .. 0]
    } else ();
    if match_vmid then {
        if not_bool(Have16bitVMID()) | Slice(VTCR_EL2, 19, 1) == 0b0 then {
            vmid = ZeroExtend((Slice(VTTBR_EL2, 56, 8) @ Slice(VTTBR_EL2, 48, 8))[7 .. 0], 16);
            bvr_vmid = ZeroExtend(DBGBVR_EL1[n][39 .. 32], 16)
        } else {
            vmid = Slice(VTTBR_EL2, 56, 8) @ Slice(VTTBR_EL2, 48, 8);
            bvr_vmid = DBGBVR_EL1[n][47 .. 32]
        };
        BXVR_match = (((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(IsInHost())) & vmid == bvr_vmid
    } else if match_cid2 then {
        BXVR_match = (not_bool(IsSecure()) & HaveVirtHostExt()) & DBGBVR_EL1[n][63 .. 32] == CONTEXTIDR_EL2
    } else ();
    let bvr_match_valid : bool = (match_addr | match_cid) | match_cid1;
    let bxvr_match_valid : bool = match_vmid | match_cid2;
    let val_match : bool = (not_bool(bxvr_match_valid) | BXVR_match) & (not_bool(bvr_match_valid) | BVR_match);
    return(val_match)
}

val CheckValidStateMatch : forall ('isbreakpnt : Bool).
  (bits(2), bits(1), bits(2), bool('isbreakpnt)) -> (Constraint, bits(2), bits(1), bits(2)) effect {escape, undef}

function CheckValidStateMatch (SSC__arg, HMC__arg, PxC__arg, isbreakpnt) = {
    SSC : bits(2) = SSC__arg;
    HMC : bits(1) = HMC__arg;
    PxC : bits(2) = PxC__arg;
    c : Constraint = undefined;
    reserved : bool = false;
    if ((not_bool(isbreakpnt) | not_bool(HaveAArch32EL(EL1))) & (HMC @ PxC) == 0b000) & SSC != 0b11 then {
        reserved = true
    } else ();
    if (not_bool(HaveEL(EL3)) & not_bool(HaveEL(EL2))) & (HMC != 0b0 | SSC != 0b00) then {
        reserved = true
    } else ();
    if (not_bool(HaveEL(EL3)) & (SSC == 0b01 | SSC == 0b10)) & ((HMC @ SSC) @ PxC) != 0b10100 then {
        reserved = true
    } else ();
    if (not_bool(HaveEL(EL3)) | HighestELUsingAArch32()) & ((HMC @ SSC) @ PxC) == 0b11000 then {
        reserved = true
    } else ();
    if not_bool(HaveEL(EL2)) & ((HMC @ SSC) @ PxC) == 0b11100 then {
        reserved = true
    } else ();
    if (match (HMC @ SSC) @ PxC {
      0b01110 => true,
      [bitone, bitzero, bitzero, _, bitzero] => true,
      0b10110 => true,
      [bitone, bitone, _, bitone, bitzero] => true,
      _ => false
    }) : bool then {
        reserved = true
    } else ();
    if reserved then {
        (c, (HMC @ SSC @ PxC)) = ConstrainUnpredictableBits(0 + 1 + 2 + 2, Unpredictable_RESBPWPCTRL);
        assert(c == Constraint_DISABLED | c == Constraint_UNKNOWN);
        if c == Constraint_DISABLED then {
            return((c, __UNKNOWN_bits(2), __UNKNOWN_bits(1), __UNKNOWN_bits(2)))
        } else ()
    } else ();
    return((Constraint_NONE, SSC, HMC, PxC))
}

val AArch64_StateMatch : forall ('isbreakpnt : Bool) ('ispriv : Bool) ('linked : Bool).
  (bits(2), bits(1), bits(2), bool('linked), bits(4), bool('isbreakpnt), bool('ispriv)) -> bool effect {escape, rreg, undef}

function AArch64_StateMatch (SSC__arg, HMC__arg, PxC__arg, linked__arg, LBN, isbreakpnt, ispriv) = {
    SSC : bits(2) = SSC__arg;
    HMC : bits(1) = HMC__arg;
    PxC : bits(2) = PxC__arg;
    linked : bool = linked__arg;
    c : Constraint = undefined;
    first_ctx_cmp : int = undefined;
    last_ctx_cmp : int = undefined;
    lbn : int = undefined;
    linked_match : bool = undefined;
    linked_to : bool = undefined;
    priv_match : bool = undefined;
    security_state_match : bool = undefined;
    vaddress : bits(64) = undefined;
    (c, SSC, HMC, PxC) = CheckValidStateMatch(SSC, HMC, PxC, isbreakpnt);
    if c == Constraint_DISABLED then {
        return(false)
    } else ();
    let EL3_match : bool = (HaveEL(EL3) & HMC == 0b1) & [SSC[0]] == 0b0;
    let EL2_match : bool = HaveEL(EL2) & (HMC == 0b1 & (SSC @ PxC) != 0b1000 | SSC == 0b11);
    let EL1_match : bool = [PxC[0]] == 0b1;
    let EL0_match : bool = [PxC[1]] == 0b1;
    if not_bool(ispriv) & not_bool(isbreakpnt) then {
        priv_match = EL0_match
    } else {
        match PSTATE.EL {
          ? if ? == EL3 => {
              priv_match = EL3_match
          },
          ? if ? == EL2 => {
              priv_match = EL2_match
          },
          ? if ? == EL1 => {
              priv_match = EL1_match
          },
          ? if ? == EL0 => {
              priv_match = EL0_match
          },
          _ => ()
        }
    };
    match SSC {
      0b00 => {
          security_state_match = true
      },
      0b01 => {
          security_state_match = not_bool(IsSecure())
      },
      0b10 => {
          security_state_match = IsSecure()
      },
      0b11 => {
          security_state_match = HMC == 0b1 | IsSecure()
      }
    };
    let security_state_match = security_state_match;
    if linked then {
        lbn = UInt(LBN);
        let 'first_ctx_cmp = UInt(Slice(ID_AA64DFR0_EL1, 12, 4)) - UInt(Slice(ID_AA64DFR0_EL1, 28, 4));
        let 'last_ctx_cmp = UInt(Slice(ID_AA64DFR0_EL1, 12, 4));
        if lbn < first_ctx_cmp | lbn > last_ctx_cmp then {
            (c, lbn) = ConstrainUnpredictableInteger(first_ctx_cmp, last_ctx_cmp, Unpredictable_BPNOTCTXCMP);
            assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
            match c {
              Constraint_DISABLED => {
                  return(false)
              },
              Constraint_NONE => {
                  linked = false
              },
              _ => ()
            }
        } else ()
    } else ();
    let 'lbn = lbn;
    if linked then {
        let vaddress : bits(64) = __UNKNOWN_bits(64);
        let linked_to : bool = true;
        linked_match = AArch64_BreakpointValueMatch(lbn, vaddress, linked_to)
    } else ();
    return((priv_match & security_state_match) & (not_bool(linked) | linked_match))
}

val AArch64_BreakpointMatch : forall ('n 'size : Int), (0 <= 'n & 'n < 16).
  (int('n), bits(64), int('size)) -> bool effect {escape, rreg, undef}

function AArch64_BreakpointMatch (n, vaddress, size) = {
    match_i : bool = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    assert(n <= UInt(Slice(ID_AA64DFR0_EL1, 12, 4)));
    let enabled : bool = Slice(DBGBCR_EL1[n], 0, 1) == 0b1;
    let ispriv : bool = PSTATE.EL != EL0;
    let linked : bool = (match Slice(DBGBCR_EL1[n], 20, 4) {
      [bitzero, _, bitzero, bitone] => true,
      _ => false
    }) : bool;
    let isbreakpnt : bool = true;
    let linked_to : bool = false;
    let state_match : bool = AArch64_StateMatch(Slice(DBGBCR_EL1[n], 14, 2), Slice(DBGBCR_EL1[n], 13, 1), Slice(DBGBCR_EL1[n], 1, 2), linked, Slice(DBGBCR_EL1[n], 16, 4), isbreakpnt, ispriv);
    value_match_name : bool = AArch64_BreakpointValueMatch(n, vaddress, linked_to);
    if HaveAnyAArch32() & size == 4 then {
        let match_i : bool = AArch64_BreakpointValueMatch(n, vaddress + 2, linked_to);
        if not_bool(value_match_name) & match_i then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        } else ()
    } else ();
    if [vaddress[1]] == 0b1 & Slice(DBGBCR_EL1[n], 5, 4) == 0b1111 then {
        if value_match_name then {
            value_match_name = ConstrainUnpredictableBool(Unpredictable_BPMATCHHALF)
        } else ()
    } else ();
    let val_match : bool = (value_match_name & state_match) & enabled;
    return(val_match)
}

val AArch64_DebugFault : forall ('iswrite : Bool).
  (AccType, bool('iswrite)) -> FaultRecord effect {undef}

function AArch64_DebugFault (acctype, iswrite) = {
    let ipaddress : bits(48) = __UNKNOWN_bits(48);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    let 'level = __UNKNOWN_integer();
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let secondstage : bool = false;
    let s2fs1walk : bool = false;
    return(AArch64_CreateFaultRecord(Fault_Debug, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val AArch64_NoFault : unit -> FaultRecord effect {undef}

function AArch64_NoFault () = {
    let ipaddress : bits(48) = __UNKNOWN_bits(48);
    let 'level = __UNKNOWN_integer();
    let acctype : AccType = AccType_NORMAL;
    let iswrite : bool = __UNKNOWN_boolean();
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    let secondstage : bool = false;
    let s2fs1walk : bool = false;
    return(AArch64_CreateFaultRecord(Fault_None, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val HaltOnBreakpointOrWatchpoint : unit -> bool effect {escape, rreg, undef}

function HaltOnBreakpointOrWatchpoint () = {
    return((HaltingAllowed() & Slice(EDSCR, 14, 1) == 0b1) & Slice(OSLSR_EL1, 1, 1) == 0b0)
}

val AArch64_CheckBreakpoint : forall ('size : Int).
  (bits(64), int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch64_CheckBreakpoint (vaddress, size) = {
    acctype : AccType = undefined;
    iswrite : bool = undefined;
    match_i : bool = undefined;
    reason : bits(6) = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    assert(UsingAArch32() & (size == 2 | size == 4) | size == 4);
    val_match : bool = false;
    foreach (i from 0 to UInt(Slice(ID_AA64DFR0_EL1, 12, 4)) by 1 in inc) {
        match_i = AArch64_BreakpointMatch(i, vaddress, size);
        val_match = val_match | match_i
    };
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        let reason : bits(6) = DebugHalt_Breakpoint;
        Halt(reason);
        return(undefined : FaultRecord)
    } else if val_match then {
        let acctype : AccType = AccType_IFETCH;
        let iswrite : bool = false;
        return(AArch64_DebugFault(acctype, iswrite))
    } else {
        return(AArch64_NoFault())
    }
}

val AArch64_AccessUsesEL : AccType -> bits(2) effect {rreg}

function AArch64_AccessUsesEL acctype = {
    if acctype == AccType_UNPRIV then {
        return(EL0)
    } else {
        return(PSTATE.EL)
    }
}

val AArch64_AccessIsPrivileged : AccType -> bool effect {escape, rreg, undef}

function AArch64_AccessIsPrivileged acctype = {
    ispriv : bool = undefined;
    let el : bits(2) = AArch64_AccessUsesEL(acctype);
    if el == EL0 then {
        ispriv = false
    } else if el == EL3 then {
        ispriv = true
    } else if el == EL2 & (not_bool(IsInHost()) | Slice(HCR_EL2, 27, 1) == 0b0) then {
        ispriv = true
    } else if HaveUAOExt() & PSTATE.UAO == 0b1 then {
        ispriv = true
    } else {
        ispriv = acctype != AccType_UNPRIV
    };
    return(ispriv)
}

val AArch64_WatchpointByteMatch : forall ('n : Int), (0 <= 'n & 'n < 16).
  (int('n), bits(64)) -> bool effect {escape, rreg, undef}

function AArch64_WatchpointByteMatch (n, vaddress) = {
    LSB : bits(8) = undefined;
    MSB : bits(8) = undefined;
    WVR_match : bool = undefined;
    c : Constraint = undefined;
    let el : bits(2) = PSTATE.EL;
    let 'top = AddrTop(vaddress, el);
    bottom : {|2, 3|} = if [DBGWVR_EL1[n][2]] == 0b1 then 2 else 3;
    byte_select_match : bool = let 'bottom = bottom in
      {
          [Slice(DBGWCR_EL1[n], 5, 8)[UInt(vaddress[bottom - 1 .. 0])]] != 0b0
      };
    mask : int = UInt(Slice(DBGWCR_EL1[n], 24, 5));
    if mask > 0 & not_bool(IsOnes(Slice(DBGWCR_EL1[n], 5, 8))) then {
        byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPMASKANDBAS)
    } else {
        let LSB : bits(8) = Slice(DBGWCR_EL1[n], 5, 8) & not_vec(Slice(DBGWCR_EL1[n], 5, 8) - 1);
        let MSB : bits(8) = Slice(DBGWCR_EL1[n], 5, 8) + LSB;
        if not_bool(IsZero(MSB & MSB - 1)) then {
            byte_select_match = ConstrainUnpredictableBool(Unpredictable_WPBASCONTIGUOUS);
            bottom = 3
        } else ()
    };
    let 'bottom = bottom;
    if mask > 0 & mask <= 2 then {
        (c, mask) = ConstrainUnpredictableInteger(3, 31, Unpredictable_RESWPMASK);
        assert(c == Constraint_DISABLED | c == Constraint_NONE | c == Constraint_UNKNOWN);
        match c {
          Constraint_DISABLED => {
              return(false)
          },
          Constraint_NONE => {
              mask = 0
          },
          _ => ()
        }
    } else ();
    let 'mask = mask;
    if mask > bottom then {
        assert(constraint('mask <= 'top));
        WVR_match = vaddress[top .. mask] == DBGWVR_EL1[n][top .. mask];
        if WVR_match & not_bool(is_zero_subrange(DBGWVR_EL1[n], mask - 1, bottom)) then {
            WVR_match = ConstrainUnpredictableBool(Unpredictable_WPMASKEDBITS)
        } else ()
    } else {
        WVR_match = vaddress[top .. bottom] == DBGWVR_EL1[n][top .. bottom]
    };
    return(WVR_match & byte_select_match)
}

val AArch64_WatchpointMatch : forall ('ispriv : Bool) ('iswrite : Bool) 'n 'size,
  (0 <= 'n & 'n < 16).
  (int('n), bits(64), int('size), bool('ispriv), bool('iswrite)) -> bool effect {escape, rreg, undef}

function AArch64_WatchpointMatch (n, vaddress, size, ispriv, iswrite) = {
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    assert(n <= UInt(Slice(ID_AA64DFR0_EL1, 20, 4)));
    let enabled : bool = Slice(DBGWCR_EL1[n], 0, 1) == 0b1;
    let linked : bool = Slice(DBGWCR_EL1[n], 20, 1) == 0b1;
    let isbreakpnt : bool = false;
    let state_match : bool = AArch64_StateMatch(Slice(DBGWCR_EL1[n], 14, 2), Slice(DBGWCR_EL1[n], 13, 1), Slice(DBGWCR_EL1[n], 1, 2), linked, Slice(DBGWCR_EL1[n], 16, 4), isbreakpnt, ispriv);
    let ls_match : bool = [Slice(DBGWCR_EL1[n], 3, 2)[if iswrite then 1 else 0]] == 0b1;
    value_match_name : bool = false;
    foreach (byte from 0 to (size - 1) by 1 in inc) {
        value_match_name = value_match_name | AArch64_WatchpointByteMatch(n, vaddress + byte)
    };
    return(((value_match_name & state_match) & ls_match) & enabled)
}

val AArch64_CheckWatchpoint : forall ('iswrite : Bool)('size : Int).
  (bits(64), AccType, bool('iswrite), int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch64_CheckWatchpoint (vaddress, acctype, iswrite, size) = {
    reason : bits(6) = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    val_match : bool = false;
    let ispriv : bool = AArch64_AccessIsPrivileged(acctype);
    foreach (i from 0 to UInt(Slice(ID_AA64DFR0_EL1, 20, 4)) by 1 in inc) {
        val_match = val_match | AArch64_WatchpointMatch(i, vaddress, size, ispriv, iswrite)
    };
    if val_match & HaltOnBreakpointOrWatchpoint() then {
        let reason : bits(6) = DebugHalt_Watchpoint;
        Halt(reason);
        return(undefined : FaultRecord)
    } else if val_match then {
        return(AArch64_DebugFault(acctype, iswrite))
    } else {
        return(AArch64_NoFault())
    }
}

val AArch64_CheckDebug : forall ('iswrite : Bool)('size : Int).
  (bits(64), AccType, bool('iswrite), int('size)) -> FaultRecord effect {escape, rreg, undef, wreg}

function AArch64_CheckDebug (vaddress, acctype, iswrite, size) = {
    fault : FaultRecord = AArch64_NoFault();
    let d_side : bool = acctype != AccType_IFETCH;
    let generate_exception : bool = AArch64_GenerateDebugExceptions() & Slice(MDSCR_EL1, 15, 1) == 0b1;
    let halt : bool = HaltOnBreakpointOrWatchpoint();
    if generate_exception | halt then {
        if d_side then {
            fault = AArch64_CheckWatchpoint(vaddress, acctype, iswrite, size)
        } else {
            fault = AArch64_CheckBreakpoint(vaddress, size)
        }
    } else ();
    return(fault)
}

val AArch64_PermissionFault : forall ('iswrite : Bool) 'level ('s2fs1walk : Bool) ('secondstage : Bool).
  (bits(48), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_PermissionFault (ipaddress, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    return(AArch64_CreateFaultRecord(Fault_Permission, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val AArch64_CheckS2Permission : forall ('hwupdatewalk : Bool) ('iswrite : Bool) 'level ('s2fs1walk : Bool).
  (Permissions, bits(64), bits(48), int('level), AccType, bool('iswrite), bool('s2fs1walk), bool('hwupdatewalk)) -> FaultRecord effect {escape, rreg, undef}

function AArch64_CheckS2Permission (perms, vaddress, ipaddress, level, acctype, iswrite, s2fs1walk, hwupdatewalk) = {
    domain : bits(4) = undefined;
    fail : bool = undefined;
    failedread : bool = undefined;
    secondstage : bool = undefined;
    xn : bool = undefined;
    assert(((HaveEL(EL2) & not_bool(IsSecure())) & not_bool(ELUsingAArch32(EL2))) & HasS2Translation());
    let r : bool = [perms.ap[1]] == 0b1;
    let w : bool = [perms.ap[2]] == 0b1;
    if HaveExtendedExecuteNeverExt() then {
        match perms.xn @ perms.xxn {
          0b00 => {
              xn = false
          },
          0b01 => {
              xn = PSTATE.EL == EL1
          },
          0b10 => {
              xn = true
          },
          0b11 => {
              xn = PSTATE.EL == EL0
          }
        }
    } else {
        xn = perms.xn == 0b1
    };
    if acctype == AccType_IFETCH & not_bool(s2fs1walk) then {
        fail = xn;
        failedread = true
    } else if (acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW) & not_bool(s2fs1walk) then {
        fail = not_bool(r) | not_bool(w);
        failedread = not_bool(r)
    } else if iswrite & not_bool(s2fs1walk) then {
        fail = not_bool(w);
        failedread = false
    } else if (acctype == AccType_DC & PSTATE.EL != EL0) & not_bool(s2fs1walk) then {
        fail = false
    } else if hwupdatewalk then {
        fail = not_bool(w);
        failedread = not_bool(iswrite)
    } else {
        fail = not_bool(r);
        failedread = not_bool(iswrite)
    };
    if fail then {
        domain = __UNKNOWN_bits(4);
        let secondstage : bool = true;
        return(AArch64_PermissionFault(ipaddress, level, acctype, not_bool(failedread), secondstage, s2fs1walk))
    } else {
        return(AArch64_NoFault())
    }
}

val AArch64_CombineS1S2Desc : (AddressDescriptor, AddressDescriptor) -> AddressDescriptor effect {escape, undef}

function AArch64_CombineS1S2Desc (s1desc, s2desc) = {
    result : AddressDescriptor = undefined;
    result.paddress = s2desc.paddress;
    if IsFault(s1desc) | IsFault(s2desc) then {
        result = if IsFault(s1desc) then s1desc else s2desc
    } else {
        result.fault = AArch64_NoFault();
        if s2desc.memattrs.memtype == MemType_Device | s1desc.memattrs.memtype == MemType_Device then {
            result.memattrs.memtype = MemType_Device;
            if s1desc.memattrs.memtype == MemType_Normal then {
                result.memattrs.device = s2desc.memattrs.device
            } else if s2desc.memattrs.memtype == MemType_Normal then {
                result.memattrs.device = s1desc.memattrs.device
            } else {
                result.memattrs.device = CombineS1S2Device(s1desc.memattrs.device, s2desc.memattrs.device)
            }
        } else {
            result.memattrs.memtype = MemType_Normal;
            result.memattrs.device = __UNKNOWN_DeviceType();
            result.memattrs.inner = CombineS1S2AttrHints(s1desc.memattrs.inner, s2desc.memattrs.inner);
            result.memattrs.outer = CombineS1S2AttrHints(s1desc.memattrs.outer, s2desc.memattrs.outer);
            result.memattrs.shareable = s1desc.memattrs.shareable | s2desc.memattrs.shareable;
            result.memattrs.outershareable = s1desc.memattrs.outershareable | s2desc.memattrs.outershareable
        }
    };
    result.memattrs = CombineS1S2LCSC(result.memattrs, s1desc.memattrs, s2desc.memattrs);
    result.memattrs = MemAttrDefaults(result.memattrs);
    return(result)
}

val AArch64_InstructionDevice : forall ('iswrite : Bool) 'level ('s2fs1walk : Bool) ('secondstage : Bool).
  (AddressDescriptor, bits(64), bits(48), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> AddressDescriptor effect {escape, undef}

function AArch64_InstructionDevice (addrdesc__arg, vaddress, ipaddress, level, acctype, iswrite, secondstage, s2fs1walk) = {
    addrdesc : AddressDescriptor = addrdesc__arg;
    let c : Constraint = ConstrainUnpredictable(Unpredictable_INSTRDEVICE);
    assert(c == Constraint_NONE | c == Constraint_FAULT);
    if c == Constraint_FAULT then {
        addrdesc.fault = AArch64_PermissionFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk)
    } else {
        addrdesc.memattrs.memtype = MemType_Normal;
        addrdesc.memattrs.inner.attrs = MemAttr_NC;
        addrdesc.memattrs.inner.hints = MemHint_No;
        addrdesc.memattrs.outer = addrdesc.memattrs.inner;
        addrdesc.memattrs = MemAttrDefaults(addrdesc.memattrs)
    };
    return(addrdesc)
}

val AArch64_AccessFlagFault : forall ('iswrite : Bool) 'level ('s2fs1walk : Bool) ('secondstage : Bool).
  (bits(48), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_AccessFlagFault (ipaddress, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    return(AArch64_CreateFaultRecord(Fault_AccessFlag, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val AArch64_AddressSizeFault : forall ('iswrite : Bool) 'level ('s2fs1walk : Bool) ('secondstage : Bool).
  (bits(48), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_AddressSizeFault (ipaddress, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    return(AArch64_CreateFaultRecord(Fault_AddressSize, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val AArch64_S1AttrDecode : (bits(2), bits(3), AccType) -> MemoryAttributes effect {escape, rreg, undef}

function AArch64_S1AttrDecode (SH, attr, acctype) = {
    memattrs : MemoryAttributes = undefined;
    let mair : bits(64) = MAIR_read__1();
    let 'index = 8 * UInt(attr);
    attrfield : bits(0 + ('index + 7 - 'index + 1)) = mair[index + 7 .. index];
    if attrfield[7 .. 4] != 0b0000 & attrfield[3 .. 0] == 0b0000 | attrfield[7 .. 4] == 0b0000 & not_bool((match attrfield[3 .. 0] {
      [_, _, bitzero, bitzero] => true,
      _ => false
    }) : bool) then {
        (__ignore_12, attrfield) = ConstrainUnpredictableBits(0 + (index + 7 - index + 1), Unpredictable_RESMAIR)
    } else ();
    if attrfield[7 .. 4] == 0b0000 then {
        memattrs.memtype = MemType_Device;
        match attrfield[3 .. 0] {
          0b0000 => {
              memattrs.device = DeviceType_nGnRnE
          },
          0b0100 => {
              memattrs.device = DeviceType_nGnRE
          },
          0b1000 => {
              memattrs.device = DeviceType_nGRE
          },
          0b1100 => {
              memattrs.device = DeviceType_GRE
          },
          _ => {
              Unreachable()
          }
        }
    } else if attrfield[3 .. 0] != 0b0000 then {
        memattrs.memtype = MemType_Normal;
        memattrs.outer = LongConvertAttrsHints(attrfield[7 .. 4], acctype);
        memattrs.inner = LongConvertAttrsHints(attrfield[3 .. 0], acctype);
        memattrs.shareable = [SH[1]] == 0b1;
        memattrs.outershareable = SH == 0b10
    } else {
        Unreachable()
    };
    return(MemAttrDefaults(memattrs))
}

val AArch64_TranslationFault : forall ('iswrite : Bool) 'level ('s2fs1walk : Bool) ('secondstage : Bool).
  (bits(48), int('level), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk)) -> FaultRecord effect {undef}

function AArch64_TranslationFault (ipaddress, level, acctype, iswrite, secondstage, s2fs1walk) = {
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    return(AArch64_CreateFaultRecord(Fault_Translation, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val EffectiveHWU : forall ('secondstage : Bool).
  (bits(2), bool('secondstage), bits(1)) -> bits(4) effect {escape, rreg, undef}

function EffectiveHWU (el, secondstage, vaddr55) = {
    regime : bits(2) = undefined;
    if secondstage then {
        return(Slice(VTCR_EL2, 28, 1) @ (Slice(VTCR_EL2, 27, 1) @ (Slice(VTCR_EL2, 26, 1) @ Slice(VTCR_EL2, 25, 1))))
    } else {
        let regime : bits(2) = S1TranslationRegime(el);
        match regime {
          ? if ? == EL1 => {
              if vaddr55 == 0b1 then {
                  if Slice(TCR_EL1, 42, 1) == 0b1 then {
                      return(Slice(TCR_EL1, 50, 1) @ (Slice(TCR_EL1, 49, 1) @ (Slice(TCR_EL1, 48, 1) @ Slice(TCR_EL1, 47, 1))))
                  } else {
                      return(Zeros(4))
                  }
              } else if Slice(TCR_EL1, 41, 1) == 0b1 then {
                  return(Slice(TCR_EL1, 46, 1) @ (Slice(TCR_EL1, 45, 1) @ (Slice(TCR_EL1, 44, 1) @ Slice(TCR_EL1, 43, 1))))
              } else {
                  return(Zeros(4))
              }
          },
          ? if ? == EL2 => {
              if HaveVirtHostExt() & ELIsInHost(el) then {
                  if vaddr55 == 0b1 then {
                      if Slice(TCR_EL2, 42, 1) == 0b1 then {
                          return(Slice(TCR_EL2, 50, 1) @ (Slice(TCR_EL2, 49, 1) @ (Slice(TCR_EL2, 48, 1) @ Slice(TCR_EL2, 47, 1))))
                      } else {
                          return(Zeros(4))
                      }
                  } else if Slice(TCR_EL2, 41, 1) == 0b1 then {
                      return(Slice(TCR_EL2, 46, 1) @ (Slice(TCR_EL2, 45, 1) @ (Slice(TCR_EL2, 44, 1) @ Slice(TCR_EL2, 43, 1))))
                  } else {
                      return(Zeros(4))
                  }
              } else {
                  if Slice(TCR_EL2, 24, 1) == 0b1 then {
                      return(Slice(TCR_EL2, 28, 1) @ (Slice(TCR_EL2, 27, 1) @ (Slice(TCR_EL2, 26, 1) @ Slice(TCR_EL2, 25, 1))))
                  } else {
                      return(Zeros(4))
                  }
              }
          },
          ? if ? == EL3 => {
              if Slice(TCR_EL3, 24, 1) == 0b1 then {
                  return(Slice(TCR_EL3, 28, 1) @ (Slice(TCR_EL3, 27, 1) @ (Slice(TCR_EL3, 26, 1) @ Slice(TCR_EL3, 25, 1))))
              } else {
                  return(Zeros(4))
              }
          },
          _ => {
              return(undefined : bits(4))
          }
        }
    }
}

register configuration __tlb_enabled : bool = false

val AArch64_CheckAndUpdateDescriptor : forall ('hwupdatewalk : Bool) ('iswrite : Bool) ('iswritevalidcap : Bool) ('s2fs1walk : Bool) ('secondstage : Bool).
  (DescriptorUpdate, FaultRecord, bool('secondstage), bits(64), AccType, bool('iswrite), bool('s2fs1walk), bool('hwupdatewalk), bool('iswritevalidcap)) -> FaultRecord effect {escape, rreg, undef}

val AArch64_SecondStageWalk : forall ('hwupdatewalk : Bool) ('iswrite : Bool) 'size.
  (AddressDescriptor, bits(64), AccType, bool('iswrite), int('size), bool('hwupdatewalk)) -> AddressDescriptor effect {escape, rreg, undef}

val AArch64_SecondStageTranslate : forall ('hwupdatewalk : Bool) ('iswrite : Bool) ('iswritevalidcap : Bool) ('s2fs1walk : Bool) 'size ('wasaligned : Bool).
  (AddressDescriptor, bits(64), AccType, bool('iswrite), bool('wasaligned), bool('s2fs1walk), int('size), bool('hwupdatewalk), bool('iswritevalidcap)) -> AddressDescriptor effect {escape, rreg, undef}

val AArch64_TranslationTableWalk : forall ('iswrite : Bool) ('s2fs1walk : Bool) ('secondstage : Bool) 'size.
  (bits(48), bits(64), AccType, bool('iswrite), bool('secondstage), bool('s2fs1walk), int('size)) -> TLBRecord effect {escape, rreg, undef}

function AArch64_CheckAndUpdateDescriptor (result, fault, secondstage, vaddress, acctype, iswrite, s2fs1walk, hwupdatewalk__arg, iswritevalidcap) = {
    hwupdatewalk : bool = hwupdatewalk__arg;
    accdesc : AccessDescriptor = undefined;
    desc : bits(64) = undefined;
    descaddr2 : AddressDescriptor = undefined;
    el : bits(2) = undefined;
    reversedescriptors : bool = undefined;
    hw_update_AF : bool = false;
    hw_update_AP : bool = false;
    hw_update_SC : bool = false;
    if result.AF then {
        if fault.statuscode == Fault_None | ConstrainUnpredictable(Unpredictable_AFUPDATE) == Constraint_TRUE then {
            hw_update_AF = true
        } else ()
    } else ();
    let write_perm_req : bool = (iswrite | acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW) & not_bool(s2fs1walk);
    if result.AP & fault.statuscode == Fault_None then {
        hw_update_AP = write_perm_req & not_bool(acctype == AccType_AT | acctype == AccType_DC | acctype == AccType_DC_UNPRIV) | hwupdatewalk
    } else ();
    if ((result.SC & fault.statuscode == Fault_None) & iswritevalidcap) & write_perm_req then {
        hw_update_SC = true
    } else ();
    if (hw_update_AF | hw_update_AP) | hw_update_SC then {
        if secondstage | not_bool(HasS2Translation()) then {
            descaddr2 = result.descaddr
        } else {
            let hwupdatewalk : bool = true;
            descaddr2 = AArch64_SecondStageWalk(result.descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            if IsFault(descaddr2) then {
                return(descaddr2.fault)
            } else ()
        };
        let accdesc : AccessDescriptor = CreateAccessDescriptor(AccType_ATOMICRW);
        desc : bits(64) = _Mem_read(descaddr2, 8, accdesc);
        let el : bits(2) = AArch64_AccessUsesEL(acctype);
        match el {
          ? if ? == EL3 => {
              reversedescriptors = Slice(SCTLR_EL3, 25, 1) == 0b1
          },
          ? if ? == EL2 => {
              reversedescriptors = Slice(SCTLR_EL2, 25, 1) == 0b1
          },
          _ => {
              reversedescriptors = Slice(SCTLR_EL1, 25, 1) == 0b1
          }
        };
        if reversedescriptors then {
            desc = BigEndianReverse(desc)
        } else ();
        if hw_update_AF then {
            desc[10] = Bit(0b1)
        } else ();
        if hw_update_AP then {
            desc[7] = Bit(if secondstage then 0b1 else 0b0)
        } else ();
        if hw_update_SC then {
            desc[60] = Bit(0b1)
        } else ();
        _Mem_set(descaddr2, 8, accdesc) = if reversedescriptors then BigEndianReverse(desc) else desc
    } else ();
    return(fault)
}

function AArch64_SecondStageWalk (S1, vaddress, acctype, iswrite, size, hwupdatewalk) = {
    assert(HasS2Translation());
    let s2fs1walk : bool = true;
    let wasaligned : bool = true;
    let iswritevalidcap : bool = false;
    return(AArch64_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk, iswritevalidcap))
}

function AArch64_SecondStageTranslate (S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk, iswritevalidcap) = {
    S2 : TLBRecord = undefined;
    ipaddress : bits(48) = undefined;
    result : AddressDescriptor = undefined;
    assert(HasS2Translation());
    let s2_enabled : bool = Slice(HCR_EL2, 0, 1) == 0b1 | Slice(HCR_EL2, 12, 1) == 0b1;
    let secondstage : bool = true;
    if s2_enabled then {
        let ipaddress : bits(48) = S1.paddress.address[47 .. 0];
        S2 : TLBRecord = AArch64_TranslationTableWalk(ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
        if ((not_bool(wasaligned) & acctype != AccType_IFETCH | acctype == AccType_DCZVA) & S2.addrdesc.memattrs.memtype == MemType_Device) & not_bool(IsFault(S2.addrdesc)) then {
            S2.addrdesc.fault = AArch64_AlignmentFault(acctype, iswrite, secondstage)
        } else ();
        if not_bool(IsFault(S2.addrdesc)) then {
            S2.addrdesc.fault = AArch64_CheckS2Permission(S2.perms, vaddress, ipaddress, S2.level, acctype, iswrite, s2fs1walk, hwupdatewalk)
        } else ();
        if ((not_bool(s2fs1walk) & not_bool(IsFault(S2.addrdesc))) & S2.addrdesc.memattrs.memtype == MemType_Device) & acctype == AccType_IFETCH then {
            S2.addrdesc = AArch64_InstructionDevice(S2.addrdesc, vaddress, ipaddress, S2.level, acctype, iswrite, secondstage, s2fs1walk)
        } else ();
        if ((s2fs1walk & not_bool(IsFault(S2.addrdesc))) & Slice(HCR_EL2, 2, 1) == 0b1) & S2.addrdesc.memattrs.memtype == MemType_Device then {
            S2.addrdesc.fault = AArch64_PermissionFault(ipaddress, S2.level, acctype, iswrite, secondstage, s2fs1walk)
        } else ();
        S2.addrdesc.fault = AArch64_CheckAndUpdateDescriptor(S2.descupdate, S2.addrdesc.fault, secondstage, vaddress, acctype, iswrite, s2fs1walk, hwupdatewalk, iswritevalidcap);
        result = AArch64_CombineS1S2Desc(S1, S2.addrdesc)
    } else {
        result = S1
    };
    return(result)
}

function AArch64_TranslationTableWalk (ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size) = {
    accdesc : AccessDescriptor = undefined;
    addrselectbottom : int = undefined;
    basefound : bool = undefined;
    blocktranslate : bool = undefined;
    c : Constraint = undefined;
    desc : bits(64) = undefined;
    descaddr2 : AddressDescriptor = undefined;
    disabled : bool = undefined;
    el : bits(2) = undefined;
    firstblocklevel : {|1, 2|} = 1;
    grainsize : {|12, 14, 16|} = 12;
    hierattrsdisabled : bool = undefined;
    hwupdatewalk : bool = undefined;
    inputsize : int = undefined;
    inputsize_max : {|48, 52|} = 48;
    inputsize_min : {'inputsize_min, 'inputsize_min == 25. int('inputsize_min)} = 25;
    inputsizecheck : int = undefined;
    largegrain : bool = undefined;
    level : int = undefined;
    lookupsecure : bool = undefined;
    midgrain : bool = undefined;
    num_ch_entries : {|4, 5, 7|} = 4;
    outputsize : int = undefined;
    ps : bits(3) = undefined;
    reversedescriptors : bool = undefined;
    singlepriv : bool = undefined;
    startlevel : int = undefined;
    startsizecheck : int = undefined;
    stride : int = undefined;
    top : int = undefined;
    update_AF : bool = undefined;
    update_AP : bool = undefined;
    if not_bool(secondstage) then {
        assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())))
    } else {
        assert(((HaveEL(EL2) & not_bool(IsSecure())) & not_bool(ELUsingAArch32(EL2))) & HasS2Translation())
    };
    result : TLBRecord = undefined;
    descaddr : AddressDescriptor = undefined;
    baseregister : bits(64) = undefined;
    inputaddr : bits(64) = undefined;
    if __tlb_enabled then {
        if not_bool(secondstage) then {
            inputaddr = ZeroExtend(vaddress)
        } else {
            inputaddr = ZeroExtend(ipaddress)
        };
        let cacheline : TLBLine = TLBLookup(ZeroExtend(inputaddr, 64), secondstage, acctype);
        if cacheline.valid_name then {
            return(cacheline.data)
        } else ()
    } else ();
    descaddr.memattrs.memtype = MemType_Normal;
    if not_bool(secondstage) then {
        inputaddr = ZeroExtend(vaddress);
        let el : bits(2) = AArch64_AccessUsesEL(acctype);
        let 'top = AddrTop(inputaddr, el);
        if el == EL3 then {
            largegrain = Slice(TCR_EL3, 14, 2) == 0b01;
            midgrain = Slice(TCR_EL3, 14, 2) == 0b10;
            inputsize = 64 - UInt(Slice(TCR_EL3, 0, 6));
            let 'inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
            let 'inputsize_min = 64 - 39;
            if inputsize < inputsize_min then {
                let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                assert(c == Constraint_FORCE | c == Constraint_FAULT);
                if c == Constraint_FORCE then {
                    inputsize = inputsize_min
                } else ()
            } else ();
            ps = Slice(TCR_EL3, 16, 3);
            let 'inputsize = inputsize in
              {
                  basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_zero_subrange(inputaddr, top, inputsize)
              };
            disabled = false;
            baseregister = TTBR0_EL3;
            descaddr.memattrs = WalkAttrDecode(Slice(TCR_EL3, 12, 2), Slice(TCR_EL3, 10, 2), Slice(TCR_EL3, 8, 2), secondstage);
            reversedescriptors = Slice(SCTLR_EL3, 25, 1) == 0b1;
            lookupsecure = true;
            singlepriv = true;
            update_AF = HaveAccessFlagUpdateExt() & Slice(TCR_EL3, 21, 1) == 0b1;
            update_AP = (HaveDirtyBitModifierExt() & update_AF) & Slice(TCR_EL3, 22, 1) == 0b1;
            hierattrsdisabled = AArch64_HaveHPDExt() & Slice(TCR_EL3, 24, 1) == 0b1
        } else if ELIsInHost(el) then {
            if [inputaddr[top]] == 0b0 then {
                largegrain = Slice(TCR_EL2, 14, 2) == 0b01;
                midgrain = Slice(TCR_EL2, 14, 2) == 0b10;
                inputsize = 64 - UInt(Slice(TCR_EL2, 0, 6));
                let 'inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                let 'inputsize_min = 64 - 39;
                if inputsize < inputsize_min then {
                    let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                    assert(c == Constraint_FORCE | c == Constraint_FAULT);
                    if c == Constraint_FORCE then {
                        inputsize = inputsize_min
                    } else ()
                } else ();
                let 'inputsize = inputsize in
                  {
                      basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_zero_subrange(inputaddr, top, inputsize)
                  };
                disabled = Slice(TCR_EL2, 7, 1) == 0b1;
                baseregister = TTBR0_EL2;
                descaddr.memattrs = WalkAttrDecode(Slice(TCR_EL2, 12, 2), Slice(TCR_EL2, 10, 2), Slice(TCR_EL2, 8, 2), secondstage);
                hierattrsdisabled = AArch64_HaveHPDExt() & Slice(TCR_EL2, 41, 1) == 0b1
            } else {
                inputsize = 64 - UInt(Slice(TCR_EL2, 16, 6));
                largegrain = Slice(TCR_EL2, 30, 2) == 0b11;
                midgrain = Slice(TCR_EL2, 30, 2) == 0b01;
                let 'inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                let 'inputsize_min = 64 - 39;
                if inputsize < inputsize_min then {
                    let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                    assert(c == Constraint_FORCE | c == Constraint_FAULT);
                    if c == Constraint_FORCE then {
                        inputsize = inputsize_min
                    } else ()
                } else ();
                let 'inputsize = inputsize in
                  {
                      basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_ones_subrange(inputaddr, top, inputsize)
                  };
                disabled = Slice(TCR_EL2, 23, 1) == 0b1;
                baseregister = TTBR1_EL2;
                descaddr.memattrs = WalkAttrDecode(Slice(TCR_EL2, 28, 2), Slice(TCR_EL2, 26, 2), Slice(TCR_EL2, 24, 2), secondstage);
                hierattrsdisabled = AArch64_HaveHPDExt() & Slice(TCR_EL2, 42, 1) == 0b1
            };
            ps = Slice(TCR_EL2, 32, 3);
            reversedescriptors = Slice(SCTLR_EL2, 25, 1) == 0b1;
            lookupsecure = false;
            singlepriv = false;
            update_AF = HaveAccessFlagUpdateExt() & Slice(TCR_EL2, if Slice(HCR_EL2, 34, 1) == 0b0 then 21 else 39, 1) == 0b1;
            update_AP = (HaveDirtyBitModifierExt() & update_AF) & Slice(TCR_EL2, if Slice(HCR_EL2, 34, 1) == 0b0 then 22 else 40, 1) == 0b1
        } else if el == EL2 then {
            inputsize = 64 - UInt(Slice(TCR_EL2, 0, 6));
            largegrain = Slice(TCR_EL2, 14, 2) == 0b01;
            midgrain = Slice(TCR_EL2, 14, 2) == 0b10;
            let 'inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
            let 'inputsize_min = 64 - 39;
            if inputsize < inputsize_min then {
                let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                assert(c == Constraint_FORCE | c == Constraint_FAULT);
                if c == Constraint_FORCE then {
                    inputsize = inputsize_min
                } else ()
            } else ();
            ps = Slice(TCR_EL2, 16, 3);
            let 'inputsize = inputsize in
              {
                  basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_zero_subrange(inputaddr, top, inputsize)
              };
            disabled = false;
            baseregister = TTBR0_EL2;
            descaddr.memattrs = WalkAttrDecode(Slice(TCR_EL2, 12, 2), Slice(TCR_EL2, 10, 2), Slice(TCR_EL2, 8, 2), secondstage);
            reversedescriptors = Slice(SCTLR_EL2, 25, 1) == 0b1;
            lookupsecure = false;
            singlepriv = true;
            update_AF = HaveAccessFlagUpdateExt() & Slice(TCR_EL2, if Slice(HCR_EL2, 34, 1) == 0b0 then 21 else 39, 1) == 0b1;
            update_AP = (HaveDirtyBitModifierExt() & update_AF) & Slice(TCR_EL2, if Slice(HCR_EL2, 34, 1) == 0b0 then 22 else 40, 1) == 0b1;
            hierattrsdisabled = AArch64_HaveHPDExt() & Slice(TCR_EL2, 24, 1) == 0b1
        } else {
            if [inputaddr[top]] == 0b0 then {
                inputsize = 64 - UInt(Slice(TCR_EL1, 0, 6));
                largegrain = Slice(TCR_EL1, 14, 2) == 0b01;
                midgrain = Slice(TCR_EL1, 14, 2) == 0b10;
                let 'inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                let 'inputsize_min = 64 - 39;
                if inputsize < inputsize_min then {
                    let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                    assert(c == Constraint_FORCE | c == Constraint_FAULT);
                    if c == Constraint_FORCE then {
                        inputsize = inputsize_min
                    } else ()
                } else ();
                let 'inputsize = inputsize in
                  {
                      basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_zero_subrange(inputaddr, top, inputsize)
                  };
                disabled = Slice(TCR_EL1, 7, 1) == 0b1;
                baseregister = TTBR0_EL1;
                descaddr.memattrs = WalkAttrDecode(Slice(TCR_EL1, 12, 2), Slice(TCR_EL1, 10, 2), Slice(TCR_EL1, 8, 2), secondstage);
                hierattrsdisabled = AArch64_HaveHPDExt() & Slice(TCR_EL1, 41, 1) == 0b1
            } else {
                inputsize = 64 - UInt(Slice(TCR_EL1, 16, 6));
                largegrain = Slice(TCR_EL1, 30, 2) == 0b11;
                midgrain = Slice(TCR_EL1, 30, 2) == 0b01;
                let 'inputsize_max = if Have52BitVAExt() & largegrain then 52 else 48;
                let 'inputsize_min = 64 - 39;
                if inputsize < inputsize_min then {
                    let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
                    assert(c == Constraint_FORCE | c == Constraint_FAULT);
                    if c == Constraint_FORCE then {
                        inputsize = inputsize_min
                    } else ()
                } else ();
                let 'inputsize = inputsize in
                  {
                      basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_ones_subrange(inputaddr, top, inputsize)
                  };
                disabled = Slice(TCR_EL1, 23, 1) == 0b1;
                baseregister = TTBR1_EL1;
                descaddr.memattrs = WalkAttrDecode(Slice(TCR_EL1, 28, 2), Slice(TCR_EL1, 26, 2), Slice(TCR_EL1, 24, 2), secondstage);
                hierattrsdisabled = AArch64_HaveHPDExt() & Slice(TCR_EL1, 42, 1) == 0b1
            };
            ps = Slice(TCR_EL1, 32, 3);
            reversedescriptors = Slice(SCTLR_EL1, 25, 1) == 0b1;
            lookupsecure = IsSecure();
            singlepriv = false;
            update_AF = HaveAccessFlagUpdateExt() & Slice(TCR_EL1, 39, 1) == 0b1;
            update_AP = (HaveDirtyBitModifierExt() & update_AF) & Slice(TCR_EL1, 40, 1) == 0b1
        };
        if largegrain then {
            grainsize = 16;
            firstblocklevel = 2
        } else if midgrain then {
            grainsize = 14;
            firstblocklevel = 2
        } else {
            grainsize = 12;
            firstblocklevel = 1
        };
        stride = grainsize - 3;
        level = 4 - (1 + DIV(inputsize - grainsize - 1, stride))
    } else {
        inputaddr = ZeroExtend(ipaddress);
        inputsize = 64 - UInt(Slice(VTCR_EL2, 0, 6));
        largegrain = Slice(VTCR_EL2, 14, 2) == 0b01;
        midgrain = Slice(VTCR_EL2, 14, 2) == 0b10;
        let 'inputsize_max = 48;
        if inputsize > inputsize_max then {
            c = ConstrainUnpredictable(Unpredictable_RESTnSZ);
            assert(c == Constraint_FORCE | c == Constraint_FAULT);
            if c == Constraint_FORCE then {
                inputsize = inputsize_max
            } else ()
        } else ();
        let 'inputsize_min = 64 - 39;
        if inputsize < inputsize_min then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_RESTnSZ);
            assert(c == Constraint_FORCE | c == Constraint_FAULT);
            if c == Constraint_FORCE then {
                inputsize = inputsize_min
            } else ()
        } else ();
        ps = Slice(VTCR_EL2, 16, 3);
        let 'inputsize = inputsize in
          {
              basefound = (inputsize >= inputsize_min & inputsize <= inputsize_max) & is_zero_subrange(inputaddr, 63, inputsize)
          };
        disabled = false;
        descaddr.memattrs = WalkAttrDecode(Slice(VTCR_EL2, 12, 2), Slice(VTCR_EL2, 10, 2), Slice(VTCR_EL2, 8, 2), secondstage);
        reversedescriptors = Slice(SCTLR_EL2, 25, 1) == 0b1;
        singlepriv = true;
        update_AF = HaveAccessFlagUpdateExt() & Slice(VTCR_EL2, 21, 1) == 0b1;
        update_AP = (HaveDirtyBitModifierExt() & update_AF) & Slice(VTCR_EL2, 22, 1) == 0b1;
        lookupsecure = false;
        baseregister = VTTBR_EL2;
        let 'startlevel = UInt(Slice(VTCR_EL2, 6, 2));
        if largegrain then {
            grainsize = 16;
            level = 3 - startlevel;
            firstblocklevel = 2
        } else if midgrain then {
            grainsize = 14;
            level = 3 - startlevel;
            firstblocklevel = 2
        } else {
            grainsize = 12;
            level = 2 - startlevel;
            firstblocklevel = 1
        };
        stride = grainsize - 3;
        if largegrain then {
            if level == 0 | level == 1 & PAMax() <= 42 then {
                basefound = false
            } else ()
        } else if midgrain then {
            if level == 0 | level == 1 & PAMax() <= 40 then {
                basefound = false
            } else ()
        } else {
            if level < 0 | level == 0 & PAMax() <= 42 then {
                basefound = false
            } else ()
        };
        inputsizecheck : int = inputsize;
        if inputsize > PAMax() & (not_bool(ELUsingAArch32(EL1)) | inputsize > 40) then {
            match ConstrainUnpredictable(Unpredictable_LARGEIPA) {
              Constraint_FORCE => {
                  inputsize = PAMax();
                  inputsizecheck = PAMax()
              },
              Constraint_FORCENOSLCHECK => {
                  inputsize = PAMax()
              },
              Constraint_FAULT => {
                  basefound = false
              },
              _ => {
                  Unreachable()
              }
            }
        } else ();
        let 'inputsizecheck = inputsizecheck;
        let 'startsizecheck = inputsizecheck - ((3 - level) * stride + grainsize);
        if startsizecheck < 1 | startsizecheck > stride + 4 then {
            basefound = false
        } else ()
    };
    let 'stride = stride;
    let 'inputsize = inputsize;
    let 'grainsize = grainsize;
    let 'firstblocklevel = firstblocklevel;
    if not_bool(basefound) | disabled then {
        level = 0;
        result.addrdesc.fault = AArch64_TranslationFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
        return(result)
    } else ();
    match ps {
      0b000 => {
          outputsize = 32
      },
      0b001 => {
          outputsize = 36
      },
      0b010 => {
          outputsize = 40
      },
      0b011 => {
          outputsize = 42
      },
      0b100 => {
          outputsize = 44
      },
      0b101 => {
          outputsize = 48
      },
      _ => {
          outputsize = __IMPDEF_integer("Reserved Intermediate Physical Address size value")
      }
    };
    if outputsize > PAMax() then {
        outputsize = PAMax()
    } else ();
    let 'outputsize = outputsize;
    if outputsize < 48 & not_bool(is_zero_subrange(baseregister, 47, outputsize)) then {
        level = 0;
        result.addrdesc.fault = AArch64_AddressSizeFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
        return(result)
    } else ();
    let 'baselowerbound = 3 + inputsize - ((3 - level) * stride + grainsize);
    assert(constraint((0 <= 'baselowerbound & 'baselowerbound <= 47)));
    baseaddress : bits(0 + (47 - 'baselowerbound + 1) + 'baselowerbound) = baseregister[47 .. baselowerbound] @ Zeros(baselowerbound);
    ns_table : bits(1) = if lookupsecure then 0b0 else 0b1;
    ap_table : bits(2) = 0b00;
    xn_table : bits(1) = 0b0;
    pxn_table : bits(1) = 0b0;
    addrselecttop : int = inputsize - 1;
    repeat {
        addrselectbottom = (3 - level) * stride + grainsize;
        let index : bits(48) = let 'addrselecttop = addrselecttop in
          {
              let 'addrselectbottom = addrselectbottom;
              assert(constraint((0 <= 'addrselectbottom & 'addrselectbottom <= 'addrselecttop & 'addrselecttop < 64)));
              assert(constraint(('addrselecttop - 'addrselectbottom + 1 + 3 >= 0 & 48 >= 'addrselecttop - 'addrselectbottom + 1 + 3)));
              ZeroExtend(inputaddr[addrselecttop .. addrselectbottom] @ 0b000)
          };
        descaddr.paddress.address = baseaddress | index;
        descaddr.paddress.NS = ns_table;
        if secondstage | not_bool(HasS2Translation()) then {
            descaddr2 = descaddr
        } else {
            hwupdatewalk = false;
            descaddr2 = AArch64_SecondStageWalk(descaddr, vaddress, acctype, iswrite, 8, hwupdatewalk);
            if IsFault(descaddr2) then {
                result.addrdesc.fault = descaddr2.fault;
                return(result)
            } else ()
        };
        descaddr2.vaddress = ZeroExtend(vaddress);
        accdesc = CreateAccessDescriptorPTW(acctype, secondstage, s2fs1walk, level);
        desc = _Mem_read(descaddr2, 8, accdesc);
        if reversedescriptors then {
            desc = BigEndianReverse(desc)
        } else ();
        if [desc[0]] == 0b0 | desc[1 .. 0] == 0b01 & level == 3 then {
            result.addrdesc.fault = AArch64_TranslationFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
            return(result)
        } else ();
        if desc[1 .. 0] == 0b01 | level == 3 then {
            blocktranslate = true
        } else {
            if outputsize != 48 & not_bool(is_zero_subrange(desc, 47, outputsize)) then {
                result.addrdesc.fault = AArch64_AddressSizeFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
                return(result)
            } else ();
            baseaddress = desc[47 .. grainsize] @ Zeros(grainsize);
            if not_bool(secondstage) then {
                ns_table = ns_table | [desc[63]]
            } else ();
            if not_bool(secondstage) & not_bool(hierattrsdisabled) then {
                ap_table[1] = Bit([ap_table[1]] | [desc[62]]);
                xn_table = xn_table | [desc[60]];
                if not_bool(singlepriv) then {
                    pxn_table = pxn_table | [desc[59]];
                    ap_table[0] = Bit([ap_table[0]] | [desc[61]])
                } else ()
            } else ();
            level = level + 1;
            addrselecttop = addrselectbottom - 1;
            blocktranslate = false
        }
    } until blocktranslate;
    let 'level = level;
    let 'addrselectbottom = addrselectbottom;
    if level < firstblocklevel then {
        result.addrdesc.fault = AArch64_TranslationFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
        return(result)
    } else ();
    if largegrain then {
        num_ch_entries = 5
    } else if midgrain then {
        if level == 3 then {
            num_ch_entries = 7
        } else {
            num_ch_entries = 5
        }
    } else {
        num_ch_entries = 4
    };
    let 'num_ch_entries = num_ch_entries;
    let contiguousbitcheck : bool = inputsize < addrselectbottom + num_ch_entries;
    if contiguousbitcheck & [desc[52]] == 0b1 then {
        if __IMPDEF_boolean("Translation fault on misprogrammed contiguous bit") then {
            result.addrdesc.fault = AArch64_TranslationFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
            return(result)
        } else ()
    } else ();
    assert(constraint((0 <= 'addrselectbottom & 'addrselectbottom <= 47)));
    assert(constraint((0 <= 'addrselectbottom - 1 & 'addrselectbottom - 1 < 64)));
    let outputaddress : bits(0 + (47 - 'addrselectbottom + 1) + (0 + ('addrselectbottom - 1 - 0 + 1))) = desc[47 .. addrselectbottom] @ inputaddr[addrselectbottom - 1 .. 0];
    if outputsize != 48 & not_bool(is_zero_subrange(desc, 47, outputsize)) then {
        result.addrdesc.fault = AArch64_AddressSizeFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
        return(result)
    } else ();
    if [desc[10]] == 0b0 then {
        if not_bool(update_AF) then {
            result.addrdesc.fault = AArch64_AccessFlagFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
            return(result)
        } else {
            result.descupdate.AF = true
        }
    } else ();
    if update_AP & [desc[51]] == 0b1 then {
        if not_bool(secondstage) & [desc[7]] == 0b1 then {
            desc[7] = Bit(0b0);
            result.descupdate.AP = true
        } else if secondstage & [desc[7]] == 0b0 then {
            desc[7] = Bit(0b1);
            result.descupdate.AP = true
        } else ()
    } else ();
    let ehwu : bits(4) = EffectiveHWU(PSTATE.EL, secondstage, [vaddress[55]]);
    let current_cdbm : bits(1) = [ehwu[0]] & [desc[59]];
    let current_sc : bits(1) = [ehwu[1]] & [desc[60]];
    if current_cdbm == 0b1 & current_sc == 0b0 then {
        result.descupdate.SC = true
    } else ();
    result.descupdate.descaddr = descaddr;
    let xn : bits(1) = [desc[54]];
    let pxn : bits(1) = [desc[53]];
    let ap : bits(3) = desc[7 .. 6] @ 0b1;
    let contiguousbit : bits(1) = [desc[52]];
    let nG : bits(1) = [desc[11]];
    let sh : bits(2) = desc[9 .. 8];
    let memattr : bits(4) = desc[5 .. 2];
    result.domain = __UNKNOWN_bits(4);
    result.level = level;
    assert(constraint((3 - 'level) * 'stride + 'grainsize >= 0));
    result.blocksize = 2 ^ ((3 - level) * stride + grainsize);
    if not_bool(secondstage) then {
        result.perms.xn = xn | xn_table;
        result.perms.ap[2 .. 2] = [ap[2]] | [ap_table[1]];
        if not_bool(singlepriv) then {
            result.perms.ap[1 .. 1] = [ap[1]] & not_vec([ap_table[0]]);
            result.perms.pxn = pxn | pxn_table;
            if IsSecure() then {
                result.nG = nG | ns_table
            } else {
                result.nG = nG
            }
        } else {
            result.perms.ap[1 .. 1] = 0b1;
            result.perms.pxn = 0b0;
            result.nG = 0b0
        };
        result.perms.ap[0 .. 0] = 0b1;
        result.addrdesc.memattrs = AArch64_S1AttrDecode(sh, memattr[2 .. 0], acctype);
        result.addrdesc.paddress.NS = [memattr[3]] | ns_table
    } else {
        result.perms.ap[2 .. 1] = ap[2 .. 1];
        result.perms.ap[0 .. 0] = 0b1;
        result.perms.xn = xn;
        if HaveExtendedExecuteNeverExt() then {
            result.perms.xxn = [desc[53]]
        } else ();
        result.perms.pxn = 0b0;
        result.nG = 0b0;
        if s2fs1walk then {
            result.addrdesc.memattrs = S2AttrDecode(sh, memattr, AccType_PTW)
        } else {
            result.addrdesc.memattrs = S2AttrDecode(sh, memattr, acctype)
        };
        result.addrdesc.paddress.NS = 0b1
    };
    if secondstage then {
        result.addrdesc.memattrs.readtagzero = ([ehwu[2]] & [desc[61]]) == 0b0;
        result.addrdesc.memattrs.readtagfault = false;
        result.addrdesc.memattrs.readtagfaulttgen = 0b0
    } else {
        result.addrdesc.memattrs.readtagzero = (ehwu[3 .. 2] & desc[62 .. 61]) == 0b00;
        result.addrdesc.memattrs.readtagfault = ([ehwu[3]] & [desc[62]]) == 0b1;
        result.addrdesc.memattrs.readtagfaulttgen = not_vec([ehwu[2]] & [desc[61]])
    };
    let cdbm : bits(1) = [ehwu[0]] & [desc[59]];
    let writetagfault : bool = cdbm == 0b0 & ([ehwu[1]] & [desc[60]]) == 0b0;
    result.addrdesc.memattrs.writetagfault = writetagfault;
    result.addrdesc.memattrs.iss2writetagfault = secondstage & writetagfault;
    result.addrdesc.paddress.address = outputaddress;
    result.addrdesc.fault = AArch64_NoFault();
    result.contiguous = contiguousbit == 0b1;
    if HaveCommonNotPrivateTransExt() then {
        result.CnP = [baseregister[0]]
    } else ();
    if __tlb_enabled then {
        TLBCache(ZeroExtend(inputaddr, 64), secondstage, acctype, result)
    } else ();
    return(result)
}

val AArch64_CheckPermission : forall ('iswrite : Bool)('level : Int).
  (Permissions, bits(64), int('level), bits(1), AccType, bool('iswrite)) -> FaultRecord effect {escape, rreg, undef}

function AArch64_CheckPermission (perms, vaddress, level, NS, acctype, iswrite) = {
    fail : bool = undefined;
    failedread : bool = undefined;
    ipaddress : bits(48) = undefined;
    is_ats1xp : bool = undefined;
    is_ldst : bool = undefined;
    ispriv : bool = undefined;
    pan : bits(1) = undefined;
    priv_r : bool = undefined;
    priv_w : bool = undefined;
    priv_xn : bool = undefined;
    r : bool = undefined;
    s2fs1walk : bool = undefined;
    secondstage : bool = undefined;
    user_r : bool = undefined;
    user_w : bool = undefined;
    user_xn : bool = undefined;
    w : bool = undefined;
    xn : bool = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    let wxn : bool = [SCTLR_read__1()[19]] == 0b1;
    if (PSTATE.EL == EL0 | IsInHost()) | PSTATE.EL == EL1 then {
        priv_r : bool = true;
        priv_w : bool = [perms.ap[2]] == 0b0;
        let user_r : bool = [perms.ap[1]] == 0b1;
        let user_w : bool = perms.ap[2 .. 1] == 0b01;
        let ispriv : bool = AArch64_AccessIsPrivileged(acctype);
        let pan : bits(1) = if HavePANExt() then PSTATE.PAN else 0b0;
        let is_ldst : bool = not_bool(acctype == AccType_DC | acctype == AccType_DC_UNPRIV | acctype == AccType_AT | acctype == AccType_IFETCH);
        let is_ats1xp : bool = acctype == AccType_AT & AArch64_ExecutingATS1xPInstr();
        if ((pan == 0b1 & user_r) & ispriv) & (is_ldst | is_ats1xp) then {
            priv_r = false;
            priv_w = false
        } else ();
        let user_xn : bool = perms.xn == 0b1 | user_w & wxn;
        let priv_xn : bool = (perms.pxn == 0b1 | priv_w & wxn) | user_w;
        if ispriv then {
            (r, w, xn) = (priv_r, priv_w, priv_xn)
        } else {
            (r, w, xn) = (user_r, user_w, user_xn)
        }
    } else {
        r = true;
        w = [perms.ap[2]] == 0b0;
        xn = perms.xn == 0b1 | w & wxn
    };
    if ((HaveEL(EL3) & IsSecure()) & NS == 0b1) & Slice(SCR_EL3, 9, 1) == 0b1 then {
        xn = true
    } else ();
    let xn = xn;
    if acctype == AccType_IFETCH then {
        fail = xn;
        failedread = true
    } else if acctype == AccType_ATOMICRW | acctype == AccType_ORDEREDRW | acctype == AccType_ORDEREDATOMICRW then {
        fail = not_bool(r) | not_bool(w);
        failedread = not_bool(r)
    } else if iswrite then {
        fail = not_bool(w);
        failedread = false
    } else if acctype == AccType_DC & PSTATE.EL != EL0 then {
        fail = false
    } else {
        fail = not_bool(r);
        failedread = true
    };
    if fail then {
        let secondstage : bool = false;
        let s2fs1walk : bool = false;
        let ipaddress : bits(48) = __UNKNOWN_bits(48);
        return(AArch64_PermissionFault(ipaddress, level, acctype, not_bool(failedread), secondstage, s2fs1walk))
    } else {
        return(AArch64_NoFault())
    }
}

val AArch64_IsStageOneEnabled : AccType -> bool effect {escape, rreg, undef}

function AArch64_IsStageOneEnabled acctype = {
    s1_enabled : bool = undefined;
    if HasS2Translation() then {
        s1_enabled = (Slice(HCR_EL2, 27, 1) == 0b0 & Slice(HCR_EL2, 12, 1) == 0b0) & Slice(SCTLR_EL1, 0, 1) == 0b1
    } else {
        s1_enabled = [SCTLR_read__1()[0]] == 0b1
    };
    return(s1_enabled)
}

val AArch64_TranslateAddressS1Off : forall ('iswrite : Bool).
  (bits(64), AccType, bool('iswrite)) -> TLBRecord effect {escape, rreg, undef}

function AArch64_TranslateAddressS1Off (vaddress, acctype, iswrite) = {
    cacheable : bool = undefined;
    ipaddress : bits(48) = undefined;
    level : int = undefined;
    s2fs1walk : bool = undefined;
    secondstage : bool = undefined;
    assert(not_bool(ELUsingAArch32(S1TranslationRegime__1())));
    result : TLBRecord = undefined;
    result.descupdate.AF = false;
    result.descupdate.AP = false;
    result.descupdate.SC = false;
    let 'Top = AddrTop(vaddress, PSTATE.EL);
    if not_bool(is_zero_subrange(vaddress, Top, PAMax())) then {
        let 'level = 0;
        let ipaddress : bits(48) = undefined : bits(48);
        let secondstage : bool = false;
        let s2fs1walk : bool = false;
        result.addrdesc.fault = AArch64_AddressSizeFault(ipaddress, level, acctype, iswrite, secondstage, s2fs1walk);
        return(result)
    } else ();
    let default_cacheable : bool = HasS2Translation() & Slice(HCR_EL2, 12, 1) == 0b1;
    if default_cacheable then {
        result.addrdesc.memattrs.memtype = MemType_Normal;
        result.addrdesc.memattrs.inner.attrs = MemAttr_WB;
        result.addrdesc.memattrs.inner.hints = MemHint_RWA;
        result.addrdesc.memattrs.shareable = false;
        result.addrdesc.memattrs.outershareable = false
    } else if acctype != AccType_IFETCH then {
        result.addrdesc.memattrs.memtype = MemType_Device;
        result.addrdesc.memattrs.device = DeviceType_nGnRnE;
        result.addrdesc.memattrs.inner = undefined : MemAttrHints
    } else {
        let cacheable : bool = [SCTLR_read__1()[12]] == 0b1;
        result.addrdesc.memattrs.memtype = MemType_Normal;
        if cacheable then {
            result.addrdesc.memattrs.inner.attrs = MemAttr_WT;
            result.addrdesc.memattrs.inner.hints = MemHint_RA
        } else {
            result.addrdesc.memattrs.inner.attrs = MemAttr_NC;
            result.addrdesc.memattrs.inner.hints = MemHint_No
        };
        result.addrdesc.memattrs.shareable = true;
        result.addrdesc.memattrs.outershareable = true
    };
    result.addrdesc.memattrs.outer = result.addrdesc.memattrs.inner;
    result.addrdesc.memattrs = MemAttrDefaults(result.addrdesc.memattrs);
    result.perms.ap = undefined : bits(3);
    result.perms.xn = 0b0;
    result.perms.pxn = 0b0;
    result.nG = undefined : bits(1);
    result.contiguous = undefined : bool;
    result.domain = undefined : bits(4);
    result.level = undefined : int;
    result.blocksize = undefined : int;
    result.addrdesc.paddress.address = vaddress[47 .. 0];
    result.addrdesc.paddress.NS = if IsSecure() then 0b0 else 0b1;
    result.addrdesc.fault = AArch64_NoFault();
    return(result)
}

val AArch64_FirstStageTranslateWithTag : forall ('iswrite : Bool) ('iswritevalidcap : Bool) 'size ('wasaligned : Bool).
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size), bool('iswritevalidcap)) -> AddressDescriptor effect {escape, rreg, undef}

function AArch64_FirstStageTranslateWithTag (vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap) = {
    S1 : TLBRecord = undefined;
    permissioncheck : bool = undefined;
    let s1_enabled : bool = AArch64_IsStageOneEnabled(acctype);
    let ipaddress : bits(48) = __UNKNOWN_bits(48);
    let secondstage : bool = false;
    s2fs1walk : bool = false;
    if s1_enabled then {
        S1 = AArch64_TranslationTableWalk(ipaddress, vaddress, acctype, iswrite, secondstage, s2fs1walk, size);
        permissioncheck = true
    } else {
        S1 = AArch64_TranslateAddressS1Off(vaddress, acctype, iswrite);
        permissioncheck = false
    };
    if ((not_bool(wasaligned) & acctype != AccType_IFETCH | acctype == AccType_DCZVA) & not_bool(IsFault(S1.addrdesc))) & S1.addrdesc.memattrs.memtype == MemType_Device then {
        S1.addrdesc.fault = AArch64_AlignmentFault(acctype, iswrite, secondstage)
    } else ();
    if not_bool(IsFault(S1.addrdesc)) & permissioncheck then {
        S1.addrdesc.fault = AArch64_CheckPermission(S1.perms, vaddress, S1.level, S1.addrdesc.paddress.NS, acctype, iswrite)
    } else ();
    if (not_bool(IsFault(S1.addrdesc)) & S1.addrdesc.memattrs.memtype == MemType_Device) & acctype == AccType_IFETCH then {
        S1.addrdesc = AArch64_InstructionDevice(S1.addrdesc, vaddress, ipaddress, S1.level, acctype, iswrite, secondstage, s2fs1walk)
    } else ();
    let hwupdatewalk : bool = false;
    let s2fs1walk : bool = false;
    S1.addrdesc.fault = AArch64_CheckAndUpdateDescriptor(S1.descupdate, S1.addrdesc.fault, secondstage, vaddress, acctype, iswrite, s2fs1walk, hwupdatewalk, iswritevalidcap);
    return(S1.addrdesc)
}

val AArch64_FullTranslateWithTag : forall ('iswrite : Bool) ('iswritevalidcap : Bool) 'size ('wasaligned : Bool).
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size), bool('iswritevalidcap)) -> AddressDescriptor effect {escape, rreg, undef}

function AArch64_FullTranslateWithTag (vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap__arg) = {
    iswritevalidcap : bool = iswritevalidcap__arg;
    hwupdatewalk : bool = undefined;
    result : AddressDescriptor = undefined;
    s2fs1walk : bool = undefined;
    let S1 : AddressDescriptor = AArch64_FirstStageTranslateWithTag(vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap);
    if not_bool(IsFault(S1)) & HasS2Translation() then {
        let s2fs1walk : bool = false;
        let hwupdatewalk : bool = false;
        if S1.memattrs.writetagfault then {
            iswritevalidcap = false
        } else ();
        result = AArch64_SecondStageTranslate(S1, vaddress, acctype, iswrite, wasaligned, s2fs1walk, size, hwupdatewalk, iswritevalidcap)
    } else {
        result = S1
    };
    return(result)
}

val AArch64_TranslateAddressWithTag : forall ('iswrite : Bool) ('iswritevalidcap : Bool) 'size ('wasaligned : Bool).
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size), bool('iswritevalidcap)) -> AddressDescriptor effect {escape, rreg, undef, wreg}

function AArch64_TranslateAddressWithTag (vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap) = {
    assert(iswrite | not_bool(iswritevalidcap));
    result : AddressDescriptor = AArch64_FullTranslateWithTag(vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap);
    if not_bool(acctype == AccType_PTW | acctype == AccType_IC | acctype == AccType_AT) & not_bool(IsFault(result)) then {
        result.fault = AArch64_CheckDebug(vaddress, acctype, iswrite, size)
    } else ();
    result.vaddress = ZeroExtend(vaddress);
    return(result)
}

val AArch64_TranslateAddress : forall ('iswrite : Bool) 'size ('wasaligned : Bool).
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rreg, undef, wreg}

function AArch64_TranslateAddress (vaddress, acctype, iswrite, wasaligned, size) = {
    let iswritevalidcap : bool = false;
    return(AArch64_TranslateAddressWithTag(vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap))
}

val AArch64_MemSingle_read : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bool('wasaligned)) -> bits('size * 8) effect {escape, rreg, undef, wreg}

function AArch64_MemSingle_read (address, size, acctype, wasaligned) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    let iswrite : bool = false;
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    let value_name : bits('size * 8) = _Mem_read(memaddrdesc, size, accdesc);
    return(value_name)
}

val AArch64_MemSingle_set : forall 'size ('wasaligned : Bool),
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType, bool('wasaligned), bits('size * 8)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_MemSingle_set (address, size, acctype, wasaligned, value_name) = {
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    assert(address == Align(address, size));
    let iswrite : bool = true;
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    } else ();
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    _Mem_set(memaddrdesc, size, accdesc) = value_name;
    return()
}

val AArch64_CapabilityPagePermissionFault : forall ('is_store 'secondstage : Bool).
  (AccType, bool('secondstage), bool('is_store)) -> FaultRecord effect {undef}

function AArch64_CapabilityPagePermissionFault (acctype, secondstage, is_store) = {
    let ipaddress : bits(48) = __UNKNOWN_bits(48);
    let errortype : bits(2) = __UNKNOWN_bits(2);
    let 'level = __UNKNOWN_integer();
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let s2fs1walk : bool = false;
    return(AArch64_CreateFaultRecord(Fault_CapPagePerm, ipaddress, level, acctype, is_store, extflag, errortype, secondstage, s2fs1walk))
}

val CheckLoadTagsPermission : (AddressDescriptor, AccType) -> unit effect {escape, rreg, undef, wreg}

function CheckLoadTagsPermission (desc, acctype) = {
    is_store : bool = undefined;
    secondstage : bool = undefined;
    if desc.memattrs.readtagfault then {
        let fault_tgen : bits(1) = desc.memattrs.readtagfaulttgen;
        if EffectiveTGEN(desc.vaddress, PSTATE.EL) == fault_tgen then {
            let secondstage : bool = false;
            let is_store : bool = false;
            let fault : FaultRecord = AArch64_CapabilityPagePermissionFault(acctype, secondstage, is_store);
            AArch64_Abort(desc.vaddress, fault)
        } else ()
    } else ()
}

val CheckStoreTagsPermission : (AddressDescriptor, AccType) -> unit effect {escape, rreg, undef, wreg}

function CheckStoreTagsPermission (desc, acctype) = {
    is_store : bool = undefined;
    if desc.memattrs.writetagfault then {
        let is_store : bool = true;
        let fault : FaultRecord = AArch64_CapabilityPagePermissionFault(acctype, desc.memattrs.iss2writetagfault, is_store);
        AArch64_Abort(desc.vaddress, fault)
    } else ()
}

val _ReadMem : forall ('size : Int), 'size > 0.
  (AddressDescriptor, int('size), AccessDescriptor) -> bits(8 * 'size)

val _ReadTaggedMem : forall ('size : Int), 'size in {16, 32}.
  (AddressDescriptor, int('size), AccessDescriptor) -> (bits(div('size, 16)), bits(8 * 'size))

val _WriteTaggedMem : forall ('size : Int), 'size in {16, 32}.
  (AddressDescriptor, int('size), AccessDescriptor, bits(div('size, 16)), bits(8 * 'size)) -> unit

val AArch64_TaggedMemSingle : forall 'size ('wasaligned : Bool),
  'size in {16, 32}.
  (bits(64), int('size), AccType, bool('wasaligned)) -> (bits(div('size, 16)), bits('size * 8)) effect {escape, rreg, undef, wreg}

val AArch64_TaggedMemSingle__1 : forall 'size ('wasaligned : Bool),
  'size in {16, 32}.
  (bits(64), int('size), AccType, bool('wasaligned), bits(div('size, 16)), bits('size * 8)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_TaggedMemSingle (address, size, acctype, wasaligned) = {
    assert(size == 16 | size == 32);
    assert(address == Align(address, 16));
    value_name : bits('size * 8) = undefined;
    tags : bits(div('size, 16)) = undefined;
    let iswrite : bool = false;
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    if memaddrdesc.memattrs.memtype == MemType_Device then {
        CheckLoadTagsPermission(memaddrdesc, acctype)
    } else ();
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    if memaddrdesc.memattrs.readtagzero then {
        value_name = _ReadMem(memaddrdesc, size, accdesc);
        tags = Zeros(DIV(size, 16))
    } else {
        (tags, value_name) = _ReadTaggedMem(memaddrdesc, size, accdesc);
        if tags != Zeros(DIV(size, 16)) then {
            CheckLoadTagsPermission(memaddrdesc, acctype)
        } else ()
    };
    return((tags, value_name))
}

function AArch64_TaggedMemSingle__1 (address, size, acctype, wasaligned, tags, value_name) = {
    assert(size == 16 | size == 32);
    assert(address == Align(address, 16));
    let iswrite : bool = true;
    let valid_cap_name : bool = tags != Zeros(DIV(size, 16));
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddressWithTag(address, acctype, iswrite, wasaligned, size, valid_cap_name);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    } else ();
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    if tags != Zeros(DIV(size, 16)) then {
        CheckStoreTagsPermission(memaddrdesc, acctype)
    } else ();
    _WriteTaggedMem(memaddrdesc, size, accdesc, tags, value_name);
    return()
}

val CheckCapabilityAlignment : forall ('iswrite : Bool).
  (bits(64), AccType, bool('iswrite)) -> unit effect {escape, rreg, undef, wreg}

function CheckCapabilityAlignment (address, acctype, iswrite) = {
    secondstage : bool = undefined;
    if address != Align(address, CAPABILITY_DBYTES) then {
        let secondstage : bool = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    } else ()
}

val _ReadTags : forall ('size : Int), 'size >= 0.
  (AddressDescriptor, int('size), AccessDescriptor) -> bits('size)

val AArch64_CapabilityTag : (bits(64), AccType) -> bits(1) effect {escape, rreg, undef, wreg}

function AArch64_CapabilityTag (address, acctype) = {
    let iswrite : bool = false;
    CheckCapabilityAlignment(address, acctype, iswrite);
    let wasaligned : bool = true;
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, wasaligned, DIV(CAPABILITY_DBYTES, 8));
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    if memaddrdesc.memattrs.memtype == MemType_Device then {
        CheckLoadTagsPermission(memaddrdesc, acctype)
    } else ();
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    tag : bits(1) = undefined;
    if memaddrdesc.memattrs.readtagzero then {
        tag = 0b0
    } else {
        let paddress : bits(48) = memaddrdesc.paddress.address;
        assert(paddress == Align(paddress, CAPABILITY_DBYTES));
        tag = _ReadTags(memaddrdesc, 1, accdesc);
        if tag == 0b1 then {
            CheckLoadTagsPermission(memaddrdesc, acctype)
        } else ()
    };
    return(tag)
}

val _WriteTags : forall ('size : Int), 'size >= 0.
  (AddressDescriptor, int('size), bits('size), AccessDescriptor) -> unit

val AArch64_CapabilityTag_set : (bits(64), AccType, bits(1)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CapabilityTag_set (address, acctype, tag) = {
    let iswrite : bool = true;
    CheckCapabilityAlignment(address, acctype, iswrite);
    let wasaligned : bool = true;
    let valid_cap_name : bool = tag == 0b1;
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddressWithTag(address, acctype, iswrite, wasaligned, CAPABILITY_DBYTES, valid_cap_name);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), CAPABILITY_DBYTES)
    } else ();
    let accdesc : AccessDescriptor = CreateAccessDescriptor(acctype);
    let paddress : bits(48) = memaddrdesc.paddress.address;
    assert(paddress == Align(paddress, CAPABILITY_DBYTES));
    if tag == 0b1 then {
        CheckStoreTagsPermission(memaddrdesc, acctype)
    } else ();
    _WriteTags(memaddrdesc, 1, tag, accdesc);
    return()
}

val Mem_read : forall 'size,
  'size in {1, 2, 4, 8, 16}.
  (bits(64), int('size), AccType) -> bits('size * 8) effect {escape, rreg, undef, wreg}

function Mem_read (address, size, acctype) = {
    atomic : bool = undefined;
    c : Constraint = undefined;
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    value_name : bits('size * 8) = undefined;
    let iswrite : bool = false;
    aligned : bool = AArch64_CheckAlignment(address, size, acctype, iswrite);
    if size != 16 | not_bool(acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        atomic = aligned
    } else {
        atomic = address == Align(address, 8)
    };
    if not_bool(atomic) then {
        assert(size > 1);
        value_name[7 .. 0] = AArch64_MemSingle_read(address, 1, acctype, aligned);
        if not_bool(aligned) then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            } else ()
        } else ();
        foreach (i from 1 to (size - 1) by 1 in inc) {
            value_name[8 * i + 7 .. 8 * i] = AArch64_MemSingle_read(address + i, 1, acctype, aligned)
        }
    } else if size == 16 & (acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        value_name[63 .. 0] = AArch64_MemSingle_read(address, 8, acctype, aligned);
        value_name[127 .. 64] = AArch64_MemSingle_read(address + 8, 8, acctype, aligned)
    } else {
        value_name = AArch64_MemSingle_read(address, size, acctype, aligned)
    };
    if BigEndian() then {
        value_name = BigEndianReverse(value_name)
    } else ();
    let value_name = value_name;
    return(value_name)
}

val Mem_set : forall 'size,
  ('size * 8 == 8 | 'size * 8 == 16 | 'size * 8 == 32 | 'size * 8 == 64 | 'size * 8 == 128).
  (bits(64), int('size), AccType, bits('size * 8)) -> unit effect {escape, rreg, undef, wreg}

function Mem_set (address, size, acctype, value_name__arg) = {
    value_name : bits('size * 8) = value_name__arg;
    atomic : bool = undefined;
    c : Constraint = undefined;
    let iswrite : bool = true;
    if BigEndian() then {
        value_name = BigEndianReverse(value_name)
    } else ();
    aligned : bool = AArch64_CheckAlignment(address, size, acctype, iswrite);
    if size != 16 | not_bool(acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        atomic = aligned
    } else {
        atomic = address == Align(address, 8)
    };
    if not_bool(atomic) then {
        assert(size > 1);
        AArch64_MemSingle_set(address, 1, acctype, aligned) = value_name[7 .. 0];
        if not_bool(aligned) then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DEVPAGE2);
            assert(c == Constraint_FAULT | c == Constraint_NONE);
            if c == Constraint_NONE then {
                aligned = true
            } else ()
        } else ();
        foreach (i from 1 to (size - 1) by 1 in inc) {
            AArch64_MemSingle_set(address + i, 1, acctype, aligned) = value_name[8 * i + 7 .. 8 * i]
        }
    } else if size == 16 & (acctype == AccType_VEC | acctype == AccType_VECSTREAM) then {
        AArch64_MemSingle_set(address, 8, acctype, aligned) = value_name[63 .. 0];
        AArch64_MemSingle_set(address + 8, 8, acctype, aligned) = value_name[127 .. 64]
    } else {
        AArch64_MemSingle_set(address, size, acctype, aligned) = value_name
    };
    return()
}

let CAPABILITY_DBITS : int(CAPABILITY_DBYTES * 8) = CAPABILITY_DBYTES * 8

type CAPABILITY_DBITS : Int = CAPABILITY_DBYTES * 8

val CheckCapabilityStorePairAlignment : forall ('iswrite : Bool).
  (bits(64), AccType, bool('iswrite)) -> unit effect {escape, rreg, undef, wreg}

function CheckCapabilityStorePairAlignment (address, acctype, iswrite) = {
    secondstage : bool = undefined;
    let atomic : bool = acctype == AccType_ATOMIC | acctype == AccType_ORDEREDATOMIC;
    let 'size = if atomic then CAPABILITY_DBYTES * 2 else CAPABILITY_DBYTES;
    if address != Align(address, size) then {
        let secondstage : bool = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    } else ()
}

val CapabilityFromData : forall ('size : Int), (0 <= 'size - 1 & 'size - 1 < 129).
  (int('size), bits(1), bits('size)) -> bits(129) effect {undef}

function CapabilityFromData (size, tag, data) = {
    c : bits(129) = undefined;
    c[size - 1 .. 0] = data;
    c[CAP_TAG_BIT] = Bit(tag);
    return(c)
}

val MemC_read : (bits(64), AccType) -> bits(129) effect {escape, rreg, undef, wreg}

function MemC_read (address, acctype) = {
    let iswrite : bool = false;
    data : bits(8 * CAPABILITY_DBYTES) = undefined;
    tag : bits(div(CAPABILITY_DBYTES, 16)) = undefined;
    CheckCapabilityAlignment(address, acctype, iswrite);
    (tag, data) = AArch64_TaggedMemSingle(address, CAPABILITY_DBYTES, acctype, true);
    let cap : bits(129) = CapabilityFromData(CAPABILITY_DBITS, [tag[0]], data[CAPABILITY_DBITS - 1 .. 0]);
    return(cap)
}

val DataFromCapability : forall ('size : Int), (0 <= 'size - 1 & 'size - 1 < 129).
  (int('size), bits(129)) -> (bits(1), bits('size))

function DataFromCapability (size, c) = {
    return(([c[CAP_TAG_BIT]], c[size - 1 .. 0]))
}

val MemC_set : (bits(64), AccType, bits(129)) -> unit effect {escape, rreg, undef, wreg}

function MemC_set (address, acctype, value_name) = {
    let iswrite : bool = true;
    data : bits(CAPABILITY_DBITS) = undefined;
    tag : bits(div(CAPABILITY_DBYTES, 16)) = undefined;
    (tag[0 .. 0], data) = DataFromCapability(CAPABILITY_DBITS, value_name);
    CheckCapabilityAlignment(address, acctype, iswrite);
    AArch64_TaggedMemSingle__1(address, CAPABILITY_DBYTES, acctype, true, tag, data[CAPABILITY_DBYTES * 8 - 1 .. 0])
}

val MemCP__1 : (bits(64), AccType, bits(129), bits(129)) -> unit effect {escape, rreg, undef, wreg}

function MemCP__1 (address, acctype, value1_name, value2_name) = {
    let iswrite : bool = true;
    let 'size = CAPABILITY_DBYTES * 2;
    tags : bits(div('size, 16)) = undefined;
    data : bits(8 * 'size) = undefined;
    (tags[0 .. 0], data[CAPABILITY_DBITS - 1 .. 0]) = DataFromCapability(CAPABILITY_DBITS, value1_name);
    (tags[1 .. 1], data[CAPABILITY_DBITS * 2 - 1 .. CAPABILITY_DBITS]) = DataFromCapability(CAPABILITY_DBITS, value2_name);
    CheckCapabilityStorePairAlignment(address, acctype, iswrite);
    AArch64_TaggedMemSingle__1(address, size, acctype, true, tags, data)
}

val AArch64_TranslateAddressForAtomicAccess : forall ('sizeinbits : Int).
  (bits(64), int('sizeinbits)) -> AddressDescriptor effect {escape, rreg, undef, wreg}

function AArch64_TranslateAddressForAtomicAccess (address, sizeinbits) = {
    let iswrite : bool = false;
    let 'size = DIV(sizeinbits, 8);
    assert(size == 1 | size == 2 | size == 4 | size == 8 | size == 16);
    let aligned : bool = AArch64_CheckAlignment(address, size, AccType_ATOMICRW, iswrite);
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, AccType_ATOMICRW, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    if memaddrdesc.memattrs.shareable then {
        ClearExclusiveByAddress(memaddrdesc.paddress, ProcessorID(), size)
    } else ();
    return(memaddrdesc)
}

val CapIsExecutePermitted : bits(129) -> bool

function CapIsExecutePermitted c = {
    return(CapCheckPermissions(c, CAP_PERM_EXECUTE))
}

val CapUnsignedLessThanOrEqual : forall ('N : Int). (bits('N), bits('N)) -> bool

function CapUnsignedLessThanOrEqual (a, b) = {
    return(UInt(a) <= UInt(b))
}

val CapIsRangeInBounds : (bits(129), bits(CAP_VALUE_NUM_BITS), bits(CAP_VALUE_NUM_BITS + 1)) -> bool effect {escape, undef}

function CapIsRangeInBounds (c, start_address, length) = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    limit : bits(CAP_BOUND_NUM_BITS) = undefined;
    valid_name : bool = undefined;
    (base, limit, valid_name) = CapGetBounds(c);
    let start_ext : bits(65) = 0b0 @ start_address;
    let limit_ext : bits(65) = start_ext + length;
    return((CapUnsignedGreaterThanOrEqual(start_ext, base) & CapUnsignedLessThanOrEqual(limit_ext, limit)) & valid_name)
}

val CapGetTag : bits(129) -> bits(64)

function CapGetTag c = {
    return(ZeroExtend([c[CAP_TAG_BIT]], 64))
}

val CapIsTagClear : bits(129) -> bool

function CapIsTagClear c = {
    return([CapGetTag(c)[0]] == 0b0)
}

val CapPermsInclude : (bits(64), bits(64)) -> bool

function CapPermsInclude (perms, mask) = {
    return((perms[CAP_PERMS_NUM_BITS - 1 .. 0] & mask[CAP_PERMS_NUM_BITS - 1 .. 0]) == mask[CAP_PERMS_NUM_BITS - 1 .. 0])
}

val CapabilityFault : forall ('iswrite : Bool).
  (Fault, AccType, bool('iswrite)) -> FaultRecord effect {undef}

function CapabilityFault (faulttype, acctype, iswrite) = {
    let ipaddress : bits(48) = __UNKNOWN_bits(48);
    let 'level = __UNKNOWN_integer();
    extflag : bits(1) = __UNKNOWN_bits(1);
    let secondstage : bool = false;
    let s2fs1walk : bool = false;
    let extflag : bits(1) = __UNKNOWN_bits(1);
    let ns : bool = false;
    let errortype : bits(2) = __UNKNOWN_bits(2);
    return(AArch64_CreateFaultRecord(faulttype, ipaddress, level, acctype, iswrite, extflag, errortype, secondstage, s2fs1walk))
}

val CheckCapability : forall ('size : Int).
  (bits(129), bits(64), int('size), bits(64), AccType) -> bits(64) effect {escape, rreg, undef, wreg}

function CheckCapability (c, address, size, requested_perms, acctype) = {
    let el : bits(2) = AArch64_AccessUsesEL(acctype);
    let 'msbit = AddrTop(address, el);
    let s1_enabled : bool = AArch64_IsStageOneEnabled(acctype);
    addressforbounds : bits(64) = address;
    if msbit != 63 then {
        if s1_enabled then {
            if ((el == EL0 | el == EL1) | ELIsInHost(el)) & [address[msbit]] == 0b1 then {
                addressforbounds = SignExtend(address[msbit .. 0])
            } else {
                addressforbounds = ZeroExtend(address[msbit .. 0])
            }
        } else {
            addressforbounds = ZeroExtend(address[msbit .. 0])
        }
    } else ();
    fault_type : Fault = Fault_None;
    if CapIsTagClear(c) then {
        fault_type = Fault_CapTag
    } else if CapIsSealed(c) then {
        fault_type = Fault_CapSeal
    } else if not_bool(CapCheckPermissions(c, requested_perms)) then {
        fault_type = Fault_CapPerm
    } else if (requested_perms & CAP_PERM_EXECUTE) != CAP_PERM_NONE & not_bool(CapIsExecutePermitted(c)) then {
        fault_type = Fault_CapPerm
    } else if not_bool(CapIsRangeInBounds(c, addressforbounds, size[64 .. 0])) then {
        fault_type = Fault_CapBounds
    } else ();
    if fault_type != Fault_None then {
        let is_store : bool = CapPermsInclude(requested_perms, CAP_PERM_STORE);
        let fault : FaultRecord = CapabilityFault(fault_type, acctype, is_store);
        AArch64_Abort(address, fault)
    } else ();
    return(address)
}

val VACheckAddress : forall ('size : Int).
  (VirtualAddress, bits(64), int('size), bits(64), AccType) -> unit effect {escape, rreg, undef, wreg}

function VACheckAddress (base, addr64, size, requested_perms, acctype) = {
    c : bits(129) = undefined;
    if VAIsBits64(base) then {
        c = DDC_read()
    } else {
        c = VAToCapability(base)
    };
    __ignore_13 = CheckCapability(c, addr64, size, requested_perms, acctype)
}

val CapGetBase : bits(129) -> bits(CAP_VALUE_NUM_BITS) effect {escape, undef}

function CapGetBase c = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    (base, __ignore_14, __ignore_15) = CapGetBounds(c);
    return(Slice(base, 0, CAP_VALUE_NUM_BITS))
}

val VAddress : VirtualAddress -> bits(64) effect {escape, rreg, undef}

function VAddress addr = {
    addr64 : bits(64) = undefined;
    if VAIsBits64(addr) then {
        if [CCTLR_read__1()[2]] == 0b1 then {
            addr64 = VAToBits64(addr) + CapGetBase(DDC_read())
        } else {
            addr64 = VAToBits64(addr)
        }
    } else {
        let c : bits(129) = VAToCapability(addr);
        addr64 = CapGetValue(c)[63 .. 0]
    };
    return(addr64)
}

val MemAtomicCompareAndSwap : forall ('size : Int), 'size in {8, 16, 32, 64, 128}.
  (VirtualAddress, bits('size), bits('size), AccType, AccType) -> bits('size) effect {escape, rreg, undef, wreg}

function MemAtomicCompareAndSwap (base, expectedvalue, newvalue__arg, ldacctype, stacctype) = {
    newvalue : bits('size) = newvalue__arg;
    let address : bits(64) = VAddress(base);
    VACheckAddress(base, address, DIV('size, 8), CAP_PERM_LOAD, ldacctype);
    VACheckAddress(base, address, DIV('size, 8), CAP_PERM_STORE, stacctype);
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddressForAtomicAccess(address, 'size);
    let ldaccdesc : AccessDescriptor = CreateAccessDescriptor(ldacctype);
    let staccdesc : AccessDescriptor = CreateAccessDescriptor(stacctype);
    oldvalue : bits(8 * div('size, 8)) = _Mem_read(memaddrdesc, DIV('size, 8), ldaccdesc);
    if BigEndian() then {
        oldvalue = BigEndianReverse(oldvalue)
    } else ();
    if oldvalue == expectedvalue then {
        if BigEndian() then {
            newvalue = BigEndianReverse(newvalue)
        } else ();
        _Mem_set(memaddrdesc, DIV('size, 8), staccdesc) = newvalue
    } else ();
    return(oldvalue)
}

val MemAtomic : forall ('size : Int), 'size in {8, 16, 32, 64, 128}.
  (VirtualAddress, MemAtomicOp, bits('size), AccType, AccType) -> bits('size) effect {escape, rreg, undef, wreg}

function MemAtomic (base, op, value_name, ldacctype, stacctype) = {
    let address : bits(64) = VAddress(base);
    VACheckAddress(base, address, DIV('size, 8), CAP_PERM_LOAD, ldacctype);
    VACheckAddress(base, address, DIV('size, 8), CAP_PERM_STORE, stacctype);
    newvalue : bits('size) = undefined;
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddressForAtomicAccess(address, 'size);
    let ldaccdesc : AccessDescriptor = CreateAccessDescriptor(ldacctype);
    let staccdesc : AccessDescriptor = CreateAccessDescriptor(stacctype);
    oldvalue : bits(8 * div('size, 8)) = _Mem_read(memaddrdesc, DIV('size, 8), ldaccdesc);
    if BigEndian() then {
        oldvalue = BigEndianReverse(oldvalue)
    } else ();
    match op {
      MemAtomicOp_ADD => {
          newvalue = oldvalue + value_name
      },
      MemAtomicOp_BIC => {
          newvalue = oldvalue & not_vec(value_name)
      },
      MemAtomicOp_EOR => {
          newvalue = EOR(oldvalue, value_name)
      },
      MemAtomicOp_ORR => {
          newvalue = oldvalue | value_name
      },
      MemAtomicOp_SMAX => {
          newvalue = if SInt(oldvalue) > SInt(value_name) then oldvalue else value_name
      },
      MemAtomicOp_SMIN => {
          newvalue = if SInt(oldvalue) > SInt(value_name) then value_name else oldvalue
      },
      MemAtomicOp_UMAX => {
          newvalue = if UInt(oldvalue) > UInt(value_name) then oldvalue else value_name
      },
      MemAtomicOp_UMIN => {
          newvalue = if UInt(oldvalue) > UInt(value_name) then value_name else oldvalue
      },
      MemAtomicOp_SWP => {
          newvalue = value_name
      }
    };
    if BigEndian() then {
        newvalue = BigEndianReverse(newvalue)
    } else ();
    _Mem_set(memaddrdesc, DIV('size, 8), staccdesc) = newvalue;
    return(oldvalue)
}

val CapIsEqual : (bits(129), bits(129)) -> bool

function CapIsEqual (c1, c2) = {
    return(c1 == c2)
}

val CapClearPerms : (bits(129), bits(64)) -> bits(129)

function CapClearPerms (c__arg, mask) = {
    c : bits(129) = c__arg;
    let old_perms : bits(CAP_PERMS_NUM_BITS) = CapGetPermissions(c);
    let new_perms : bits(CAP_PERMS_NUM_BITS) = old_perms & not_vec(mask[CAP_PERMS_NUM_BITS - 1 .. 0]);
    c[CAP_PERMS_HI_BIT .. CAP_PERMS_LO_BIT] = new_perms[CAP_PERMS_NUM_BITS - 1 .. 0];
    return(c)
}

val CapIsMutableLoadPermitted : bits(129) -> bool

function CapIsMutableLoadPermitted c = {
    return(CapCheckPermissions(c, CAP_PERM_MUTABLE_LOAD))
}

val CapIsTagSet : bits(129) -> bool

function CapIsTagSet c = {
    return([CapGetTag(c)[0]] == 0b1)
}

val CapSquashPostLoadCap : (bits(129), VirtualAddress) -> bits(129) effect {escape, rreg, undef}

function CapSquashPostLoadCap (data__arg, addr) = {
    data : bits(129) = data__arg;
    base_cap : bits(129) = undefined;
    if VAIsBits64(addr) then {
        base_cap = DDC_read()
    } else {
        base_cap = VAToCapability(addr)
    };
    if not_bool(CapCheckPermissions(base_cap, CAP_PERM_LOAD_CAP)) then {
        data = CapWithTagClear(data)
    } else ();
    if (not_bool(CapIsMutableLoadPermitted(base_cap)) & CapIsTagSet(data)) & not_bool(CapIsSealed(data)) then {
        data = CapClearPerms(data, ((CAP_PERM_STORE | CAP_PERM_STORE_CAP) | CAP_PERM_STORE_LOCAL) | CAP_PERM_MUTABLE_LOAD)
    } else ();
    return(data)
}

val MemAtomicCompareAndSwapC : (VirtualAddress, bits(64), bits(129), bits(129), AccType, AccType) -> bits(129) effect {escape, rreg, undef, wreg}

function MemAtomicCompareAndSwapC (vaddr, address, expectedcap, newcap, ldacctype, stacctype) = {
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddressForAtomicAccess(address, CAPABILITY_DBYTES * 8);
    let ldaccdesc : AccessDescriptor = CreateAccessDescriptor(ldacctype);
    let staccdesc : AccessDescriptor = CreateAccessDescriptor(stacctype);
    let 'size = CAPABILITY_DBYTES;
    newdata : bits(8 * 'size) = undefined;
    newtag : bits(div('size, 16)) = undefined;
    (newtag[0 .. 0], newdata) = DataFromCapability(8 * size, newcap);
    if newtag != Zeros(DIV(size, 16)) then {
        CheckStoreTagsPermission(memaddrdesc, stacctype)
    } else ();
    if memaddrdesc.memattrs.memtype == MemType_Device then {
        CheckLoadTagsPermission(memaddrdesc, ldacctype)
    } else ();
    olddata : bits(8 * 'size) = undefined;
    oldtag : bits(div('size, 16)) = undefined;
    if memaddrdesc.memattrs.readtagzero then {
        olddata = _ReadMem(memaddrdesc, size, ldaccdesc);
        oldtag = Zeros(DIV(size, 16))
    } else {
        (oldtag, olddata) = _ReadTaggedMem(memaddrdesc, size, ldaccdesc);
        if oldtag != Zeros(DIV(size, 16)) then {
            CheckLoadTagsPermission(memaddrdesc, ldacctype)
        } else ()
    };
    oldcap : bits(129) = CapabilityFromData(CAPABILITY_DBITS, [oldtag[0]], olddata[CAPABILITY_DBITS - 1 .. 0]);
    let oldcap : bits(129) = CapSquashPostLoadCap(oldcap, vaddr);
    if CapIsEqual(oldcap, expectedcap) then {
        _WriteTaggedMem(memaddrdesc, size, staccdesc, newtag, newdata)
    } else ();
    return(oldcap)
}

val MemAtomicC : (bits(64), MemAtomicOp, bits(129), AccType, AccType) -> bits(129) effect {escape, rreg, undef, wreg}

function MemAtomicC (address, op, value_name, ldacctype, stacctype) = {
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddressForAtomicAccess(address, CAPABILITY_DBYTES * 8);
    let ldaccdesc : AccessDescriptor = CreateAccessDescriptor(ldacctype);
    let staccdesc : AccessDescriptor = CreateAccessDescriptor(stacctype);
    let 'size = CAPABILITY_DBYTES;
    assert(op == MemAtomicOp_SWP);
    newdata : bits(8 * 'size) = undefined;
    newtag : bits(div('size, 16)) = undefined;
    (newtag[0 .. 0], newdata) = DataFromCapability(8 * size, value_name);
    if newtag != Zeros(DIV(size, 16)) then {
        CheckStoreTagsPermission(memaddrdesc, stacctype)
    } else ();
    if memaddrdesc.memattrs.memtype == MemType_Device then {
        CheckLoadTagsPermission(memaddrdesc, ldacctype)
    } else ();
    olddata : bits(8 * 'size) = undefined;
    oldtag : bits(div('size, 16)) = undefined;
    if memaddrdesc.memattrs.readtagzero then {
        olddata = _ReadMem(memaddrdesc, size, ldaccdesc);
        oldtag = Zeros(DIV(size, 16))
    } else {
        (oldtag, olddata) = _ReadTaggedMem(memaddrdesc, size, ldaccdesc);
        if oldtag != Zeros(DIV(size, 16)) then {
            CheckLoadTagsPermission(memaddrdesc, ldacctype)
        } else ()
    };
    _WriteTaggedMem(memaddrdesc, size, staccdesc, newtag, newdata);
    return(CapabilityFromData(CAPABILITY_DBITS, [oldtag[0]], olddata[CAPABILITY_DBITS - 1 .. 0]))
}

val AArch64_IsExclusiveVA : forall ('processorid 'size : Int).
  (bits(64), int('processorid), int('size)) -> bool

val AArch64_MarkExclusiveVA : forall ('processorid 'size : Int).
  (bits(64), int('processorid), int('size)) -> unit

val AArch64_SetExclusiveMonitors : forall ('size : Int).
  (bits(64), int('size)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SetExclusiveMonitors (address, size) = {
    let acctype : AccType = AccType_ATOMIC;
    let iswrite : bool = false;
    let aligned : bool = address == Align(address, size);
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        return()
    } else ();
    if memaddrdesc.memattrs.shareable then {
        MarkExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
    } else ();
    MarkExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    AArch64_MarkExclusiveVA(address, ProcessorID(), size)
}

val AArch64_ExclusiveMonitorsPass : forall ('size : Int).
  (bits(64), int('size)) -> bool effect {escape, rreg, undef, wreg}

function AArch64_ExclusiveMonitorsPass (address, size) = {
    secondstage : bool = undefined;
    let acctype : AccType = AccType_ATOMIC;
    let iswrite : bool = true;
    let aligned : bool = address == Align(address, size);
    if not_bool(aligned) then {
        let secondstage : bool = false;
        AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    } else ();
    passed : bool = AArch64_IsExclusiveVA(address, ProcessorID(), size);
    if not_bool(passed) then {
        return(false)
    } else ();
    let memaddrdesc : AddressDescriptor = AArch64_TranslateAddress(address, acctype, iswrite, aligned, size);
    if IsFault(memaddrdesc) then {
        AArch64_Abort(address, memaddrdesc.fault)
    } else ();
    passed : bool = IsExclusiveLocal(memaddrdesc.paddress, ProcessorID(), size);
    ClearExclusiveLocal(ProcessorID());
    if passed then {
        if memaddrdesc.memattrs.shareable then {
            passed = IsExclusiveGlobal(memaddrdesc.paddress, ProcessorID(), size)
        } else ()
    } else ();
    return(passed)
}

val FPRecipStepFused : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRecipStepFused (op1__arg, op2) = {
    op1 : bits('N) = op1__arg;
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_value : real = undefined;
    sign : bits(1) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    let op1 : bits('N) = FPNeg(op1);
    (type1, sign1, value1_name) = FPUnpack(op1, FPCR);
    (type2, sign2, value2_name) = FPUnpack(op2, FPCR);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, FPCR);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPTwo('N, 0b0)
        } else if inf1 | inf2 then {
            result = FPInfinity('N, EOR(sign1, sign2))
        } else {
            let result_value : real = 2.0 + value1_name * value2_name;
            if result_value == 0.0 then {
                let sign : bits(1) = if FPRoundingMode(FPCR) == FPRounding_NEGINF then 0b1 else 0b0;
                result = FPZero('N, sign)
            } else {
                result = FPRound__1('N, result_value, FPCR)
            }
        }
    } else ();
    return(result)
}

val FPRSqrtStepFused : forall ('N : Int), 'N in {16, 32, 64}.
  (bits('N), bits('N)) -> bits('N) effect {escape, rreg, undef, wreg}

function FPRSqrtStepFused (op1__arg, op2) = {
    op1 : bits('N) = op1__arg;
    done : bool = undefined;
    inf1 : bool = undefined;
    inf2 : bool = undefined;
    result_value : real = undefined;
    sign : bits(1) = undefined;
    sign1 : bits(1) = undefined;
    sign2 : bits(1) = undefined;
    type1 : FPType = undefined;
    type2 : FPType = undefined;
    value1_name : real = undefined;
    value2_name : real = undefined;
    zero1 : bool = undefined;
    zero2 : bool = undefined;
    assert('N == 16 | 'N == 32 | 'N == 64);
    result : bits('N) = undefined;
    let op1 : bits('N) = FPNeg(op1);
    (type1, sign1, value1_name) = FPUnpack(op1, FPCR);
    (type2, sign2, value2_name) = FPUnpack(op2, FPCR);
    (done, result) = FPProcessNaNs(type1, type2, op1, op2, FPCR);
    if not_bool(done) then {
        let inf1 : bool = type1 == FPType_Infinity;
        let inf2 : bool = type2 == FPType_Infinity;
        let zero1 : bool = type1 == FPType_Zero;
        let zero2 : bool = type2 == FPType_Zero;
        if inf1 & zero2 | zero1 & inf2 then {
            result = FPOnePointFive('N, 0b0)
        } else if inf1 | inf2 then {
            result = FPInfinity('N, EOR(sign1, sign2))
        } else {
            let result_value : real = (3.0 + value1_name * value2_name) / 2.0;
            if result_value == 0.0 then {
                let sign : bits(1) = if FPRoundingMode(FPCR) == FPRounding_NEGINF then 0b1 else 0b0;
                result = FPZero('N, sign)
            } else {
                result = FPRound__1('N, result_value, FPCR)
            }
        }
    } else ();
    return(result)
}

val AArch64_PhysicalSErrorSyndrome : forall ('implicit_esb : Bool).
  bool('implicit_esb) -> bits(25)

val AArch64_ReportDeferredSError : bits(25) -> bits(64) effect {undef}

function AArch64_ReportDeferredSError syndrome = {
    target : bits(64) = undefined;
    target[31] = Bit(0b1);
    target[24] = Bit([syndrome[24]]);
    target[23 .. 0] = syndrome[23 .. 0];
    return(target)
}

val ExternalDebugInterruptsDisabled : bits(2) -> bool effect {escape, rreg, undef}

function ExternalDebugInterruptsDisabled target = {
    int_dis : bool = undefined;
    match target {
      ? if ? == EL3 => {
          int_dis = Slice(EDSCR, 22, 2) == 0b11 & ExternalSecureInvasiveDebugEnabled()
      },
      ? if ? == EL2 => {
          int_dis = (match Slice(EDSCR, 22, 2) {
            [bitone, _] => true,
            _ => false
          }) : bool & ExternalInvasiveDebugEnabled()
      },
      ? if ? == EL1 => {
          if IsSecure() then {
              int_dis = (match Slice(EDSCR, 22, 2) {
                [bitone, _] => true,
                _ => false
              }) : bool & ExternalSecureInvasiveDebugEnabled()
          } else {
              int_dis = Slice(EDSCR, 22, 2) != 0b00 & ExternalInvasiveDebugEnabled()
          }
      },
      _ => ()
    };
    return(int_dis)
}

val AArch64_ESBOperation : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_ESBOperation () = {
    implicit_esb : bool = undefined;
    mask_active : bool = undefined;
    syndrome : bits(25) = undefined;
    let route_to_el3 : bool = HaveEL(EL3) & Slice(SCR_EL3, 3, 1) == 0b1;
    let route_to_el2 : bool = EL2Enabled() & (Slice(HCR_EL2, 27, 1) == 0b1 | Slice(HCR_EL2, 5, 1) == 0b1);
    let target : bits(2) = if route_to_el3 then EL3 else if route_to_el2 then EL2 else EL1;
    if target == EL1 then {
        mask_active = PSTATE.EL == EL0 | PSTATE.EL == EL1
    } else if (HaveVirtHostExt() & target == EL2) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 then {
        mask_active = PSTATE.EL == EL0 | PSTATE.EL == EL2
    } else {
        mask_active = PSTATE.EL == target
    };
    let mask_set : bool = PSTATE.A == 0b1;
    let intdis : bool = Halted() | ExternalDebugInterruptsDisabled(target);
    let masked : bool = (UInt(target) < UInt(PSTATE.EL) | intdis) | mask_active & mask_set;
    if IsPhysicalSErrorPending() & masked then {
        let implicit_esb : bool = false;
        let syndrome : bits(25) = AArch64_PhysicalSErrorSyndrome(implicit_esb);
        DISR_EL1 = AArch64_ReportDeferredSError(syndrome)[31 .. 0];
        ClearPendingPhysicalSError()
    } else ();
    return()
}

val AArch64_vESBOperation : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_vESBOperation () = {
    assert((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled());
    let vSEI_enabled : bool = Slice(HCR_EL2, 27, 1) == 0b0 & Slice(HCR_EL2, 5, 1) == 0b1;
    let vSEI_pending : bool = vSEI_enabled & Slice(HCR_EL2, 8, 1) == 0b1;
    let vintdis : bool = Halted() | ExternalDebugInterruptsDisabled(EL1);
    let vmasked : bool = vintdis | PSTATE.A == 0b1;
    if vSEI_pending & vmasked then {
        VDISR_EL2 = AArch64_ReportDeferredSError(VSESR_EL2[24 .. 0])[31 .. 0];
        HCR_EL2 = SetSlice(1, HCR_EL2, 8, 0b0)
    } else ();
    return()
}

val AArch64_ResetControlRegisters : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit

val AArch64_TakeReset : forall ('cold_reset : Bool).
  bool('cold_reset) -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakeReset cold_reset = {
    assert(not_bool(HighestELUsingAArch32()));
    PSTATE.nRW = 0b0;
    if HaveEL(EL3) then {
        PSTATE.EL = EL3
    } else if HaveEL(EL2) then {
        PSTATE.EL = EL2
    } else {
        PSTATE.EL = EL1
    };
    AArch64_ResetControlRegisters(cold_reset);
    PSTATE.SP = 0b1;
    (PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = 0b1111;
    PSTATE.SS = 0b0;
    PSTATE.C64 = 0b0;
    PSTATE.IL = 0b0;
    AArch64_ResetGeneralRegisters();
    AArch64_ResetSIMDFPRegisters();
    AArch64_ResetSpecialRegisters();
    ResetExternalDebugRegisters(cold_reset);
    rv : bits(64) = undefined;
    if HaveEL(EL3) then {
        rv = RVBAR_EL3
    } else if HaveEL(EL2) then {
        rv = RVBAR_EL2
    } else {
        rv = RVBAR_EL1
    };
    assert(is_zero_subrange(rv, 63, PAMax()) & IsZero(rv[1 .. 0]));
    BranchTo(rv, BranchType_RESET)
}

val DebugTarget : unit -> bits(2) effect {escape, rreg, undef}

function DebugTarget () = {
    let secure : bool = IsSecure();
    return(DebugTargetFrom(secure))
}

val SSAdvance : unit -> unit effect {escape, rreg, undef, wreg}

function SSAdvance () = {
    let target : bits(2) = DebugTarget();
    let step_enabled : bool = not_bool(ELUsingAArch32(target)) & Slice(MDSCR_EL1, 0, 1) == 0b1;
    let active_not_pending : bool = step_enabled & PSTATE.SS == 0b1;
    if active_not_pending then {
        PSTATE.SS = 0b0
    } else ();
    return()
}

val AArch64_CallSecureMonitor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallSecureMonitor immediate = {
    assert(HaveEL(EL3) & not_bool(ELUsingAArch32(EL3)));
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    exception : ExceptionRecord = ExceptionSyndrome(Exception_MonitorCall);
    exception.syndrome[15 .. 0] = immediate;
    AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
}

val AArch64_CallHypervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallHypervisor immediate = {
    assert(HaveEL(EL2));
    SSAdvance();
    let preferred_exception_return : bits(64) = NextInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    exception : ExceptionRecord = ExceptionSyndrome(Exception_HypervisorCall);
    exception.syndrome[15 .. 0] = immediate;
    if PSTATE.EL == EL3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CallSupervisor : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CallSupervisor immediate = {
    SSAdvance();
    let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & Slice(HCR_EL2, 27, 1) == 0b1;
    let preferred_exception_return : bits(64) = NextInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    exception : ExceptionRecord = ExceptionSyndrome(Exception_SupervisorCall);
    exception.syndrome[15 .. 0] = immediate;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckIllegalState : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckIllegalState () = {
    exception : ExceptionRecord = undefined;
    route_to_el2 : bool = undefined;
    vect_offset : int = undefined;
    if PSTATE.IL == 0b1 then {
        let route_to_el2 : bool = (PSTATE.EL == EL0 & EL2Enabled()) & Slice(HCR_EL2, 27, 1) == 0b1;
        let preferred_exception_return : bits(64) = ThisInstrAddr(64);
        let 'vect_offset = UInt(0x0);
        let exception : ExceptionRecord = ExceptionSyndrome(Exception_IllegalState);
        if UInt(PSTATE.EL) > UInt(EL1) then {
            AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
        } else if route_to_el2 then {
            AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
        } else {
            AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
        }
    } else ()
}

val AArch64_CheckForSMCUndefOrTrap : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForSMCUndefOrTrap imm = {
    exception : ExceptionRecord = undefined;
    vect_offset : int = undefined;
    route_to_el2 : bool = (PSTATE.EL == EL1 & EL2Enabled()) & Slice(HCR_EL2, 19, 1) == 0b1;
    if not_bool(HaveEL(EL3)) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    } else ();
    let route_to_el2 : bool = (PSTATE.EL == EL1 & EL2Enabled()) & Slice(HCR_EL2, 19, 1) == 0b1;
    if route_to_el2 then {
        let preferred_exception_return : bits(64) = ThisInstrAddr(64);
        let 'vect_offset = UInt(0x0);
        exception : ExceptionRecord = ExceptionSyndrome(Exception_MonitorCall);
        exception.syndrome[15 .. 0] = imm;
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else ()
}

val AArch64_WFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_WFxTrap (target_el, is_wfe) = {
    assert(UInt(target_el) > UInt(PSTATE.EL));
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    exception : ExceptionRecord = ExceptionSyndrome(Exception_WFxTrap);
    exception.syndrome[24 .. 20] = ConditionSyndrome();
    exception.syndrome[0 .. 0] = if is_wfe then 0b1 else 0b0;
    if (target_el == EL1 & EL2Enabled()) & Slice(HCR_EL2, 27, 1) == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckForWFxTrap : forall ('is_wfe : Bool).
  (bits(2), bool('is_wfe)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckForWFxTrap (target_el, is_wfe) = {
    trap : bool = undefined;
    assert(HaveEL(target_el));
    match target_el {
      ? if ? == EL1 => {
          trap = (if is_wfe then [SCTLR_read__1()[18]] else [SCTLR_read__1()[16]]) == 0b0
      },
      ? if ? == EL2 => {
          trap = (if is_wfe then Slice(HCR_EL2, 14, 1) else Slice(HCR_EL2, 13, 1)) == 0b1
      },
      ? if ? == EL3 => {
          trap = (if is_wfe then Slice(SCR_EL3, 13, 1) else Slice(SCR_EL3, 12, 1)) == 0b1
      },
      _ => ()
    };
    if trap then {
        AArch64_WFxTrap(target_el, is_wfe)
    } else ()
}

val AArch64_AdvSIMDFPAccessTrap : bits(2) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AdvSIMDFPAccessTrap target_el = {
    exception : ExceptionRecord = undefined;
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let route_to_el2 : bool = (target_el == EL1 & EL2Enabled()) & Slice(HCR_EL2, 27, 1) == 0b1;
    if route_to_el2 then {
        let exception : ExceptionRecord = ExceptionSyndrome(Exception_Uncategorized);
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        exception : ExceptionRecord = ExceptionSyndrome(Exception_AdvSIMDFPAccessTrap);
        exception.syndrome[24 .. 20] = ConditionSyndrome();
        AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset)
    };
    return()
}

val AArch64_CheckFPAdvSIMDTrap : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckFPAdvSIMDTrap () = {
    disabled : bool = undefined;
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2) & EL2Enabled() then {
        if HaveVirtHostExt() & Slice(HCR_EL2, 34, 1) == 0b1 then {
            match Slice(CPTR_EL2, 20, 2) {
              [_, bitzero] => {
                  disabled = not_bool(PSTATE.EL == EL1 & Slice(HCR_EL2, 27, 1) == 0b1)
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & Slice(HCR_EL2, 27, 1) == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            } else ()
        } else {
            if Slice(CPTR_EL2, 10, 1) == 0b1 then {
                AArch64_AdvSIMDFPAccessTrap(EL2)
            } else ()
        }
    } else ();
    if HaveEL(EL3) then {
        if Slice(CPTR_EL3, 10, 1) == 0b1 then {
            AArch64_AdvSIMDFPAccessTrap(EL3)
        } else ()
    } else ();
    return()
}

val AArch64_CheckFPAdvSIMDEnabled : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckFPAdvSIMDEnabled () = {
    disabled : bool = undefined;
    if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & not_bool(IsInHost()) then {
        match Slice(CPACR_read(), 20, 2) {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if disabled then {
            AArch64_AdvSIMDFPAccessTrap(EL1)
        } else ()
    } else ();
    AArch64_CheckFPAdvSIMDTrap()
}

val CheckFPAdvSIMDEnabled64 : unit -> unit effect {escape, rreg, undef, wreg}

function CheckFPAdvSIMDEnabled64 () = {
    AArch64_CheckFPAdvSIMDEnabled()
}

val CapabilityAccessTrap : bits(2) -> unit effect {escape, rreg, undef, wreg}

function CapabilityAccessTrap target_el = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_CapabilityAccess);
    AArch64_TakeException(target_el, exception, preferred_exception_return, vect_offset);
    return()
}

val CheckCapabilitiesEnabled : unit -> unit effect {escape, rreg, undef, wreg}

function CheckCapabilitiesEnabled () = {
    disabled : bool = undefined;
    if PSTATE.EL == EL0 | PSTATE.EL == EL1 then {
        match Slice(CPACR_EL1, 18, 2) {
          [_, bitzero] => {
              disabled = true
          },
          0b01 => {
              disabled = PSTATE.EL == EL0
          },
          0b11 => {
              disabled = false
          }
        };
        if ((HaveEL(EL2) & not_bool(IsSecure())) & Slice(HCR_EL2, 34, 1) == 0b1) & Slice(HCR_EL2, 27, 1) == 0b1 then {
            disabled = false
        } else ();
        if disabled then {
            if HaveEL(EL2) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                CapabilityAccessTrap(EL2)
            } else {
                CapabilityAccessTrap(EL1)
            }
        } else ()
    } else ();
    if HaveEL(EL2) & not_bool(IsSecure()) then {
        if Slice(HCR_EL2, 34, 1) == 0b1 then {
            match Slice(CPTR_EL2, 18, 2) {
              [_, bitzero] => {
                  disabled = PSTATE.EL == EL0 | PSTATE.EL == EL1 | PSTATE.EL == EL2
              },
              0b01 => {
                  disabled = PSTATE.EL == EL0 & Slice(HCR_EL2, 27, 1) == 0b1
              },
              0b11 => {
                  disabled = false
              }
            };
            if disabled then {
                CapabilityAccessTrap(EL2)
            } else ()
        } else {
            if Slice(CPTR_EL2, 9, 1) == 0b1 then {
                CapabilityAccessTrap(EL2)
            } else ()
        }
    } else ();
    if HaveEL(EL3) then {
        if Slice(CPTR_EL3, 9, 1) == 0b0 then {
            CapabilityAccessTrap(EL3)
        } else ()
    } else ();
    return()
}

val IsTagSettingDisabled : unit -> bool effect {escape, rreg, undef}

function IsTagSettingDisabled () = {
    let __PSTATE_EL : bits(2) = PSTATE.EL;
    result : bool = false;
    if __PSTATE_EL == EL0 | __PSTATE_EL == EL1 then {
        if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(CHCR_EL2, 0, 1) == 0b1 then {
            result = true
        } else if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & Slice(CSCR_EL3, 0, 1) == 0b1 then {
            result = true
        } else ()
    } else if __PSTATE_EL == EL2 then {
        if (HaveEL(EL3) & not_bool(ELUsingAArch32(EL3))) & Slice(CSCR_EL3, 0, 1) == 0b1 then {
            result = true
        } else ()
    } else ();
    return(result)
}

val AArch64_TakePhysicalIRQException : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_TakePhysicalIRQException () = {
    let route_to_el3 : bool = HaveEL(EL3) & Slice(SCR_EL3, 1, 1) == 0b1;
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (Slice(HCR_EL2, 27, 1) == 0b1 | Slice(HCR_EL2, 4, 1) == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x80);
    let exception : ExceptionRecord = ExceptionSyndrome(Exception_IRQ);
    if route_to_el3 then {
        AArch64_TakeException(EL3, exception, preferred_exception_return, vect_offset)
    } else if PSTATE.EL == EL2 | route_to_el2 then {
        assert(PSTATE.EL != EL3);
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        assert(PSTATE.EL == EL0 | PSTATE.EL == EL1);
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_SoftwareBreakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function AArch64_SoftwareBreakpoint immediate = {
    let route_to_el2 : bool = ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & (Slice(HCR_EL2, 27, 1) == 0b1 | Slice(MDCR_EL2, 8, 1) == 0b1);
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    exception : ExceptionRecord = ExceptionSyndrome(Exception_SoftwareBreakpoint);
    exception.syndrome[15 .. 0] = immediate;
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else if route_to_el2 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_PCAlignmentFault : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_PCAlignmentFault () = {
    let preferred_exception_return : bits(64) = ThisInstrAddr(64);
    let 'vect_offset = UInt(0x0);
    exception : ExceptionRecord = ExceptionSyndrome(Exception_PCAlignment);
    exception.vaddress = ThisInstrAddr(64);
    if UInt(PSTATE.EL) > UInt(EL1) then {
        AArch64_TakeException(PSTATE.EL, exception, preferred_exception_return, vect_offset)
    } else if EL2Enabled() & Slice(HCR_EL2, 27, 1) == 0b1 then {
        AArch64_TakeException(EL2, exception, preferred_exception_return, vect_offset)
    } else {
        AArch64_TakeException(EL1, exception, preferred_exception_return, vect_offset)
    }
}

val AArch64_CheckPCAlignment : unit -> unit effect {escape, rreg, undef, wreg}

function AArch64_CheckPCAlignment () = {
    let pc : bits(64) = ThisInstrAddr(64);
    if pc[1 .. 0] != 0b00 then {
        AArch64_PCAlignmentFault()
    } else ()
}

val CheckPCCCapability : unit -> bits(64) effect {escape, rreg, undef, wreg}

function CheckPCCCapability () = {
    return(CheckCapability(PCC, CapGetValue(PCC), 4, CAP_PERM_EXECUTE, AccType_IFETCH))
}

val AArch64_FullTranslate : forall ('iswrite : Bool) 'size ('wasaligned : Bool).
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rreg, undef}

function AArch64_FullTranslate (vaddress, acctype, iswrite, wasaligned, size) = {
    let iswritevalidcap : bool = false;
    return(AArch64_FullTranslateWithTag(vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap))
}

val AArch64_FirstStageTranslate : forall ('iswrite : Bool) 'size ('wasaligned : Bool).
  (bits(64), AccType, bool('iswrite), bool('wasaligned), int('size)) -> AddressDescriptor effect {escape, rreg, undef}

function AArch64_FirstStageTranslate (vaddress, acctype, iswrite, wasaligned, size) = {
    let iswritevalidcap : bool = false;
    return(AArch64_FirstStageTranslateWithTag(vaddress, acctype, iswrite, wasaligned, size, iswritevalidcap))
}

val ProfilingSynchronizationBarrier : unit -> unit

val AArch64_ExceptionReturnToCapability : (bits(129), bits(32)) -> unit effect {escape, rreg, undef, wreg}

function AArch64_ExceptionReturnToCapability (new_pcc__arg, spsr) = {
    new_pcc : bits(129) = new_pcc__arg;
    iesb_req : bool = undefined;
    SynchronizeContext();
    let sync_errors : bool = HaveIESB() & [SCTLR_read__1()[21]] == 0b1;
    if sync_errors then {
        SynchronizeErrors();
        let iesb_req : bool = true;
        TakeUnmaskedPhysicalSErrorInterrupts(iesb_req)
    } else ();
    SetPSTATEFromPSR(spsr);
    ClearExclusiveLocal(ProcessorID());
    SendEventLocal();
    if not_bool(CapIsSystemAccessEnabled()) then {
        new_pcc = CapWithTagClear(new_pcc)
    } else ();
    if CapIsExponentOutOfRange(new_pcc) then {
        new_pcc = CapWithTagClear(new_pcc)
    } else ();
    let new_pcc : bits(129) = BranchAddr(new_pcc, PSTATE.EL);
    BranchToCapability(new_pcc, BranchType_ERET)
}

val DecodeRegExtend : bits(3) -> ExtendType effect {undef}

function DecodeRegExtend op = {
    match op {
      0b000 => {
          return(ExtendType_UXTB)
      },
      0b001 => {
          return(ExtendType_UXTH)
      },
      0b010 => {
          return(ExtendType_UXTW)
      },
      0b011 => {
          return(ExtendType_UXTX)
      },
      0b100 => {
          return(ExtendType_SXTB)
      },
      0b101 => {
          return(ExtendType_SXTH)
      },
      0b110 => {
          return(ExtendType_SXTW)
      },
      0b111 => {
          return(ExtendType_SXTX)
      },
      _ => {
          return(undefined : ExtendType)
      }
    }
}

val ExtendReg : forall 'N 'reg 'shift,
  ('N == 8 | 'N == 16 | 'N == 32 | 'N == 64 | not(('shift >= 0 & 'shift <= 4))).
  (implicit('N), int('reg), ExtendType, int('shift)) -> bits('N) effect {escape, rreg, undef}

function ExtendReg (N, reg, exttype, shift) = {
    assert(shift >= 0 & shift <= 4);
    let val_name : bits('N) = X_read(N, reg);
    is_unsigned : bool = undefined;
    len : int = undefined;
    match exttype {
      ExtendType_SXTB => {
          is_unsigned = false;
          len = 8
      },
      ExtendType_SXTH => {
          is_unsigned = false;
          len = 16
      },
      ExtendType_SXTW => {
          is_unsigned = false;
          len = 32
      },
      ExtendType_SXTX => {
          is_unsigned = false;
          len = 64
      },
      ExtendType_UXTB => {
          is_unsigned = true;
          len = 8
      },
      ExtendType_UXTH => {
          is_unsigned = true;
          len = 16
      },
      ExtendType_UXTW => {
          is_unsigned = true;
          len = 32
      },
      ExtendType_UXTX => {
          is_unsigned = true;
          len = 64
      }
    };
    let is_unsigned = is_unsigned;
    let 'len = Min(len, N - shift);
    assert(constraint((0 <= 'len - 1 | not(('shift >= 0 & 'shift <= 4)))));
    return(Extend(val_name[len - 1 .. 0] @ Zeros(shift), N, is_unsigned))
}

val DecodeBitMasks : forall 'M ('immediate : Bool),
  (0 <= 'M - 1 & 'M - 1 < 64).
  (implicit('M), bits(1), bits(6), bits(6), bool('immediate)) -> (bits('M), bits('M)) effect {escape}

function DecodeBitMasks (M, immN, imms, immr, immediate) = {
    let 'len = HighestSetBit(immN @ not_vec(imms));
    if len < 1 then {
        throw(Error_Undefined())
    } else ();
    assert(M >= (1 << len));
    assert(constraint(6 >= 'len));
    let levels : bits(6) = ZeroExtend(Ones(len), 6);
    if immediate & (imms & levels) == levels then {
        throw(Error_Undefined())
    } else ();
    let 'S = UInt(imms & levels);
    let 'R = UInt(immr & levels);
    let 'diff = S - R;
    let tmask_and : bits(6) = diff[5 .. 0] | not_vec(levels);
    let tmask_or : bits(6) = diff[5 .. 0] & levels;
    tmask : bits(64) = Ones(64);
    tmask : bits(64) = tmask & Replicate(Replicate([tmask_and[0]], 1) @ Ones(1), 32) | Replicate(Zeros(1) @ Replicate([tmask_or[0]], 1), 32);
    tmask : bits(64) = tmask & Replicate(Replicate([tmask_and[1]], 2) @ Ones(2), 16) | Replicate(Zeros(2) @ Replicate([tmask_or[1]], 2), 16);
    tmask : bits(64) = tmask & Replicate(Replicate([tmask_and[2]], 4) @ Ones(4), 8) | Replicate(Zeros(4) @ Replicate([tmask_or[2]], 4), 8);
    tmask : bits(64) = tmask & Replicate(Replicate([tmask_and[3]], 8) @ Ones(8), 4) | Replicate(Zeros(8) @ Replicate([tmask_or[3]], 8), 4);
    tmask : bits(64) = tmask & Replicate(Replicate([tmask_and[4]], 16) @ Ones(16), 2) | Replicate(Zeros(16) @ Replicate([tmask_or[4]], 16), 2);
    let tmask : bits(64) = tmask & Replicate(Replicate([tmask_and[5]], 32) @ Ones(32), 1) | Replicate(Zeros(32) @ Replicate([tmask_or[5]], 32), 1);
    let wmask_and : bits(6) = immr | not_vec(levels);
    let wmask_or : bits(6) = immr & levels;
    wmask : bits(64) = Zeros(64);
    wmask : bits(64) = wmask & Replicate(Ones(1) @ Replicate([wmask_and[0]], 1), 32) | Replicate(Replicate([wmask_or[0]], 1) @ Zeros(1), 32);
    wmask : bits(64) = wmask & Replicate(Ones(2) @ Replicate([wmask_and[1]], 2), 16) | Replicate(Replicate([wmask_or[1]], 2) @ Zeros(2), 16);
    wmask : bits(64) = wmask & Replicate(Ones(4) @ Replicate([wmask_and[2]], 4), 8) | Replicate(Replicate([wmask_or[2]], 4) @ Zeros(4), 8);
    wmask : bits(64) = wmask & Replicate(Ones(8) @ Replicate([wmask_and[3]], 8), 4) | Replicate(Replicate([wmask_or[3]], 8) @ Zeros(8), 4);
    wmask : bits(64) = wmask & Replicate(Ones(16) @ Replicate([wmask_and[4]], 16), 2) | Replicate(Replicate([wmask_or[4]], 16) @ Zeros(16), 2);
    wmask : bits(64) = wmask & Replicate(Ones(32) @ Replicate([wmask_and[5]], 32), 1) | Replicate(Replicate([wmask_or[5]], 32) @ Zeros(32), 1);
    if [diff[6]] != 0b0 then {
        wmask = wmask & tmask
    } else {
        wmask = wmask | tmask
    };
    return((wmask[M - 1 .. 0], tmask[M - 1 .. 0]))
}

val DecodeShift : bits(2) -> ShiftType effect {undef}

function DecodeShift op = {
    match op {
      0b00 => {
          return(ShiftType_LSL)
      },
      0b01 => {
          return(ShiftType_LSR)
      },
      0b10 => {
          return(ShiftType_ASR)
      },
      0b11 => {
          return(ShiftType_ROR)
      },
      _ => {
          return(undefined : ShiftType)
      }
    }
}

val ShiftReg : forall 'N 'amount 'reg,
  'N in {8, 16, 32, 64} & 'amount >= 0.
  (implicit('N), int('reg), ShiftType, int('amount)) -> bits('N) effect {escape, rreg}

function ShiftReg (N, reg, shiftype, amount) = {
    result : bits('N) = X_read(N, reg);
    match shiftype {
      ShiftType_LSL => {
          result = LSL(result, amount)
      },
      ShiftType_LSR => {
          result = LSR(result, amount)
      },
      ShiftType_ASR => {
          result = ASR(result, amount)
      },
      ShiftType_ROR => {
          result = ROR(result, amount)
      }
    };
    return(result)
}

val Prefetch : (bits(64), bits(5)) -> unit effect {undef}

function Prefetch (address, prfop) = {
    hint : PrefetchHint = undefined;
    match prfop[4 .. 3] {
      0b00 => {
          hint = Prefetch_READ
      },
      0b01 => {
          hint = Prefetch_EXEC
      },
      0b10 => {
          hint = Prefetch_WRITE
      },
      0b11 => {
          return()
      }
    };
    let 'target = UInt(prfop[2 .. 1]);
    let stream : bool = [prfop[0]] != 0b0;
    Hint_Prefetch(address, hint, target, stream);
    return()
}

val ReduceCombine : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits('esize), bits('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function ReduceCombine (op, lo, hi) = if 'esize == 8 then {
    assert(op == ReduceOp_ADD);
    lo + hi
} else match op {
  ReduceOp_FMINNUM => {
      FPMinNum(lo, hi, FPCR)
  },
  ReduceOp_FMAXNUM => {
      FPMaxNum(lo, hi, FPCR)
  },
  ReduceOp_FMIN => {
      FPMin(lo, hi, FPCR)
  },
  ReduceOp_FMAX => {
      FPMax(lo, hi, FPCR)
  },
  ReduceOp_FADD => {
      FPAdd(lo, hi, FPCR)
  },
  ReduceOp_ADD => {
      lo + hi
  }
}

val Reduce16 : forall ('esize : Int), 'esize in {8, 16}.
  (ReduceOp, bits(16), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce16 (op, input, esize) = {
    if esize == 16 then input else {
        let hi = Slice(input, 8, 8);
        let lo = Slice(input, 0, 8);
        ReduceCombine(op, lo, hi) : bits(8)
    }
}

val Reduce32 : forall ('esize : Int), 'esize in {8, 16, 32}.
  (ReduceOp, bits(32), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce32 (op, input, esize) = {
    if esize == 32 then input else {
        let hi = Reduce16(op, Slice(input, 16, 16), esize);
        let lo = Reduce16(op, Slice(input, 0, 16), esize);
        ReduceCombine(op, lo, hi)
    }
}

val Reduce64 : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits(64), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce64 (op, input, esize) = {
    if esize == 64 then input else {
        let hi = Reduce32(op, Slice(input, 32, 32), esize);
        let lo = Reduce32(op, Slice(input, 0, 32), esize);
        ReduceCombine(op, lo, hi)
    }
}

val Reduce128 : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits(128), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce128 (op, input, esize) = {
    let hi = Reduce64(op, Slice(input, 64, 64), esize);
    let lo = Reduce64(op, Slice(input, 0, 64), esize);
    ReduceCombine(op, lo, hi)
}

val Reduce256 : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits(256), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce256 (op, input, esize) = {
    let hi = Reduce128(op, Slice(input, 128, 128), esize);
    let lo = Reduce128(op, Slice(input, 0, 128), esize);
    ReduceCombine(op, lo, hi)
}

val Reduce512 : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits(512), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce512 (op, input, esize) = {
    let hi = Reduce256(op, Slice(input, 256, 256), esize);
    let lo = Reduce256(op, Slice(input, 0, 256), esize);
    ReduceCombine(op, lo, hi)
}

val Reduce1024 : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits(1024), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce1024 (op, input, esize) = {
    let hi = Reduce512(op, Slice(input, 512, 512), esize);
    let lo = Reduce512(op, Slice(input, 0, 512), esize);
    ReduceCombine(op, lo, hi)
}

val Reduce2048 : forall ('esize : Int), 'esize in {8, 16, 32, 64}.
  (ReduceOp, bits(2048), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce2048 (op, input, esize) = {
    let hi = Reduce1024(op, Slice(input, 1024, 1024), esize);
    let lo = Reduce1024(op, Slice(input, 0, 1024), esize);
    ReduceCombine(op, lo, hi)
}

val Reduce : forall 'N 'esize,
  ('N in {16, 32, 64, 128, 256, 512, 1024, 2048} & 'esize in {8, 16, 32, 64} & 'N >= 'esize).
  (ReduceOp, bits('N), int('esize)) -> bits('esize) effect {escape, rreg, undef, wreg}

function Reduce (op, input, esize) = {
    match 'N {
      16 => Reduce16(op, input, esize),
      32 => Reduce32(op, input, esize),
      64 => Reduce64(op, input, esize),
      128 => Reduce128(op, input, esize),
      256 => Reduce256(op, input, esize),
      512 => Reduce512(op, input, esize),
      1024 => Reduce1024(op, input, esize),
      2048 => Reduce2048(op, input, esize)
    }
}

val DCPSInstruction : bits(2) -> unit effect {escape, rreg, undef, wreg}

function DCPSInstruction target_el = {
    handle_el : bits(2) = undefined;
    SynchronizeContext();
    match target_el {
      ? if ? == EL1 => {
          if PSTATE.EL == EL2 | PSTATE.EL == EL3 & not_bool(UsingAArch32()) then {
              handle_el = PSTATE.EL
          } else if EL2Enabled() & Slice(HCR_EL2, 27, 1) == 0b1 then {
              throw(Error_Undefined())
          } else {
              handle_el = EL1
          }
      },
      ? if ? == EL2 => {
          if not_bool(HaveEL(EL2)) then {
              throw(Error_Undefined())
          } else if PSTATE.EL == EL3 & not_bool(UsingAArch32()) then {
              handle_el = EL3
          } else if IsSecure() then {
              throw(Error_Undefined())
          } else {
              handle_el = EL2
          }
      },
      ? if ? == EL3 => {
          if Slice(EDSCR, 16, 1) == 0b1 | not_bool(HaveEL(EL3)) then {
              throw(Error_Undefined())
          } else ();
          handle_el = EL3
      },
      _ => {
          Unreachable()
      }
    };
    from_secure = IsSecure();
    PSTATE.nRW = 0b0;
    PSTATE.SP = 0b1;
    PSTATE.EL = handle_el;
    if HavePANExt() & (handle_el == EL1 & Slice(SCTLR_EL1, 23, 1) == 0b0 | ((handle_el == EL2 & Slice(HCR_EL2, 34, 1) == 0b1) & Slice(HCR_EL2, 27, 1) == 0b1) & Slice(SCTLR_EL2, 23, 1) == 0b0) then {
        PSTATE.PAN = 0b1
    } else ();
    ELR_set__1() = __UNKNOWN_bits(64);
    SPSR_set() = __UNKNOWN_bits(32);
    ESR_set__1() = __UNKNOWN_bits(32);
    if not_bool(HaveCapabilitiesExt()) then {
        DLR_EL0_write() = __UNKNOWN_bits(64)
    } else ();
    DSPSR_EL0 = __UNKNOWN_bits(32);
    if HaveUAOExt() then {
        PSTATE.UAO = 0b0
    } else ();
    if HaveCapabilitiesExt() then {
        PSTATE.C64 = [CCTLR_read__1()[5]]
    } else ();
    UpdateEDSCRFields();
    sync_errors : bool = HaveIESB() & [SCTLR_read__1()[21]] == 0b1;
    if not_bool(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    } else ();
    if sync_errors then {
        SynchronizeErrors()
    } else ();
    return()
}

val DRPSInstruction : unit -> unit effect {escape, rreg, undef, wreg}

function DRPSInstruction () = {
    DLR : bits(32) = undefined;
    DSPSR : bits(32) = undefined;
    SynchronizeContext();
    sync_errors : bool = HaveIESB() & [SCTLR_read__1()[21]] == 0b1;
    if not_bool(ConstrainUnpredictableBool(Unpredictable_IESBinDebug)) then {
        sync_errors = false
    } else ();
    if sync_errors then {
        SynchronizeErrors()
    } else ();
    SetPSTATEFromPSR(SPSR_read());
    if UsingAArch32() then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.Q @ PSTATE.GE @ PSTATE.SS @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(13);
        PSTATE.IT = 0b00000000;
        PSTATE.T = 0b1;
        DLR = __UNKNOWN_bits(32);
        DSPSR = __UNKNOWN_bits(32)
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V @ PSTATE.SS @ PSTATE.D @ PSTATE.A @ PSTATE.I @ PSTATE.F) = __UNKNOWN_bits(9);
        if not_bool(HaveCapabilitiesExt()) then {
            DLR_EL0_write() = __UNKNOWN_bits(64)
        } else ();
        DSPSR_EL0 = __UNKNOWN_bits(32)
    };
    UpdateEDSCRFields();
    return()
}

val CapSetObjectType : (bits(129), bits(64)) -> bits(129)

function CapSetObjectType (c__arg, o) = {
    c : bits(129) = c__arg;
    c[CAP_OTYPE_HI_BIT .. CAP_OTYPE_LO_BIT] = o[CAP_OTYPE_NUM_BITS - 1 .. 0];
    return(c)
}

val CapSetBounds : forall ('exact : Bool).
  (bits(129), bits(CAP_LENGTH_NUM_BITS), bool('exact)) -> bits(129) effect {escape, undef}

function CapSetBounds (c, req_len, exact) = {
    L_ie : bits(13) = undefined;
    obase : bits(CAP_BOUND_NUM_BITS) = undefined;
    olimit : bits(CAP_BOUND_NUM_BITS) = undefined;
    ovalid : bool = undefined;
    assert(CapUnsignedLessThanOrEqual(req_len, CAP_BOUND_MAX));
    exp : int = CAP_MAX_EXPONENT - CountLeadingZeroBits(req_len[CAP_VALUE_NUM_BITS .. CAP_MW - 1]);
    let ie : bool = exp != 0 | [req_len[CAP_MW - 2]] == 0b1;
    let base : bits(CAP_VALUE_NUM_BITS) = CapGetValue(c);
    let abase : bits(CAP_VALUE_NUM_BITS) = if CapBoundsUsesValue(CapGetExponent(c)) then CapBoundsAddress(base) else base;
    let req_base : bits(CAP_VALUE_NUM_BITS + 2) = 0b00 @ abase;
    let req_top : bits(CAP_VALUE_NUM_BITS + 2) = req_base + (0b0 @ req_len);
    Bbits : bits(CAP_MW) = req_base[CAP_MW - 1 .. 0];
    TBits : bits(CAP_MW) = req_top[CAP_MW - 1 .. 0];
    lostTop : bool = false;
    lostBottom : bool = false;
    incrementE_name : bool = false;
    if ie then {
        B_ie : bits(CAP_MW - 3) = let 'exp = exp in
          {
              assert(constraint((0 <= 'exp + 3 & 'exp + 16 - 1 < 66)));
              req_base[exp + CAP_MW - 1 .. exp + 3]
          };
        T_ie : bits(CAP_MW - 3) = let 'exp = exp in
          {
              assert(constraint((0 <= 'exp + 3 & 'exp + 16 - 1 < 66)));
              req_top[exp + CAP_MW - 1 .. exp + 3]
          };
        let maskLo : bits(CAP_VALUE_NUM_BITS + 2) = let 'exp = exp in
          {
              assert(constraint('exp + 3 >= 0));
              assert(constraint(66 >= 'exp + 3));
              ZeroExtend(Ones(exp + 3), CAP_VALUE_NUM_BITS + 2)
          };
        lostBottom = (req_base & maskLo) != Zeros(CAP_VALUE_NUM_BITS + 2);
        lostTop = (req_top & maskLo) != Zeros(CAP_VALUE_NUM_BITS + 2);
        if lostTop then {
            T_ie = T_ie + 1
        } else ();
        let L_ie : bits(13) = T_ie - B_ie;
        let 'exp = exp in
          {
              if [L_ie[CAP_MW - 4]] == 0b1 then {
                  incrementE_name = true;
                  lostBottom = lostBottom | [B_ie[0]] == 0b1;
                  lostTop = lostTop | [T_ie[0]] == 0b1;
                  assert(exp < CAP_MAX_EXPONENT);
                  assert(constraint(0 <= 'exp + 4));
                  B_ie = req_base[exp + CAP_MW .. exp + 4];
                  T_ie = req_top[exp + CAP_MW .. exp + 4];
                  if lostTop then {
                      T_ie = T_ie + 1
                  } else ()
              } else ()
          };
        if incrementE_name == true then {
            exp = exp + 1
        } else ();
        Bbits = B_ie @ 0b000;
        TBits = T_ie @ 0b000
    } else ();
    let 'exp = exp;
    newc : bits(129) = c;
    (obase, olimit, ovalid) = CapGetBounds(c);
    if (not_bool(CapUnsignedGreaterThanOrEqual(Slice(req_base, 0, CAP_BOUND_NUM_BITS), obase)) | not_bool(CapUnsignedLessThanOrEqual(Slice(req_top, 0, CAP_BOUND_NUM_BITS), olimit))) | not_bool(ovalid) then {
        newc[CAP_TAG_BIT] = Bit(0b0)
    } else ();
    if ie then {
        newc[CAP_IE_BIT] = Bit(0b0);
        newc[CAP_BASE_EXP_HI_BIT .. CAP_BASE_LO_BIT] = not_vec(exp[2 .. 0]);
        newc[CAP_LIMIT_EXP_HI_BIT .. CAP_LIMIT_LO_BIT] = not_vec(exp[5 .. 3])
    } else {
        newc[CAP_IE_BIT] = Bit(0b1);
        newc[CAP_BASE_EXP_HI_BIT .. CAP_BASE_LO_BIT] = Bbits[2 .. 0];
        newc[CAP_LIMIT_EXP_HI_BIT .. CAP_LIMIT_LO_BIT] = TBits[2 .. 0]
    };
    newc[CAP_BASE_HI_BIT .. CAP_BASE_MANTISSA_LO_BIT] = Bbits[CAP_MW - 1 .. 3];
    newc[CAP_LIMIT_HI_BIT .. CAP_LIMIT_MANTISSA_LO_BIT] = TBits[CAP_MW - 3 .. 3];
    let from_large : bool = not_bool(CapBoundsUsesValue(CapGetExponent(c)));
    let to_small : bool = CapBoundsUsesValue(exp);
    if (from_large & to_small) & SignExtend(base[CAP_FLAGS_LO_BIT - 1 .. 0], 64) != base then {
        newc[CAP_TAG_BIT] = Bit(0b0)
    } else ();
    if exact & (lostBottom | lostTop) then {
        newc[CAP_TAG_BIT] = Bit(0b0)
    } else ();
    return(newc)
}

val CapGetRepresentableMask : bits(CAP_VALUE_NUM_BITS) -> bits(CAP_VALUE_NUM_BITS) effect {escape, undef}

function CapGetRepresentableMask len = {
    c : bits(129) = CapNull();
    let test_base : bits(CAP_VALUE_NUM_BITS) = Ones(CAP_VALUE_NUM_BITS) - len;
    let test_length : bits(CAP_LENGTH_NUM_BITS) = ZeroExtend(len, CAP_LENGTH_NUM_BITS);
    c[CAP_VALUE_HI_BIT .. CAP_VALUE_LO_BIT] = test_base;
    let c : bits(129) = CapSetBounds(c, test_length, false);
    exp1 : int = 0;
    if CapIsInternalExponent(c) then {
        exp1 = CapGetExponent(c) + 3
    } else ();
    let 'exp1 = exp1;
    assert(constraint(64 - 'exp1 >= 0));
    assert(constraint('exp1 >= 0));
    return(Ones(CAP_VALUE_NUM_BITS - exp1) @ Zeros(exp1))
}

val CapWithTagSet : bits(129) -> bits(129)

function CapWithTagSet c = {
    return(CapSetTag(c, ZeroExtend(0b1, 64)))
}

val CapIsBaseAboveLimit : bits(129) -> bool effect {escape, undef}

function CapIsBaseAboveLimit c = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    limit : bits(CAP_BOUND_NUM_BITS) = undefined;
    (base, limit, __ignore_16) = CapGetBounds(c);
    return(CapUnsignedGreaterThan(base, limit))
}

val CapIsSubSetOf : (bits(129), bits(129)) -> bool effect {escape, undef}

function CapIsSubSetOf (a, b) = {
    abase : bits(CAP_BOUND_NUM_BITS) = undefined;
    alimit : bits(CAP_BOUND_NUM_BITS) = undefined;
    avalid : bool = undefined;
    bbase : bits(CAP_BOUND_NUM_BITS) = undefined;
    blimit : bits(CAP_BOUND_NUM_BITS) = undefined;
    bvalid : bool = undefined;
    (abase, alimit, avalid) = CapGetBounds(a);
    (bbase, blimit, bvalid) = CapGetBounds(b);
    let boundsSubset : bool = CapUnsignedGreaterThanOrEqual(abase, bbase) & CapUnsignedLessThanOrEqual(alimit, blimit);
    let permsSubset : bool = (CapGetPermissions(a) & not_vec(CapGetPermissions(b))) == Zeros(CAP_PERMS_NUM_BITS);
    return(((boundsSubset & permsSubset) & avalid) & bvalid)
}

val CapUnseal : bits(129) -> bits(129)

function CapUnseal c = {
    return(CapSetObjectType(c, Zeros(64)))
}

val CapGetOffset : bits(129) -> bits(CAP_VALUE_NUM_BITS) effect {escape, undef}

function CapGetOffset c = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    (base, __ignore_17, __ignore_18) = CapGetBounds(c);
    let offset : bits(65) = (0b0 @ CapGetValue(c)) - base;
    return(Slice(offset, 0, CAP_VALUE_NUM_BITS))
}

val CapGetLength : bits(129) -> bits(CAP_LENGTH_NUM_BITS) effect {escape, undef}

function CapGetLength c = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    limit : bits(CAP_BOUND_NUM_BITS) = undefined;
    (base, limit, __ignore_19) = CapGetBounds(c);
    return(limit - base)
}

val CapIsInBounds : bits(129) -> bool effect {escape, undef}

function CapIsInBounds c = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    limit : bits(CAP_BOUND_NUM_BITS) = undefined;
    valid_name : bool = undefined;
    (base, limit, valid_name) = CapGetBounds(c);
    let value65_name : bits(65) = 0b0 @ CapGetValue(c);
    return((CapUnsignedGreaterThanOrEqual(value65_name, base) & CapUnsignedLessThan(value65_name, limit)) & valid_name)
}

val CapSetOffset : (bits(129), bits(CAP_VALUE_NUM_BITS)) -> bits(129) effect {escape, undef}

function CapSetOffset (c, offset) = {
    base : bits(CAP_BOUND_NUM_BITS) = undefined;
    (base, __ignore_20, __ignore_21) = CapGetBounds(c);
    let newvalue : bits(CAP_VALUE_NUM_BITS) = base[CAP_VALUE_NUM_BITS - 1 .. 0] + offset;
    let increment_name : bits(CAP_VALUE_NUM_BITS) = newvalue - CapGetValue(c);
    return(CapAdd(c, increment_name))
}

val CapIsLocal : bits(129) -> bool

function CapIsLocal c = {
    return(not_bool(CapCheckPermissions(c, CAP_PERM_GLOBAL)))
}

val VACheckPerm : (VirtualAddress, bits(64)) -> bool effect {escape, rreg, undef}

function VACheckPerm (base, requested_perms) = {
    c : bits(129) = undefined;
    if VAIsBits64(base) then {
        c = DDC_read()
    } else {
        c = VAToCapability(base)
    };
    return(CapCheckPermissions(c, requested_perms))
}

val VAAdd : (VirtualAddress, bits(64)) -> VirtualAddress effect {escape, undef}

function VAAdd (v, offset) = {
    r : VirtualAddress = undefined;
    if VAIsCapability(v) then {
        r = VAFromCapability(CapAdd(VAToCapability(v), offset))
    } else {
        r = VAFromBits64(VAToBits64(v) + offset)
    };
    return(r)
}

val _TLB_Invalidate : unit -> unit

val __SAVE_EL : bits(2) -> unit

val __RESTORE_EL : unit -> unit

val MorelloCheckForCMO : (bits(129), bits(64), AccType) -> bits(64)

val CAP_DC_ZVA : bits(129) -> unit

val CAP_DC_CIVAC : bits(129) -> unit

val CAP_DC_CVAC : bits(129) -> unit

val CAP_DC_CVADP : bits(129) -> unit

val CAP_DC_CVAP : bits(129) -> unit

val CAP_DC_CVAU : bits(129) -> unit

val CAP_DC_IVAC : bits(129) -> unit

val CAP_IC_IVAU : bits(129) -> unit

val DC_CIVAC_ : bits(64) -> unit

val DC_CVAC_ : bits(64) -> unit

val DC_CVAU_ : bits(64) -> unit

val DC_IVAC_ : bits(64) -> unit

val DC_ZVA_ : bits(64) -> unit

val AArch64_AT_S12Ex : forall ('iswrite : Bool).
  (bits(64), bits(2), bool('iswrite)) -> unit

val AArch64_AT_S1Ex : forall ('iswrite : Bool).
  (bits(64), bits(2), bool('iswrite)) -> unit

val AArch64_EncodePAR : AddressDescriptor -> unit

val AArch64_PARFaultStatus : FaultRecord -> bits(6)

val PARShareabilityDecode : MemoryAttributes -> bits(2)

val PARAttrsDecode : MemoryAttributes -> bits(8)

val __TopLevel : unit -> unit

val __CycleEnd : unit -> unit

register configuration __syncAbortOnReadNormCache : bool = true

register configuration __syncAbortOnReadNormNonCache : bool = true

register configuration __syncAbortOnDeviceRead : bool = true

register configuration __syncAbortOnSoRead : bool = true

register configuration __syncAbortOnSoWrite : bool = true

register configuration __syncAbortOnPrefetch : bool = true

register configuration __syncAbortOnTTWCache : bool = true

register configuration __syncAbortOnTTWNonCache : bool = true

register configuration __syncAbortOnWriteNormCache : bool = false

register configuration __syncAbortOnWriteNormNonCache : bool = false

register configuration __syncAbortOnDeviceWrite : bool = false

val AArch64_IMPDEFResets : unit -> unit

val AArch64_SetLSInstructionSyndrome : forall 'Rt ('acq_rel : Bool) ('sign_extend : Bool) ('sixty_four : Bool) 'size.
  (int('size), bool('sign_extend), int('Rt), bool('sixty_four), bool('acq_rel)) -> unit

register configuration __v81_implemented : bool = true

register configuration __v82_implemented : bool = true

register configuration __support_52bit_pa : bool = false

register configuration __support_52bit_va : bool = true

register configuration __aa32_hpd_implemented : bool = true

register configuration __crc32_implemented : bool = true

register configuration __pan_implemented : bool = true

register configuration __vmid16_implemented : bool = true

register configuration __dot_product_implemented : bool = true

register configuration __fp16_implemented : bool = true

register configuration __crypto_aes_implemented : int = UInt(0x2)

register configuration __crypto_sha1_implemented : bool = true

register configuration __crypto_sha256_implemented : bool = true

register configuration __crypto_sha512_implemented : bool = false

register configuration __crypto_sha3_implemented : bool = false

register configuration __crypto_sm3_implemented : bool = false

register configuration __crypto_sm4_implemented : bool = false

register configuration __block_bbm_implemented : int = UInt(0x2)

register configuration __mpam_implemented : bool = false

register configuration __mpam_has_hcr : bool = true

register configuration __trickbox_enabled : bool = false

register configuration __mpam_partid_max : bits(16) = Zeros()

register configuration __mpam_pmg_max : bits(8) = Zeros()

register configuration __mpam_vpmr_max : bits(3) = Zeros()

register configuration CFG_RVBAR : bits(64) = ZeroExtend(0x10300000, 64)

register configuration CFG_RMR_AA64 : bits(1) = 0b1

register configuration HEAP_BASE : bits(64) = ZeroExtend(0x00000000, 64)

register configuration HEAP_LIMIT : bits(64) = ZeroExtend(0x0f000000, 64)

register configuration STACK_BASE : bits(64) = ZeroExtend(0x10000000, 64)

register configuration STACK_LIMIT : bits(64) = ZeroExtend(0x0f000000, 64)

register configuration CFG_MPIDR : bits(32) = 0x80000000

val __ConfigureV81Features : forall ('enabled : Bool). bool('enabled) -> unit

val __ConfigureV82Features : forall ('enabled : Bool). bool('enabled) -> unit

val AArch64_AutoGen_ArchitectureReset : forall ('cold : Bool).
  bool('cold) -> unit effect {escape, rreg, undef, wreg}

function AArch64_AutoGen_ArchitectureReset cold = {
    ELR_EL2 = SetSlice(65, ELR_EL2, 64, 0b00000000000000000000000000000000000000000000000000000000000000000);
    ELR_EL3 = SetSlice(65, ELR_EL3, 64, 0b00000000000000000000000000000000000000000000000000000000000000000);
    VBAR_EL2 = SetSlice(65, VBAR_EL2, 64, 0b00000000000000000000000000000000000000000000000000000000000000000);
    VBAR_EL2 = SetSlice(11, VBAR_EL2, 0, 0b00000000000);
    VBAR_EL2 = SetSlice(11, VBAR_EL2, 0, 0b00000000000);
    VBAR_EL3 = SetSlice(65, VBAR_EL3, 64, 0b00000000000000000000000000000000000000000000000000000000000000000);
    VBAR_EL3 = SetSlice(11, VBAR_EL3, 0, 0b00000000000);
    VBAR_EL3 = SetSlice(11, VBAR_EL3, 0, 0b00000000000);
    VBAR_EL1 = SetSlice(65, VBAR_EL1, 64, 0b00000000000000000000000000000000000000000000000000000000000000000);
    VBAR_EL1 = SetSlice(11, VBAR_EL1, 0, 0b00000000000);
    VBAR_EL1 = SetSlice(11, VBAR_EL1, 0, 0b00000000000);
    ELR_EL1 = SetSlice(65, ELR_EL1, 64, 0b00000000000000000000000000000000000000000000000000000000000000000);
    DDC_EL2 = SetSlice(129, DDC_EL2, 0, 0b111111111111111111100000000000000000000000000000100000000000001010000000000000000000000000000000000000000000000000000000000000000);
    RDDC_EL0 = SetSlice(129, RDDC_EL0, 0, 0b111111111111111111100000000000000000000000000000100000000000001010000000000000000000000000000000000000000000000000000000000000000);
    DDC_EL3 = SetSlice(129, DDC_EL3, 0, 0b111111111111111111100000000000000000000000000000100000000000001010000000000000000000000000000000000000000000000000000000000000000);
    DDC_EL0 = SetSlice(129, DDC_EL0, 0, 0b111111111111111111100000000000000000000000000000100000000000001010000000000000000000000000000000000000000000000000000000000000000);
    DDC_EL1 = SetSlice(129, DDC_EL1, 0, 0b111111111111111111100000000000000000000000000000100000000000001010000000000000000000000000000000000000000000000000000000000000000);
    HCR_EL2 = SetSlice(4, HCR_EL2, 60, 0b0000);
    HCR_EL2 = SetSlice(1, HCR_EL2, 59, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 58, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 57, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 56, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 51, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 48, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 47, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 46, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 45, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 44, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 43, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 42, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 41, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 40, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 39, 0b0);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 60, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 52, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 48, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 44, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 40, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 36, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 32, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 28, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 24, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 20, 0b0000);
    PAR_EL1 = SetSlice(4, PAR_EL1, 52, 0b0000);
    PAR_EL1 = SetSlice(1, PAR_EL1, 11, 0b1);
    PAR_EL1 = SetSlice(6, PAR_EL1, 1, 0b000000);
    PAR_EL1 = SetSlice(36, PAR_EL1, 12, 0b000000000000000000000000000000000000);
    PAR_EL1 = SetSlice(1, PAR_EL1, 11, 0b1);
    PAR_EL1 = SetSlice(1, PAR_EL1, 10, 0b0);
    PAR_EL1 = SetSlice(1, PAR_EL1, 7, 0b0);
    MDRAR_EL1 = SetSlice(12, MDRAR_EL1, 52, 0b000000000000);
    MDRAR_EL1 = SetSlice(10, MDRAR_EL1, 2, 0b0000000000);
    HCR_EL2 = SetSlice(4, HCR_EL2, 60, 0b0000);
    HCR_EL2 = SetSlice(1, HCR_EL2, 59, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 58, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 57, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 56, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 51, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 48, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 47, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 46, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 45, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 44, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 43, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 42, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 41, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 40, 0b0);
    HCR_EL2 = SetSlice(1, HCR_EL2, 39, 0b0);
    PAR_EL1 = SetSlice(4, PAR_EL1, 52, 0b0000);
    PAR_EL1 = SetSlice(1, PAR_EL1, 11, 0b1);
    PAR_EL1 = SetSlice(6, PAR_EL1, 1, 0b000000);
    PAR_EL1 = SetSlice(36, PAR_EL1, 12, 0b000000000000000000000000000000000000);
    PAR_EL1 = SetSlice(1, PAR_EL1, 11, 0b1);
    PAR_EL1 = SetSlice(1, PAR_EL1, 10, 0b0);
    PAR_EL1 = SetSlice(1, PAR_EL1, 7, 0b0);
    TCR_EL2 = SetSlice(32, TCR_EL2, 32, 0b00000000000000000000000000000000);
    TCR_EL2 = SetSlice(1, TCR_EL2, 31, 0b1);
    TCR_EL2 = SetSlice(1, TCR_EL2, 30, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 29, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 23, 0b1);
    TCR_EL2 = SetSlice(1, TCR_EL2, 19, 0b0);
    TCR_EL2 = SetSlice(2, TCR_EL2, 6, 0b00);
    TCR_EL2 = SetSlice(5, TCR_EL2, 59, 0b00000);
    TCR_EL2 = SetSlice(1, TCR_EL2, 58, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 57, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 56, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 55, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 52, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 51, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 35, 0b0);
    TCR_EL2 = SetSlice(1, TCR_EL2, 6, 0b0);
    ICC_ASGI1R_EL1 = SetSlice(8, ICC_ASGI1R_EL1, 56, 0b00000000);
    ICC_ASGI1R_EL1 = SetSlice(3, ICC_ASGI1R_EL1, 41, 0b000);
    ICC_ASGI1R_EL1 = SetSlice(4, ICC_ASGI1R_EL1, 28, 0b0000);
    SCTLR_EL1 = SetSlice(10, SCTLR_EL1, 54, 0b0000000000);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 53, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 52, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 51, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 50, 0b0);
    SCTLR_EL1 = SetSlice(4, SCTLR_EL1, 46, 0b0000);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 45, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 43, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 42, 0b0);
    SCTLR_EL1 = SetSlice(2, SCTLR_EL1, 40, 0b00);
    SCTLR_EL1 = SetSlice(2, SCTLR_EL1, 38, 0b00);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 37, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 36, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 35, 0b0);
    SCTLR_EL1 = SetSlice(3, SCTLR_EL1, 32, 0b000);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 31, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 30, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 27, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 22, 0b1);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 17, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 13, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 12, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 11, 0b1);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 6, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 2, 0b0);
    SCTLR_EL1 = SetSlice(1, SCTLR_EL1, 0, 0b0);
    VMPIDR_EL2 = SetSlice(24, VMPIDR_EL2, 40, 0b000000000000000000000000);
    VMPIDR_EL2 = SetSlice(1, VMPIDR_EL2, 31, 0b1);
    VMPIDR_EL2 = SetSlice(5, VMPIDR_EL2, 25, 0b00000);
    ICC_SGI1R_EL1 = SetSlice(8, ICC_SGI1R_EL1, 56, 0b00000000);
    ICC_SGI1R_EL1 = SetSlice(3, ICC_SGI1R_EL1, 41, 0b000);
    ICC_SGI1R_EL1 = SetSlice(4, ICC_SGI1R_EL1, 28, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 60, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 52, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 48, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 44, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 40, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 36, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 32, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 28, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 24, 0b0000);
    ID_AA64MMFR2_EL1 = SetSlice(4, ID_AA64MMFR2_EL1, 20, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(8, ID_AA64ISAR1_EL1, 56, 0b00000000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 48, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 32, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 28, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 24, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 20, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 16, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 12, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 8, 0b0000);
    ID_AA64ISAR1_EL1 = SetSlice(4, ID_AA64ISAR1_EL1, 4, 0b0000);
    ID_AA64DFR0_EL1 = SetSlice(12, ID_AA64DFR0_EL1, 52, 0b000000000000);
    ID_AA64DFR0_EL1 = SetSlice(4, ID_AA64DFR0_EL1, 48, 0b0000);
    ID_AA64DFR0_EL1 = SetSlice(4, ID_AA64DFR0_EL1, 44, 0b0000);
    ID_AA64DFR0_EL1 = SetSlice(4, ID_AA64DFR0_EL1, 40, 0b0000);
    ID_AA64DFR0_EL1 = SetSlice(4, ID_AA64DFR0_EL1, 24, 0b0000);
    ID_AA64DFR0_EL1 = SetSlice(4, ID_AA64DFR0_EL1, 16, 0b0000);
    ID_AA64PFR0_EL1 = SetSlice(4, ID_AA64PFR0_EL1, 60, 0b0000);
    ID_AA64PFR0_EL1 = SetSlice(4, ID_AA64PFR0_EL1, 56, 0b0000);
    ID_AA64PFR0_EL1 = SetSlice(4, ID_AA64PFR0_EL1, 52, 0b0000);
    ID_AA64PFR0_EL1 = SetSlice(4, ID_AA64PFR0_EL1, 48, 0b0000);
    ID_AA64PFR0_EL1 = SetSlice(4, ID_AA64PFR0_EL1, 44, 0b0000);
    ID_AA64PFR0_EL1 = SetSlice(4, ID_AA64PFR0_EL1, 36, 0b0000);
    ID_AA64ISAR0_EL1 = SetSlice(4, ID_AA64ISAR0_EL1, 60, 0b0000);
    ID_AA64ISAR0_EL1 = SetSlice(4, ID_AA64ISAR0_EL1, 56, 0b0000);
    ID_AA64ISAR0_EL1 = SetSlice(4, ID_AA64ISAR0_EL1, 24, 0b0000);
    ID_AA64ISAR0_EL1 = SetSlice(4, ID_AA64ISAR0_EL1, 0, 0b0000);
    ID_AA64MMFR1_EL1 = SetSlice(24, ID_AA64MMFR1_EL1, 40, 0b000000000000000000000000);
    ID_AA64MMFR1_EL1 = SetSlice(4, ID_AA64MMFR1_EL1, 32, 0b0000);
    CLIDR_EL1 = SetSlice(17, CLIDR_EL1, 47, 0b00000000000000000);
    CLIDR_EL1 = SetSlice(14, CLIDR_EL1, 33, 0b00000000000000);
    LOREA_EL1 = SetSlice(12, LOREA_EL1, 52, 0b000000000000);
    LOREA_EL1 = SetSlice(16, LOREA_EL1, 0, 0b0000000000000000);
    MPIDR_EL1 = SetSlice(24, MPIDR_EL1, 40, 0b000000000000000000000000);
    MPIDR_EL1 = SetSlice(1, MPIDR_EL1, 31, 0b1);
    MPIDR_EL1 = SetSlice(5, MPIDR_EL1, 25, 0b00000);
    TTBR0_EL3 = SetSlice(16, TTBR0_EL3, 48, 0b0000000000000000);
    ICC_SGI0R_EL1 = SetSlice(8, ICC_SGI0R_EL1, 56, 0b00000000);
    ICC_SGI0R_EL1 = SetSlice(3, ICC_SGI0R_EL1, 41, 0b000);
    ICC_SGI0R_EL1 = SetSlice(4, ICC_SGI0R_EL1, 28, 0b0000);
    TCR_EL1 = SetSlice(5, TCR_EL1, 59, 0b00000);
    TCR_EL1 = SetSlice(1, TCR_EL1, 58, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 57, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 56, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 55, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 52, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 51, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 35, 0b0);
    TCR_EL1 = SetSlice(1, TCR_EL1, 6, 0b0);
    HPFAR_EL2 = SetSlice(1, HPFAR_EL2, 63, 0b0);
    HPFAR_EL2 = SetSlice(19, HPFAR_EL2, 44, 0b0000000000000000000);
    HPFAR_EL2 = SetSlice(4, HPFAR_EL2, 0, 0b0000);
    SCTLR_EL3 = SetSlice(10, SCTLR_EL3, 54, 0b0000000000);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 53, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 52, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 51, 0b0);
    SCTLR_EL3 = SetSlice(6, SCTLR_EL3, 45, 0b000000);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 43, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 42, 0b0);
    SCTLR_EL3 = SetSlice(2, SCTLR_EL3, 40, 0b00);
    SCTLR_EL3 = SetSlice(2, SCTLR_EL3, 38, 0b00);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 37, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 36, 0b0);
    SCTLR_EL3 = SetSlice(4, SCTLR_EL3, 32, 0b0000);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 31, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 30, 0b0);
    SCTLR_EL3 = SetSlice(2, SCTLR_EL3, 28, 0b11);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 27, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 26, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 24, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 23, 0b1);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 22, 0b1);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 20, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 18, 0b1);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 17, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 16, 0b1);
    SCTLR_EL3 = SetSlice(2, SCTLR_EL3, 14, 0b00);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 13, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 12, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 11, 0b1);
    SCTLR_EL3 = SetSlice(4, SCTLR_EL3, 7, 0b0000);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 6, 0b0);
    SCTLR_EL3 = SetSlice(2, SCTLR_EL3, 4, 0b11);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 2, 0b0);
    SCTLR_EL3 = SetSlice(1, SCTLR_EL3, 0, 0b0);
    SCTLR_EL2 = SetSlice(10, SCTLR_EL2, 54, 0b0000000000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 53, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 52, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 51, 0b0);
    SCTLR_EL2 = SetSlice(6, SCTLR_EL2, 45, 0b000000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 43, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 42, 0b0);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 40, 0b00);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 38, 0b00);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 37, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 36, 0b0);
    SCTLR_EL2 = SetSlice(4, SCTLR_EL2, 32, 0b0000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 31, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 30, 0b0);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 28, 0b11);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 27, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 26, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 24, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 23, 0b1);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 22, 0b1);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 20, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 18, 0b1);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 17, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 16, 0b1);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 14, 0b00);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 13, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 12, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 11, 0b1);
    SCTLR_EL2 = SetSlice(4, SCTLR_EL2, 7, 0b0000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 6, 0b0);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 4, 0b11);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 2, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 0, 0b0);
    SCTLR_EL2 = SetSlice(10, SCTLR_EL2, 54, 0b0000000000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 53, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 52, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 51, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 50, 0b0);
    SCTLR_EL2 = SetSlice(4, SCTLR_EL2, 46, 0b0000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 45, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 43, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 42, 0b0);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 40, 0b00);
    SCTLR_EL2 = SetSlice(2, SCTLR_EL2, 38, 0b00);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 37, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 36, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 35, 0b0);
    SCTLR_EL2 = SetSlice(3, SCTLR_EL2, 32, 0b000);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 31, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 30, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 27, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 22, 0b1);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 17, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 13, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 12, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 11, 0b1);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 9, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 6, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 2, 0b0);
    SCTLR_EL2 = SetSlice(1, SCTLR_EL2, 0, 0b0);
    LORSA_EL1 = SetSlice(12, LORSA_EL1, 52, 0b000000000000);
    LORSA_EL1 = SetSlice(15, LORSA_EL1, 1, 0b000000000000000);
    LORSA_EL1 = SetSlice(1, LORSA_EL1, 0, 0b0);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 60, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 48, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 40, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 36, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 32, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 28, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 24, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 16, 0b0000);
    ID_AA64ZFR0_EL1 = SetSlice(8, ID_AA64ZFR0_EL1, 8, 0b00000000);
    ID_AA64ZFR0_EL1 = SetSlice(4, ID_AA64ZFR0_EL1, 4, 0b0000);
    MPAM3_EL3 = SetSlice(1, MPAM3_EL3, 63, 0b0);
    if cold then {
        MPAM3_EL3 = SetSlice(1, MPAM3_EL3, 62, 0b1)
    } else ();
    MPAM3_EL3 = SetSlice(1, MPAM3_EL3, 61, 0b0);
    MPAM3_EL3 = SetSlice(1, MPAM3_EL3, 60, 0b0);
    MPAM3_EL3 = SetSlice(12, MPAM3_EL3, 48, 0b000000000000);
    MPAMIDR_EL1 = SetSlice(2, MPAMIDR_EL1, 62, 0b00);
    MPAMIDR_EL1 = SetSlice(1, MPAMIDR_EL1, 61, 0b0);
    MPAMIDR_EL1 = SetSlice(1, MPAMIDR_EL1, 60, 0b0);
    MPAMIDR_EL1 = SetSlice(1, MPAMIDR_EL1, 59, 0b0);
    MPAMIDR_EL1 = SetSlice(1, MPAMIDR_EL1, 58, 0b0);
    MPAMIDR_EL1 = SetSlice(18, MPAMIDR_EL1, 40, 0b000000000000000000);
    MPAMIDR_EL1 = SetSlice(11, MPAMIDR_EL1, 21, 0b00000000000);
    MPAMIDR_EL1 = SetSlice(1, MPAMIDR_EL1, 16, 0b0);
    MPAM2_EL2_write() = SetSlice(4, MPAM2_EL2_read(), 59, 0b0000);
    MPAM2_EL2_write() = SetSlice(1, MPAM2_EL2_read(), 58, 0b0);
    MPAM2_EL2_write() = SetSlice(8, MPAM2_EL2_read(), 50, 0b00000000);
    MPAM2_EL2_write() = SetSlice(1, MPAM2_EL2_read(), 63, 0b0);
    MPAM0_EL1 = SetSlice(16, MPAM0_EL1, 48, 0b0000000000000000);
    MPAM1_EL1_write() = SetSlice(1, MPAM1_EL1_read(), 63, 0b0);
    MPAM1_EL1_write() = SetSlice(2, MPAM1_EL1_read(), 61, 0b00);
    MPAM1_EL1_write() = SetSlice(1, MPAM1_EL1_read(), 60, 0b0);
    MPAM1_EL1_write() = SetSlice(12, MPAM1_EL1_read(), 48, 0b000000000000);
    PMSICR_EL1 = SetSlice(24, PMSICR_EL1, 32, 0b000000000000000000000000);
    PMSEVFR_EL1 = SetSlice(1, PMSEVFR_EL1, 18, 0b0);
    PMSEVFR_EL1 = SetSlice(1, PMSEVFR_EL1, 17, 0b0);
    PMSEVFR_EL1 = SetSlice(1, PMSEVFR_EL1, 16, 0b0);
    PMSEVFR_EL1 = SetSlice(1, PMSEVFR_EL1, 11, 0b0);
    (PMSEVFR_EL1[47 .. 32] @ PMSEVFR_EL1[23 .. 19] @ PMSEVFR_EL1[10 .. 8] @ PMSEVFR_EL1[6 .. 6] @ PMSEVFR_EL1[4 .. 4] @ PMSEVFR_EL1[2 .. 2] @ PMSEVFR_EL1[0 .. 0]) = 0b0000000000000000000000000000;
    PMBLIMITR_EL1 = SetSlice(9, PMBLIMITR_EL1, 3, 0b000000000);
    PMBLIMITR_EL1 = SetSlice(1, PMBLIMITR_EL1, 0, 0b0);
    ID_MMFR4_EL1 = SetSlice(4, ID_MMFR4_EL1, 24, 0b0000);
    DSPSR_EL0 = SetSlice(1, DSPSR_EL0, 24, 0b0);
    DSPSR_EL0 = SetSlice(1, DSPSR_EL0, 27, 0b0);
    DSPSR_EL0 = SetSlice(1, DSPSR_EL0, 25, 0b0);
    DSPSR_EL0 = SetSlice(1, DSPSR_EL0, 24, 0b0);
    DSPSR_EL0 = SetSlice(7, DSPSR_EL0, 13, 0b0000000);
    DSPSR_EL0 = SetSlice(2, DSPSR_EL0, 10, 0b00);
    DSPSR_EL0 = SetSlice(1, DSPSR_EL0, 5, 0b0);
    ICC_CTLR_EL1_write() = SetSlice(2, ICC_CTLR_EL1_read(), 16, 0b00);
    ICC_CTLR_EL1_write() = SetSlice(1, ICC_CTLR_EL1_read(), 7, 0b0);
    ICC_CTLR_EL1_write() = SetSlice(4, ICC_CTLR_EL1_read(), 2, 0b0000);
    SPSR_irq = SetSlice(1, SPSR_irq, 21, 0b0);
    SPSR_abt = SetSlice(1, SPSR_abt, 21, 0b0);
    TCR_EL3 = SetSlice(1, TCR_EL3, 31, 0b1);
    TCR_EL3 = SetSlice(1, TCR_EL3, 30, 0b0);
    TCR_EL3 = SetSlice(1, TCR_EL3, 29, 0b0);
    TCR_EL3 = SetSlice(1, TCR_EL3, 23, 0b1);
    TCR_EL3 = SetSlice(1, TCR_EL3, 19, 0b0);
    TCR_EL3 = SetSlice(2, TCR_EL3, 6, 0b00);
    ICC_PMR_EL1 = SetSlice(8, ICC_PMR_EL1, 0, 0b00000000);
    RMR_EL1 = SetSlice(1, RMR_EL1, 1, 0b0);
    if cold then {
        OSLSR_EL1 = SetSlice(1, OSLSR_EL1, 1, 0b1)
    } else ();
    ICC_CTLR_EL3 = SetSlice(1, ICC_CTLR_EL3, 16, 0b0);
    ICC_CTLR_EL3 = SetSlice(1, ICC_CTLR_EL3, 7, 0b0);
    ICC_CTLR_EL3 = SetSlice(1, ICC_CTLR_EL3, 6, 0b0);
    ICH_VMCR_EL2 = SetSlice(8, ICH_VMCR_EL2, 10, 0b00000000);
    ICH_VMCR_EL2 = SetSlice(4, ICH_VMCR_EL2, 5, 0b0000);
    CCSIDR_EL1 = SetSlice(4, CCSIDR_EL1, 28, 0b0000);
    ICV_CTLR_EL1 = SetSlice(2, ICV_CTLR_EL1, 16, 0b00);
    ICV_CTLR_EL1 = SetSlice(6, ICV_CTLR_EL1, 2, 0b000000);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 28, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 27, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 26, 0b0);
    MDCR_EL3 = SetSlice(2, MDCR_EL3, 24, 0b00);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 23, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 22, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 21, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 20, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 19, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 18, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 17, 0b0);
    MDCR_EL3 = SetSlice(1, MDCR_EL3, 11, 0b0);
    MDCR_EL3 = SetSlice(2, MDCR_EL3, 7, 0b00);
    MDCR_EL3 = SetSlice(6, MDCR_EL3, 0, 0b000000);
    ICC_SRE_EL2 = SetSlice(1, ICC_SRE_EL2, 2, 0b0);
    ICC_SRE_EL2 = SetSlice(1, ICC_SRE_EL2, 1, 0b0);
    ICC_SRE_EL2 = SetSlice(1, ICC_SRE_EL2, 0, 0b0);
    LORC_EL1 = SetSlice(1, LORC_EL1, 1, 0b0);
    LORC_EL1 = SetSlice(1, LORC_EL1, 0, 0b0);
    SPSR_und = SetSlice(1, SPSR_und, 21, 0b0);
    CTR_EL0 = SetSlice(1, CTR_EL0, 31, 0b1);
    CTR_EL0 = SetSlice(1, CTR_EL0, 30, 0b0);
    CTR_EL0 = SetSlice(10, CTR_EL0, 4, 0b0000000000);
    ID_ISAR5_EL1 = SetSlice(4, ID_ISAR5_EL1, 28, 0b0000);
    ID_ISAR5_EL1 = SetSlice(4, ID_ISAR5_EL1, 20, 0b0000);
    ICH_HCR_EL2 = SetSlice(5, ICH_HCR_EL2, 27, 0b00000);
    ICH_HCR_EL2 = SetSlice(12, ICH_HCR_EL2, 15, 0b000000000000);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 14, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 13, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 12, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 11, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 10, 0b0);
    ICH_HCR_EL2 = SetSlice(2, ICH_HCR_EL2, 8, 0b00);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 7, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 6, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 5, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 4, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 3, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 2, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 1, 0b0);
    ICH_HCR_EL2 = SetSlice(1, ICH_HCR_EL2, 0, 0b0);
    ICC_IGRPEN0_EL1 = SetSlice(1, ICC_IGRPEN0_EL1, 0, 0b0);
    FPCR = SetSlice(2, FPCR, 13, 0b00);
    FPCR = SetSlice(8, FPCR, 0, 0b00000000);
    PMCR_EL0 = SetSlice(3, PMCR_EL0, 8, 0b000);
    PMCR_EL0 = SetSlice(1, PMCR_EL0, 7, 0b0);
    PMCR_EL0 = SetSlice(1, PMCR_EL0, 0, 0b0);
    ID_MMFR4_EL1 = SetSlice(4, ID_MMFR4_EL1, 24, 0b0000);
    ID_AA64PFR1_EL1 = SetSlice(4, ID_AA64PFR1_EL1, 16, 0b0000);
    ID_AA64PFR1_EL1 = SetSlice(4, ID_AA64PFR1_EL1, 12, 0b0000);
    ID_AA64PFR1_EL1 = SetSlice(4, ID_AA64PFR1_EL1, 8, 0b0000);
    ID_AA64PFR1_EL1 = SetSlice(4, ID_AA64PFR1_EL1, 4, 0b0000);
    ID_AA64PFR1_EL1 = SetSlice(4, ID_AA64PFR1_EL1, 0, 0b0000);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 28, 0b0);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 27, 0b0);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 26, 0b0);
    MDCR_EL2 = SetSlice(2, MDCR_EL2, 24, 0b00);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 23, 0b0);
    MDCR_EL2 = SetSlice(3, MDCR_EL2, 20, 0b000);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 19, 0b0);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 18, 0b0);
    MDCR_EL2 = SetSlice(1, MDCR_EL2, 17, 0b0);
    MDCR_EL2 = SetSlice(2, MDCR_EL2, 15, 0b00);
    LORID_EL1 = SetSlice(8, LORID_EL1, 8, 0b00000000);
    FPSR = SetSlice(19, FPSR, 8, 0b0000000000000000000);
    FPSR = SetSlice(2, FPSR, 5, 0b00);
    DBGVCR32_EL2 = SetSlice(1, DBGVCR32_EL2, 29, 0b0);
    DBGVCR32_EL2 = SetSlice(17, DBGVCR32_EL2, 8, 0b00000000000000000);
    DBGVCR32_EL2 = SetSlice(1, DBGVCR32_EL2, 5, 0b0);
    DBGVCR32_EL2 = SetSlice(1, DBGVCR32_EL2, 0, 0b0);
    DBGVCR32_EL2 = SetSlice(1, DBGVCR32_EL2, 5, 0b0);
    DBGVCR32_EL2 = SetSlice(1, DBGVCR32_EL2, 0, 0b0);
    ICC_IGRPEN1_EL1_write() = SetSlice(1, ICC_IGRPEN1_EL1_read(), 0, 0b0);
    PMCCFILTR_EL0 = SetSlice(1, PMCCFILTR_EL0, 25, 0b0);
    PMCCFILTR_EL0 = SetSlice(1, PMCCFILTR_EL0, 24, 0b0);
    PMCCFILTR_EL0 = SetSlice(1, PMCCFILTR_EL0, 23, 0b0);
    PMCCFILTR_EL0 = SetSlice(23, PMCCFILTR_EL0, 0, 0b00000000000000000000000);
    ICC_SRE_EL1_write() = SetSlice(1, ICC_SRE_EL1_read(), 2, 0b0);
    ICC_SRE_EL1_write() = SetSlice(1, ICC_SRE_EL1_read(), 1, 0b0);
    ICC_SRE_EL1_write() = SetSlice(1, ICC_SRE_EL1_read(), 0, 0b0);
    DBGCLAIMSET_EL1 = SetSlice(24, DBGCLAIMSET_EL1, 8, 0b000000000000000000000000);
    CPTR_EL2 = SetSlice(1, CPTR_EL2, 30, 0b0);
    CPTR_EL2 = SetSlice(1, CPTR_EL2, 29, 0b0);
    CPTR_EL2 = SetSlice(6, CPTR_EL2, 22, 0b000000);
    CPTR_EL2 = SetSlice(16, CPTR_EL2, 0, 0b0000000000000000);
    CPTR_EL2 = SetSlice(1, CPTR_EL2, 30, 0b0);
    CPTR_EL2 = SetSlice(9, CPTR_EL2, 21, 0b000000000);
    CPTR_EL2 = SetSlice(6, CPTR_EL2, 14, 0b000000);
    CPTR_EL2 = SetSlice(2, CPTR_EL2, 12, 0b11);
    CPTR_EL2 = SetSlice(1, CPTR_EL2, 11, 0b0);
    CPTR_EL2 = SetSlice(8, CPTR_EL2, 0, 0b11111111);
    ICH_VTR_EL2 = SetSlice(14, ICH_VTR_EL2, 5, 0b00000000000000);
    RMR_EL3 = SetSlice(1, RMR_EL3, 1, 0b0);
    CSSELR_EL1 = SetSlice(1, CSSELR_EL1, 4, 0b0);
    ID_ISAR6_EL1 = SetSlice(4, ID_ISAR6_EL1, 0, 0b0000);
    MDCCINT_EL1 = SetSlice(1, MDCCINT_EL1, 30, 0b0);
    MDCCINT_EL1 = SetSlice(1, MDCCINT_EL1, 29, 0b0);
    MDCCINT_EL1 = SetSlice(29, MDCCINT_EL1, 0, 0b00000000000000000000000000000);
    CNTKCTL_EL1 = SetSlice(1, CNTKCTL_EL1, 17, 0b0);
    CNTKCTL_EL1 = SetSlice(7, CNTKCTL_EL1, 10, 0b0000000);
    CNTKCTL_EL1 = SetSlice(1, CNTKCTL_EL1, 2, 0b0);
    SPSR_EL3 = SetSlice(1, SPSR_EL3, 24, 0b0);
    SPSR_EL3 = SetSlice(1, SPSR_EL3, 27, 0b0);
    SPSR_EL3 = SetSlice(1, SPSR_EL3, 25, 0b0);
    SPSR_EL3 = SetSlice(1, SPSR_EL3, 24, 0b0);
    SPSR_EL3 = SetSlice(7, SPSR_EL3, 13, 0b0000000);
    SPSR_EL3 = SetSlice(2, SPSR_EL3, 10, 0b00);
    SPSR_EL3 = SetSlice(1, SPSR_EL3, 5, 0b0);
    MDCCSR_EL0 = SetSlice(10, MDCCSR_EL0, 19, 0b0000000000);
    MDCCSR_EL0 = SetSlice(4, MDCCSR_EL0, 15, 0b0000);
    MDCCSR_EL0 = SetSlice(2, MDCCSR_EL0, 13, 0b00);
    MDCCSR_EL0 = SetSlice(1, MDCCSR_EL0, 12, 0b0);
    MDCCSR_EL0 = SetSlice(6, MDCCSR_EL0, 6, 0b000000);
    MDCCSR_EL0 = SetSlice(4, MDCCSR_EL0, 2, 0b0000);
    MDCCSR_EL0 = SetSlice(2, MDCCSR_EL0, 0, 0b00);
    SCR_EL3 = SetSlice(1, SCR_EL3, 29, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 28, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 27, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 26, 0b0);
    SCR_EL3 = SetSlice(3, SCR_EL3, 22, 0b000);
    SCR_EL3 = SetSlice(1, SCR_EL3, 21, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 20, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 19, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 18, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 17, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 16, 0b0);
    SCR_EL3 = SetSlice(1, SCR_EL3, 6, 0b0);
    SCR_EL3 = SetSlice(2, SCR_EL3, 4, 0b11);
    OSDLR_EL1 = SetSlice(1, OSDLR_EL1, 0, 0b0);
    VTCR_EL2 = SetSlice(1, VTCR_EL2, 31, 0b1);
    VTCR_EL2 = SetSlice(1, VTCR_EL2, 30, 0b0);
    VTCR_EL2 = SetSlice(1, VTCR_EL2, 29, 0b0);
    VTCR_EL2 = SetSlice(2, VTCR_EL2, 23, 0b00);
    VTCR_EL2 = SetSlice(1, VTCR_EL2, 20, 0b0);
    DBGCLAIMCLR_EL1 = SetSlice(24, DBGCLAIMCLR_EL1, 8, 0b000000000000000000000000);
    if cold then {
        DBGCLAIMCLR_EL1 = SetSlice(8, DBGCLAIMCLR_EL1, 0, 0b00000000)
    } else ();
    RMR_EL2 = SetSlice(1, RMR_EL2, 1, 0b0);
    ID_PFR2_EL1 = SetSlice(4, ID_PFR2_EL1, 8, 0b0000);
    ID_PFR2_EL1 = SetSlice(4, ID_PFR2_EL1, 4, 0b0000);
    ID_PFR2_EL1 = SetSlice(4, ID_PFR2_EL1, 0, 0b0000);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 7, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 6, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 5, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 4, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 3, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 2, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 1, 0b0);
    ICH_MISR_EL2 = SetSlice(1, ICH_MISR_EL2, 0, 0b0);
    SPSR_EL2 = SetSlice(1, SPSR_EL2, 24, 0b0);
    SPSR_EL2 = SetSlice(1, SPSR_EL2, 27, 0b0);
    SPSR_EL2 = SetSlice(1, SPSR_EL2, 25, 0b0);
    SPSR_EL2 = SetSlice(1, SPSR_EL2, 24, 0b0);
    SPSR_EL2 = SetSlice(7, SPSR_EL2, 13, 0b0000000);
    SPSR_EL2 = SetSlice(2, SPSR_EL2, 10, 0b00);
    SPSR_EL2 = SetSlice(1, SPSR_EL2, 5, 0b0);
    ISR_EL1 = SetSlice(6, ISR_EL1, 0, 0b000000);
    CPACR_EL1 = SetSlice(6, CPACR_EL1, 22, 0b000000);
    CPACR_EL1 = SetSlice(16, CPACR_EL1, 0, 0b0000000000000000);
    SPSR_EL1 = SetSlice(1, SPSR_EL1, 24, 0b0);
    SPSR_EL1 = SetSlice(1, SPSR_EL1, 27, 0b0);
    SPSR_EL1 = SetSlice(1, SPSR_EL1, 25, 0b0);
    SPSR_EL1 = SetSlice(1, SPSR_EL1, 24, 0b0);
    SPSR_EL1 = SetSlice(7, SPSR_EL1, 13, 0b0000000);
    SPSR_EL1 = SetSlice(2, SPSR_EL1, 10, 0b00);
    SPSR_EL1 = SetSlice(1, SPSR_EL1, 5, 0b0);
    FPEXC32_EL2 = SetSlice(15, FPEXC32_EL2, 11, 0b000000000000000);
    FPEXC32_EL2 = SetSlice(2, FPEXC32_EL2, 5, 0b00);
    MDSCR_EL1 = SetSlice(1, MDSCR_EL1, 31, 0b0);
    MDSCR_EL1 = SetSlice(1, MDSCR_EL1, 28, 0b0);
    MDSCR_EL1 = SetSlice(2, MDSCR_EL1, 24, 0b00);
    MDSCR_EL1 = SetSlice(1, MDSCR_EL1, 20, 0b0);
    MDSCR_EL1 = SetSlice(3, MDSCR_EL1, 16, 0b000);
    MDSCR_EL1 = SetSlice(5, MDSCR_EL1, 7, 0b00000);
    MDSCR_EL1 = SetSlice(5, MDSCR_EL1, 1, 0b00000);
    SPSR_fiq = SetSlice(1, SPSR_fiq, 21, 0b0);
    ID_PFR0_EL1 = SetSlice(4, ID_PFR0_EL1, 24, 0b0000);
    ID_PFR0_EL1 = SetSlice(4, ID_PFR0_EL1, 20, 0b0000);
    ID_PFR0_EL1 = SetSlice(4, ID_PFR0_EL1, 16, 0b0000);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 17, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 16, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 15, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 14, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 13, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 12, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 17, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 16, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 15, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 14, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 13, 0b0);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 12, 0b0);
    CNTHCTL_EL2 = SetSlice(4, CNTHCTL_EL2, 8, 0b0000);
    CNTHCTL_EL2 = SetSlice(1, CNTHCTL_EL2, 2, 0b0);
    IFSR32_EL2 = SetSlice(3, IFSR32_EL2, 13, 0b000);
    IFSR32_EL2 = SetSlice(1, IFSR32_EL2, 11, 0b0);
    IFSR32_EL2 = SetSlice(5, IFSR32_EL2, 4, 0b00000);
    IFSR32_EL2 = SetSlice(3, IFSR32_EL2, 13, 0b000);
    IFSR32_EL2 = SetSlice(2, IFSR32_EL2, 10, 0b00);
    IFSR32_EL2 = SetSlice(3, IFSR32_EL2, 6, 0b000);
    ICC_IGRPEN1_EL3 = SetSlice(1, ICC_IGRPEN1_EL3, 1, 0b0);
    ICC_IGRPEN1_EL3 = SetSlice(1, ICC_IGRPEN1_EL3, 0, 0b0);
    CPTR_EL3 = SetSlice(1, CPTR_EL3, 30, 0b0);
    CPTR_EL3 = SetSlice(9, CPTR_EL3, 21, 0b000000000);
    CPTR_EL3 = SetSlice(9, CPTR_EL3, 11, 0b000000000);
    CPTR_EL3 = SetSlice(1, CPTR_EL3, 9, 0b0);
    CPTR_EL3 = SetSlice(8, CPTR_EL3, 0, 0b00000000);
    ICC_SRE_EL3 = SetSlice(1, ICC_SRE_EL3, 2, 0b0);
    ICC_SRE_EL3 = SetSlice(1, ICC_SRE_EL3, 1, 0b0);
    ICC_SRE_EL3 = SetSlice(1, ICC_SRE_EL3, 0, 0b0);
    MPAMHCR_EL2 = SetSlice(22, MPAMHCR_EL2, 9, 0b0000000000000000000000);
    MPAMHCR_EL2 = SetSlice(6, MPAMHCR_EL2, 2, 0b000000);
    PMSCR_EL2 = SetSlice(1, PMSCR_EL2, 2, 0b0);
    PMSCR_EL1 = SetSlice(1, PMSCR_EL1, 2, 0b0);
    CCTLR_EL0 = SetSlice(1, CCTLR_EL0, 5, 0b0);
    CCTLR_EL0 = SetSlice(2, CCTLR_EL0, 0, 0b00);
    CCTLR_EL3 = SetSlice(1, CCTLR_EL3, 5, 0b0);
    CCTLR_EL3 = SetSlice(1, CCTLR_EL3, 1, 0b0);
    CCTLR_EL1 = SetSlice(1, CCTLR_EL1, 5, 0b0);
    CCTLR_EL2 = SetSlice(1, CCTLR_EL2, 5, 0b0)
}
