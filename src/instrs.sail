/******************************************************************************/
/*  BSD 3-clause Clear License                                                */
/*                                                                            */
/*  Copyright (c) 2022                                                        */
/*    Arm Limited (or its affiliates),                                        */
/*    Thomas Bauereiss,                                                       */
/*    Brian Campbell,                                                         */
/*    Alasdair Armstrong,                                                     */
/*    Alastair Reid,                                                          */
/*    Peter Sewell                                                            */
/*                                                                            */
/*  All rights reserved.                                                      */
/*                                                                            */
/*  Redistribution and use in source and binary forms, with or without        */
/*  modification, are permitted (subject to the limitations in the            */
/*  disclaimer below) provided that the following conditions are met:         */
/*                                                                            */
/*    * Redistributions of source code must retain the above copyright        */
/*      notice, this list of conditions and the following disclaimer.         */
/*    * Redistributions in binary form must reproduce the above copyright     */
/*      notice, this list of conditions and the following disclaimer in the   */
/*      documentation and/or other materials provided with the distribution.  */
/*    * Neither the name of ARM Limited nor the names of its contributors     */
/*      may be used to endorse or promote products derived from this          */
/*      software without specific prior written permission.                   */
/*                                                                            */
/*  NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED   */
/*  BY THIS LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND   */
/*  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,    */
/*  BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND         */
/*  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE   */
/*  COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,      */
/*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  */
/*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF      */
/*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON    */
/*  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   */
/*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  */
/*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.         */
/******************************************************************************/

val execute_aarch64_instrs_float_arithmetic_round_frint : forall 'd 'datasize ('exact : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('exact), int('n), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_round_frint (d, datasize, exact, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    let result : bits('datasize) = FPRoundInt(operand, FPCR, rounding, exact);
    V_set(datasize, d) = result
}

val decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint : (bits(5), bits(5), bits(3), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint (Rd, Rn, rmode, ftype, S, M) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    exact : bool = false;
    rounding : FPRounding = undefined;
    match rmode {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode[1 .. 0])
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_float_arithmetic_round_frint(d, datasize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let rmode = Slice(__opcode, 15, 3);
    let ftype = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let M = Slice(__opcode, 31, 1);
    decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint(Rd, Rn, rmode, ftype, S, M)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_immediate : forall 'd 'datasize 'n ('setflags : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits('datasize), int('n), bool('setflags), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_add_sub_immediate (d, datasize, imm, n, setflags, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = if n == 31 then SP_read(datasize) else X_read(datasize, n);
    operand2 : bits('datasize) = imm;
    nzcv : bits(4) = undefined;
    carry_in : bits(1) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    } else ();
    if d == 31 & not_bool(setflags) then {
        SP_set(datasize) = result
    } else {
        X_set(datasize, d) = result
    }
}

val decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate : (bits(5), bits(5), bits(12), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd, Rn, imm12, sh, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    imm : bits('datasize) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, datasize)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), datasize)
      }
    };
    let imm = imm;
    execute_aarch64_instrs_integer_arithmetic_add_sub_immediate(d, datasize, imm, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let sh = Slice(__opcode, 22, 1);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate(Rd, Rn, imm12, sh, S, op, sf)
}

val execute_aarch64_instrs_system_barriers_dmb : (MBReqDomain, MBReqTypes) -> unit effect {undef}

function execute_aarch64_instrs_system_barriers_dmb (domain, types) = {
    DataMemoryBarrier(domain, types)
}

val decode_dmb_aarch64_instrs_system_barriers_dmb : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {undef}

function decode_dmb_aarch64_instrs_system_barriers_dmb (Rt, opc, CRm, CRn, op1, op0, L) = {
    domain : MBReqDomain = undefined;
    types : MBReqTypes = undefined;
    match CRm[3 .. 2] {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    match CRm[1 .. 0] {
      0b00 => {
          types = MBReqTypes_All;
          domain = MBReqDomain_FullSystem
      },
      0b01 => {
          types = MBReqTypes_Reads
      },
      0b10 => {
          types = MBReqTypes_Writes
      },
      0b11 => {
          types = MBReqTypes_All
      }
    };
    let types = types;
    execute_aarch64_instrs_system_barriers_dmb(domain, types)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let op0 = Slice(__opcode, 19, 2);
    let L = Slice(__opcode, 21, 1);
    decode_dmb_aarch64_instrs_system_barriers_dmb(Rt, opc, CRm, CRn, op1, op0, L)
}

val execute_aarch64_instrs_system_barriers_dsb : (MBReqDomain, MBReqTypes) -> unit effect {undef}

function execute_aarch64_instrs_system_barriers_dsb (domain, types) = {
    DataSynchronizationBarrier(domain, types)
}

val decode_dsb_aarch64_instrs_system_barriers_dsb : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {undef}

function decode_dsb_aarch64_instrs_system_barriers_dsb (Rt, opc, CRm, CRn, op1, op0, L) = {
    domain : MBReqDomain = undefined;
    types : MBReqTypes = undefined;
    match CRm[3 .. 2] {
      0b00 => {
          domain = MBReqDomain_OuterShareable
      },
      0b01 => {
          domain = MBReqDomain_Nonshareable
      },
      0b10 => {
          domain = MBReqDomain_InnerShareable
      },
      0b11 => {
          domain = MBReqDomain_FullSystem
      }
    };
    match CRm[1 .. 0] {
      0b00 => {
          types = MBReqTypes_All;
          domain = MBReqDomain_FullSystem
      },
      0b01 => {
          types = MBReqTypes_Reads
      },
      0b10 => {
          types = MBReqTypes_Writes
      },
      0b11 => {
          types = MBReqTypes_All
      }
    };
    let types = types;
    execute_aarch64_instrs_system_barriers_dsb(domain, types)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let op0 = Slice(__opcode, 19, 2);
    let L = Slice(__opcode, 21, 1);
    decode_dsb_aarch64_instrs_system_barriers_dsb(Rt, opc, CRm, CRn, op1, op0, L)
}

val execute_aarch64_instrs_system_barriers_isb : unit -> unit

function execute_aarch64_instrs_system_barriers_isb () = {
    InstructionSynchronizationBarrier()
}

val decode_isb_aarch64_instrs_system_barriers_isb : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit

function decode_isb_aarch64_instrs_system_barriers_isb (Rt, opc, CRm, CRn, op1, op0, L) = {
    execute_aarch64_instrs_system_barriers_isb()
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let op0 = Slice(__opcode, 19, 2);
    let L = Slice(__opcode, 21, 1);
    decode_isb_aarch64_instrs_system_barriers_isb(Rt, opc, CRm, CRn, op1, op0, L)
}

val execute_aarch64_instrs_system_barriers_ssbb : unit -> unit

function execute_aarch64_instrs_system_barriers_ssbb () = {
    SpeculativeStoreBypassBarrierToVA()
}

val decode_ssbb_aarch64_instrs_system_barriers_ssbb : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit

function decode_ssbb_aarch64_instrs_system_barriers_ssbb (Rt, opc, CRm, CRn, op1, op0, L) = {
    execute_aarch64_instrs_system_barriers_ssbb()
}

function clause __DecodeA64 (pc, (0b11010101000000110011000010011111 as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let op0 = Slice(__opcode, 19, 2);
    let L = Slice(__opcode, 21, 1);
    decode_ssbb_aarch64_instrs_system_barriers_ssbb(Rt, opc, CRm, CRn, op1, op0, L)
}

val execute_aarch64_instrs_system_barriers_pssbb : unit -> unit

function execute_aarch64_instrs_system_barriers_pssbb () = {
    SpeculativeStoreBypassBarrierToPA()
}

val decode_pssbb_aarch64_instrs_system_barriers_pssbb : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit

function decode_pssbb_aarch64_instrs_system_barriers_pssbb (Rt, opc, CRm, CRn, op1, op0, L) = {
    execute_aarch64_instrs_system_barriers_pssbb()
}

function clause __DecodeA64 (pc, (0b11010101000000110011010010011111 as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let op0 = Slice(__opcode, 19, 2);
    let L = Slice(__opcode, 21, 1);
    decode_pssbb_aarch64_instrs_system_barriers_pssbb(Rt, opc, CRm, CRn, op1, op0, L)
}

val execute_aarch64_instrs_system_barriers_sb : unit -> unit effect {escape}

function execute_aarch64_instrs_system_barriers_sb () = {
    SpeculationBarrier()
}

val decode_sb_aarch64_instrs_system_barriers_sb : (bits(5), bits(2), bits(4), bits(4), bits(3), bits(2), bits(1)) -> unit effect {escape}

function decode_sb_aarch64_instrs_system_barriers_sb (Rt, opc, CRm, CRn, op1, op0, L) = {
    if not_bool(HaveSBExt()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_system_barriers_sb()
}

function clause __DecodeA64 (pc, (0b11010101000000110011000011111111 as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let opc = Slice(__opcode, 5, 2);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let op0 = Slice(__opcode, 19, 2);
    let L = Slice(__opcode, 21, 1);
    decode_sb_aarch64_instrs_system_barriers_sb(Rt, opc, CRm, CRn, op1, op0, L)
}

val execute_ADR_C_I_C : forall ('d : Int), (0 <= 'd & 'd <= 31).
  (int('d), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_ADR_C_I_C (d, imm) = {
    if IsInC64() then {
        let addr : bits(129) = PCC_read();
        C_set(d) = CapAdd(addr, imm)
    } else {
        addr : bits(64) = undefined;
        if [CCTLR_read__1()[3]] == 0b1 then {
            addr = CapGetOffset(PCC_read())
        } else {
            addr = CapGetValue(PCC_read())
        };
        X_set(64, d) = addr + imm
    }
}

val decode_ADR_C_I_C : (bits(1), bits(2), bits(1), bits(18), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ADR_C_I_C (op, immlo, P, immhi, Rd) = {
    let 'd = UInt(Rd);
    let imm : bits(64) = SignExtend((P @ immhi) @ immlo, 64);
    execute_ADR_C_I_C(d, imm)
}

function clause __DecodeA64 (pc, ([bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op = Slice(__opcode, 31, 1);
    let immlo = Slice(__opcode, 29, 2);
    let P = Slice(__opcode, 23, 1);
    let immhi = Slice(__opcode, 5, 18);
    let Rd = Slice(__opcode, 0, 5);
    decode_ADR_C_I_C(op, immlo, P, immhi, Rd)
}

val execute_ADRP_C_I_C : forall ('d : Int), (0 <= 'd & 'd <= 31).
  (bits(1), int('d), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_ADRP_C_I_C (P, d, imm) = {
    if IsInC64() then {
        addr : bits(129) = undefined;
        if P == 0b0 then {
            if [CCTLR_read__1()[4]] == 0b1 then {
                addr = C_read(28)
            } else {
                addr = DDC_read()
            }
        } else {
            addr = PCC_read()
        };
        let newvalue : bits(64) = CapGetValue(addr) & not_vec(ZeroExtend(Ones(12), 64));
        let offset : bits(64) = newvalue - CapGetValue(addr) + imm;
        result : bits(129) = CapAdd(addr, offset);
        if CapIsSealed(addr) then {
            result = CapWithTagClear(result)
        } else ();
        C_set(d) = result
    } else {
        addr : bits(64) = undefined;
        if [CCTLR_read__1()[3]] == 0b1 then {
            addr = CapGetOffset(PCC_read())
        } else {
            addr = CapGetValue(PCC_read())
        };
        addr[11 .. 0] = Zeros(12);
        X_set(64, d) = addr + imm
    }
}

val decode_ADRP_C_I_C : (bits(1), bits(2), bits(1), bits(18), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ADRP_C_I_C (op, immlo, P, immhi, Rd) = {
    let 'd = UInt(Rd);
    imm : bits(64) = undefined;
    if IsInC64() then {
        if P == 0b1 then {
            imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
        } else {
            imm = ZeroExtend((immhi @ immlo) @ Zeros(12), 64)
        }
    } else {
        imm = SignExtend(((P @ immhi) @ immlo) @ Zeros(12), 64)
    };
    execute_ADRP_C_I_C(P, d, imm)
}

function clause __DecodeA64 (pc, ([bitone, _, _, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op = Slice(__opcode, 31, 1);
    let immlo = Slice(__opcode, 29, 2);
    let P = Slice(__opcode, 23, 1);
    let immhi = Slice(__opcode, 5, 18);
    let Rd = Slice(__opcode, 0, 5);
    decode_ADRP_C_I_C(op, immlo, P, immhi, Rd)
}

val execute_ADRP_C_IP_C : forall ('d : Int), (0 <= 'd & 'd <= 31).
  (bits(1), int('d), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_ADRP_C_IP_C (P, d, imm) = {
    if IsInC64() then {
        addr : bits(129) = undefined;
        if P == 0b0 then {
            if [CCTLR_read__1()[4]] == 0b1 then {
                addr = C_read(28)
            } else {
                addr = DDC_read()
            }
        } else {
            addr = PCC_read()
        };
        let newvalue : bits(64) = CapGetValue(addr) & not_vec(ZeroExtend(Ones(12), 64));
        let offset : bits(64) = newvalue - CapGetValue(addr) + imm;
        result : bits(129) = CapAdd(addr, offset);
        if CapIsSealed(addr) then {
            result = CapWithTagClear(result)
        } else ();
        C_set(d) = result
    } else {
        addr : bits(64) = undefined;
        if [CCTLR_read__1()[3]] == 0b1 then {
            addr = CapGetOffset(PCC_read())
        } else {
            addr = CapGetValue(PCC_read())
        };
        addr[11 .. 0] = Zeros(12);
        X_set(64, d) = addr + imm
    }
}

val decode_ADRP_C_IP_C : (bits(1), bits(2), bits(1), bits(18), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ADRP_C_IP_C (op, immlo, P, immhi, Rd) = {
    let 'd = UInt(Rd);
    imm : bits(64) = undefined;
    if IsInC64() then {
        if P == 0b1 then {
            imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
        } else {
            imm = ZeroExtend((immhi @ immlo) @ Zeros(12), 64)
        }
    } else {
        imm = SignExtend(((P @ immhi) @ immlo) @ Zeros(12), 64)
    };
    execute_ADRP_C_IP_C(P, d, imm)
}

function clause __DecodeA64 (pc, ([bitone, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op = Slice(__opcode, 31, 1);
    let immlo = Slice(__opcode, 29, 2);
    let P = Slice(__opcode, 23, 1);
    let immhi = Slice(__opcode, 5, 18);
    let Rd = Slice(__opcode, 0, 5);
    decode_ADRP_C_IP_C(op, immlo, P, immhi, Rd)
}

val execute_ADRDP_C_ID_C : forall ('d : Int), (0 <= 'd & 'd <= 31).
  (bits(1), int('d), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_ADRDP_C_ID_C (P, d, imm) = {
    if IsInC64() then {
        addr : bits(129) = undefined;
        if P == 0b0 then {
            if [CCTLR_read__1()[4]] == 0b1 then {
                addr = C_read(28)
            } else {
                addr = DDC_read()
            }
        } else {
            addr = PCC_read()
        };
        let newvalue : bits(64) = CapGetValue(addr) & not_vec(ZeroExtend(Ones(12), 64));
        let offset : bits(64) = newvalue - CapGetValue(addr) + imm;
        result : bits(129) = CapAdd(addr, offset);
        if CapIsSealed(addr) then {
            result = CapWithTagClear(result)
        } else ();
        C_set(d) = result
    } else {
        addr : bits(64) = undefined;
        if [CCTLR_read__1()[3]] == 0b1 then {
            addr = CapGetOffset(PCC_read())
        } else {
            addr = CapGetValue(PCC_read())
        };
        addr[11 .. 0] = Zeros(12);
        X_set(64, d) = addr + imm
    }
}

val decode_ADRDP_C_ID_C : (bits(1), bits(2), bits(1), bits(18), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ADRDP_C_ID_C (op, immlo, P, immhi, Rd) = {
    let 'd = UInt(Rd);
    imm : bits(64) = undefined;
    if IsInC64() then {
        if P == 0b1 then {
            imm = SignExtend((immhi @ immlo) @ Zeros(12), 64)
        } else {
            imm = ZeroExtend((immhi @ immlo) @ Zeros(12), 64)
        }
    } else {
        imm = SignExtend(((P @ immhi) @ immlo) @ Zeros(12), 64)
    };
    execute_ADRDP_C_ID_C(P, d, imm)
}

function clause __DecodeA64 (pc, ([bitone, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op = Slice(__opcode, 31, 1);
    let immlo = Slice(__opcode, 29, 2);
    let P = Slice(__opcode, 23, 1);
    let immhi = Slice(__opcode, 5, 18);
    let Rd = Slice(__opcode, 0, 5);
    decode_ADRDP_C_ID_C(op, immlo, P, immhi, Rd)
}

val execute_ADD_C_CIS_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(64), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_ADD_C_CIS_C (d, imm, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let 'operand2 = UInt(imm);
    result : bits(129) = CapAdd__1(operand1, operand2);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_ADD_C_CIS_C : (bits(1), bits(1), bits(12), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ADD_C_CIS_C (A, sh, imm12, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    imm : bits(64) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, 64)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), 64)
      }
    };
    let imm = imm;
    execute_ADD_C_CIS_C(d, imm, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let A = Slice(__opcode, 23, 1);
    let sh = Slice(__opcode, 22, 1);
    let imm12 = Slice(__opcode, 10, 12);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_ADD_C_CIS_C(A, sh, imm12, Cn, Cd)
}

val execute_ADD_C_CRI_C : forall 'd 'm 'n 'shift,
  ('shift in {0, 1, 2, 3, 4, 5, 6, 7} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), ExtendType, int('m), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function execute_ADD_C_CRI_C (d, extend_type, m, n, shift) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(64) = ExtendReg(64, m, extend_type, shift);
    result : bits(129) = CapAdd(operand1, operand2);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_ADD_C_CRI_C : (bits(5), bits(3), bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ADD_C_CRI_C (Rm, option_name, imm3, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    } else ();
    execute_ADD_C_CRI_C(d, extend_type, m, n, shift)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let option_name = Slice(__opcode, 13, 3);
    let imm3 = Slice(__opcode, 10, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_ADD_C_CRI_C(Rm, option_name, imm3, Cn, Cd)
}

val execute_ALDUR_C_RI_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_C_RI_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
    data : bits(129) = MemC_read(addr, AccType_NORMAL);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_ALDUR_C_RI_C : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_C_RI_C (op1, V, imm9, op2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    execute_ALDUR_C_RI_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_ALDUR_C_RI_C (op1, V, imm9, op2, Rn, Ct);
    decode_ALDUR_C_RI_C(op1, V, imm9, op2, Rn, Ct)
}

val execute_ALDUR_R_RI_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_R_RI_32 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDUR_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 32;
    let 'regsize = 32;
    execute_ALDUR_R_RI_32(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDUR_R_RI_64 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 'datasize == 64).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_R_RI_64 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDUR_R_RI_64 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_R_RI_64 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 64;
    let 'regsize = 64;
    execute_ALDUR_R_RI_64(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_R_RI_64(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDUR_V_RI_B : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_V_RI_B (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDUR_V_RI_B : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_V_RI_B (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 8;
    execute_ALDUR_V_RI_B(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_V_RI_B(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDUR_V_RI_D : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 64).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_V_RI_D (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDUR_V_RI_D : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_V_RI_D (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 64;
    execute_ALDUR_V_RI_D(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_V_RI_D(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDUR_V_RI_H : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 16).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_V_RI_H (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDUR_V_RI_H : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_V_RI_H (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 16;
    execute_ALDUR_V_RI_H(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_V_RI_H(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDUR_V_RI_Q : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 128).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_V_RI_Q (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDUR_V_RI_Q : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_V_RI_Q (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 128;
    execute_ALDUR_V_RI_Q(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_V_RI_Q(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDUR_V_RI_S : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDUR_V_RI_S (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDUR_V_RI_S : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDUR_V_RI_S (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 32;
    execute_ALDUR_V_RI_S(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDUR_V_RI_S(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURB_R_RI_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURB_R_RI_32 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDURB_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURB_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 8;
    let 'regsize = 32;
    execute_ALDURB_R_RI_32(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURB_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURH_R_RI_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 16).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURH_R_RI_32 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDURH_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURH_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 16;
    let 'regsize = 32;
    execute_ALDURH_R_RI_32(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURH_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURSB_R_RI_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURSB_R_RI_32 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDURSB_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURSB_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 8;
    let 'regsize = 32;
    execute_ALDURSB_R_RI_32(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURSB_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURSB_R_RI_64 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURSB_R_RI_64 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDURSB_R_RI_64 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURSB_R_RI_64 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 8;
    let 'regsize = 64;
    execute_ALDURSB_R_RI_64(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURSB_R_RI_64(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURSH_R_RI_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 16).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURSH_R_RI_32 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDURSH_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURSH_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 16;
    let 'regsize = 32;
    execute_ALDURSH_R_RI_32(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURSH_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURSH_R_RI_64 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 'datasize == 16).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURSH_R_RI_64 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDURSH_R_RI_64 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURSH_R_RI_64 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 16;
    let 'regsize = 64;
    execute_ALDURSH_R_RI_64(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURSH_R_RI_64(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALDURSW_R_RI_64 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDURSW_R_RI_64 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDURSW_R_RI_64 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDURSW_R_RI_64 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 32;
    let 'regsize = 64;
    execute_ALDURSW_R_RI_64(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDURSW_R_RI_64(op1, V, imm9, op2, Rn, Rt)
}

val execute_ALIGND_C_CI_C : forall 'align 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'align & 'align <= 63).
  (int('align), int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALIGND_C_CI_C (align, d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let newvalue : bits(64) = CapGetValue(operand) & not_vec(ZeroExtend(Ones(align), 64));
    result : bits(129) = CapSetValue(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_ALIGND_C_CI_C : (bits(6), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALIGND_C_CI_C (imm6, U, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'align = UInt(imm6);
    execute_ALIGND_C_CI_C(align, d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm6 = Slice(__opcode, 15, 6);
    let U = Slice(__opcode, 14, 1);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_ALIGND_C_CI_C(imm6, U, Cn, Cd)
}

val execute_ALIGNU_C_CI_C : forall 'align 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'align & 'align <= 63).
  (int('align), int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALIGNU_C_CI_C (align, d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let m : bits(65) = ZeroExtend(Ones(align), 65);
    let newvalue : bits(65) = ZeroExtend(CapGetValue(operand), 65) + m & not_vec(m);
    result : bits(129) = CapSetValue(operand, newvalue[63 .. 0]);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_ALIGNU_C_CI_C : (bits(6), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALIGNU_C_CI_C (imm6, U, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'align = UInt(imm6);
    execute_ALIGNU_C_CI_C(align, d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm6 = Slice(__opcode, 15, 6);
    let U = Slice(__opcode, 14, 1);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_ALIGNU_C_CI_C(imm6, U, Cn, Cd)
}

val execute_ASTUR_C_RI_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_C_RI_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, AccType_NORMAL);
    MemC_set(addr, AccType_NORMAL) = data
}

val decode_ASTUR_C_RI_C : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_C_RI_C (op1, V, imm9, op2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    execute_ASTUR_C_RI_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_ASTUR_C_RI_C(op1, V, imm9, op2, Rn, Ct)
}

val execute_ASTUR_R_RI_32 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_R_RI_32 (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 32;
    regsize = 32;
    execute_ASTUR_R_RI_32(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTUR_R_RI_64 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 64).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_R_RI_64 (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_R_RI_64 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_R_RI_64 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 64;
    regsize = 64;
    execute_ASTUR_R_RI_64(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_R_RI_64(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTUR_V_RI_B : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_V_RI_B (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_V_RI_B : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_V_RI_B (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 8;
    execute_ASTUR_V_RI_B(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_V_RI_B(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTUR_V_RI_D : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 64).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_V_RI_D (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_V_RI_D : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_V_RI_D (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 64;
    execute_ASTUR_V_RI_D(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_V_RI_D(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTUR_V_RI_H : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 16).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_V_RI_H (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_V_RI_H : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_V_RI_H (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 16;
    execute_ASTUR_V_RI_H(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_V_RI_H(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTUR_V_RI_Q : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 128).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_V_RI_Q (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_V_RI_Q : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_V_RI_Q (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 128;
    execute_ASTUR_V_RI_Q(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_V_RI_Q(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTUR_V_RI_S : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTUR_V_RI_S (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTUR_V_RI_S : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTUR_V_RI_S (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 32;
    execute_ASTUR_V_RI_S(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTUR_V_RI_S(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTURB_R_RI_32 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTURB_R_RI_32 (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTURB_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTURB_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 8;
    regsize = 32;
    execute_ASTURB_R_RI_32(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTURB_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_ASTURH_R_RI_32 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 16).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTURH_R_RI_32 (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTURH_R_RI_32 : (bits(2), bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTURH_R_RI_32 (op1, V, imm9, op2, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'datasize = 16;
    regsize = 32;
    execute_ASTURH_R_RI_32(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let op1 = Slice(__opcode, 22, 2);
    let V = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op2 = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTURH_R_RI_32(op1, V, imm9, op2, Rn, Rt)
}

val execute_BICFLGS_C_CI_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(8), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BICFLGS_C_CI_C (d, mask, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let oldvalue : bits(64) = CapGetValue(operand);
    let newflags : bits(8) = oldvalue[63 .. 56] & not_vec(mask);
    let newvalue : bits(64) = newflags @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_BICFLGS_C_CI_C : (bits(8), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BICFLGS_C_CI_C (imm8, Cn, Cd) = {
    let 'n = UInt(Cn);
    let 'd = UInt(Cd);
    let mask : bits(8) = imm8;
    execute_BICFLGS_C_CI_C(d, mask, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm8 = Slice(__opcode, 13, 8);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_BICFLGS_C_CI_C(imm8, Cn, Cd)
}

val execute_BICFLGS_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BICFLGS_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let mask : bits(64) = X_read(64, m);
    let oldvalue : bits(64) = CapGetValue(operand);
    let newflags : bits(8) = oldvalue[63 .. 56] & not_vec(mask[63 .. 56]);
    let newvalue : bits(64) = newflags @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_BICFLGS_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BICFLGS_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_BICFLGS_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_BICFLGS_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_BLR_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BLR_C_C (branch_type, n) = {
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    linkoffset : int = 4;
    if IsInC64() then {
        linkoffset = linkoffset + 1
    } else ();
    let 'linkoffset = linkoffset;
    link : bits(129) = CapAdd__1(PCC_read(), linkoffset);
    if [CCTLR_read__1()[7]] == 0b1 then {
        link = CapSetObjectType(link, CAP_SEAL_TYPE_RB)
    } else ();
    C_set(30) = link;
    BranchXToCapability(target, branch_type)
}

val decode_BLR_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BLR_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDCALL;
    execute_BLR_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BLR_C_C (opc, Cn);
    decode_BLR_C_C(opc, Cn)
}

val execute_BLRR_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BLRR_C_C (branch_type, n) = {
    if IsInRestricted() then {
        UndefinedFault()
    } else ();
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else {
        if [CCTLR_read__1()[7]] == 0b1 then {
            target = CapWithTagClear(target)
        } else ()
    };
    linkoffset : int = 4;
    if IsInC64() then {
        linkoffset = linkoffset + 1
    } else ();
    let 'linkoffset = linkoffset;
    link : bits(129) = CapAdd__1(PCC_read(), linkoffset);
    if [CCTLR_read__1()[7]] == 0b1 then {
        link = CapSetObjectType(link, CAP_SEAL_TYPE_RB)
    } else ();
    C_set(30) = link;
    BranchXToCapability(target, branch_type)
}

val decode_BLRR_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BLRR_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDCALL;
    execute_BLRR_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BLRR_C_C(opc, Cn);
    decode_BLRR_C_C(opc, Cn)
}

val execute_BLRS_C_C_C : forall 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (BranchType, int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BLRS_C_C_C (branch_type, m, n) = {
    CheckCapabilitiesEnabled();
    sealed_target : bits(129) = C_read(n);
    let sealed_data : bits(129) = C_read(m);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(sealed_target, CAP_PERM_EXECUTIVE)) then {
        sealed_target = CapWithTagClear(sealed_target)
    } else ();
    target : bits(129) = undefined;
    if ((((((((CapIsTagSet(sealed_target) & CapIsTagSet(sealed_data)) & CapIsSealed(sealed_target)) & CapIsSealed(sealed_data)) & UInt(CapGetObjectType(sealed_target)) > CAP_MAX_FIXED_SEAL_TYPE) & CapGetObjectType(sealed_target) == CapGetObjectType(sealed_data)) & CapCheckPermissions(sealed_target, CAP_PERM_BRANCH_SEALED_PAIR)) & CapCheckPermissions(sealed_data, CAP_PERM_BRANCH_SEALED_PAIR)) & CapCheckPermissions(sealed_target, CAP_PERM_EXECUTE)) & not_bool(CapCheckPermissions(sealed_data, CAP_PERM_EXECUTE)) then {
        target = CapUnseal(sealed_target);
        C_set(29) = CapUnseal(sealed_data)
    } else {
        target = CapWithTagClear(sealed_target);
        C_set(29) = sealed_data
    };
    linkoffset : int = 4;
    if IsInC64() then {
        linkoffset = linkoffset + 1
    } else ();
    let 'linkoffset = linkoffset;
    link : bits(129) = CapAdd__1(PCC_read(), linkoffset);
    if [CCTLR_read__1()[7]] == 0b1 then {
        link = CapSetObjectType(link, CAP_SEAL_TYPE_RB)
    } else ();
    C_set(30) = link;
    BranchXToCapability(target, branch_type)
}

val decode_BLRS_C_C_C : (bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BLRS_C_C_C (Cm, opc, Cn) = {
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    let branch_type : BranchType = BranchType_INDCALL;
    execute_BLRS_C_C_C(branch_type, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BLRS_C_C_C (Cm, opc, Cn);
    decode_BLRS_C_C_C(Cm, opc, Cn)
}

val execute_BR_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BR_C_C (branch_type, n) = {
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    BranchXToCapability(target, branch_type)
}

val decode_BR_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BR_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDIR;
    execute_BR_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BR_C_C (opc, Cn);
    decode_BR_C_C(opc, Cn)
}

val execute_BRR_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BRR_C_C (branch_type, n) = {
    if IsInRestricted() then {
        UndefinedFault()
    } else ();
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else {
        if [CCTLR_read__1()[7]] == 0b1 then {
            target = CapWithTagClear(target)
        } else ()
    };
    BranchXToCapability(target, branch_type)
}

val decode_BRR_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BRR_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDIR;
    execute_BRR_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BRR_C_C (opc, Cn);
    decode_BRR_C_C(opc, Cn)
}

val execute_BRS_C_C_C : forall 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (BranchType, int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BRS_C_C_C (branch_type, m, n) = {
    CheckCapabilitiesEnabled();
    sealed_target : bits(129) = C_read(n);
    let sealed_data : bits(129) = C_read(m);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(sealed_target, CAP_PERM_EXECUTIVE)) then {
        sealed_target = CapWithTagClear(sealed_target)
    } else ();
    target : bits(129) = undefined;
    if ((((((((CapIsTagSet(sealed_target) & CapIsTagSet(sealed_data)) & CapIsSealed(sealed_target)) & CapIsSealed(sealed_data)) & UInt(CapGetObjectType(sealed_target)) > CAP_MAX_FIXED_SEAL_TYPE) & CapGetObjectType(sealed_target) == CapGetObjectType(sealed_data)) & CapCheckPermissions(sealed_target, CAP_PERM_BRANCH_SEALED_PAIR)) & CapCheckPermissions(sealed_data, CAP_PERM_BRANCH_SEALED_PAIR)) & CapCheckPermissions(sealed_target, CAP_PERM_EXECUTE)) & not_bool(CapCheckPermissions(sealed_data, CAP_PERM_EXECUTE)) then {
        target = CapUnseal(sealed_target);
        C_set(29) = CapUnseal(sealed_data)
    } else {
        target = CapWithTagClear(sealed_target);
        C_set(29) = sealed_data
    };
    BranchXToCapability(target, branch_type)
}

val decode_BRS_C_C_C : (bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BRS_C_C_C (Cm, opc, Cn) = {
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    let branch_type : BranchType = BranchType_INDIR;
    execute_BRS_C_C_C(branch_type, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BRS_C_C_C(Cm, opc, Cn);
    decode_BRS_C_C_C(Cm, opc, Cn)
}

val execute_CAS_C_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_CAS_C_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    data : bits(129) = undefined;
    let comparecap : bits(129) = C_read(s);
    let newcap : bits(129) = C_read(t);
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(newcap) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(newcap) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    C_set(s) = MemAtomicCompareAndSwapC(base, addr, comparecap, newcap, ldacctype, stacctype)
}

val decode_CAS_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CAS_C_R_C (L, Cs, R, Rn, Ct) = {
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = AccType_ATOMICRW;
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    execute_CAS_C_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 15, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_CAS_C_R_C (L, Cs, R, Rn, Ct);
    decode_CAS_C_R_C(L, Cs, R, Rn, Ct)
}

val execute_CASA_C_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_CASA_C_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    data : bits(129) = undefined;
    let comparecap : bits(129) = C_read(s);
    let newcap : bits(129) = C_read(t);
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(newcap) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(newcap) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    C_set(s) = MemAtomicCompareAndSwapC(base, addr, comparecap, newcap, ldacctype, stacctype)
}

val decode_CASA_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CASA_C_R_C (L, Cs, R, Rn, Ct) = {
    let ldacctype : AccType = AccType_ORDEREDATOMICRW;
    let stacctype : AccType = AccType_ATOMICRW;
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    execute_CASA_C_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 15, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_CASA_C_R_C (L, Cs, R, Rn, Ct);
    decode_CASA_C_R_C(L, Cs, R, Rn, Ct)
}

val execute_CASAL_C_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_CASAL_C_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    data : bits(129) = undefined;
    let comparecap : bits(129) = C_read(s);
    let newcap : bits(129) = C_read(t);
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(newcap) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(newcap) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    C_set(s) = MemAtomicCompareAndSwapC(base, addr, comparecap, newcap, ldacctype, stacctype)
}

val decode_CASAL_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CASAL_C_R_C (L, Cs, R, Rn, Ct) = {
    let ldacctype : AccType = AccType_ORDEREDATOMICRW;
    let stacctype : AccType = AccType_ORDEREDATOMICRW;
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    execute_CASAL_C_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 15, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_CASAL_C_R_C (L, Cs, R, Rn, Ct);
    decode_CASAL_C_R_C(L, Cs, R, Rn, Ct)
}

val execute_CASL_C_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_CASL_C_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    data : bits(129) = undefined;
    let comparecap : bits(129) = C_read(s);
    let newcap : bits(129) = C_read(t);
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(newcap) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(newcap) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    C_set(s) = MemAtomicCompareAndSwapC(base, addr, comparecap, newcap, ldacctype, stacctype)
}

val decode_CASL_C_R_C : (bits(1), bits(5), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CASL_C_R_C (L, Cs, R, Rn, Ct) = {
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = AccType_ORDEREDATOMICRW;
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    execute_CASL_C_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 15, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_CASL_C_R_C (L, Cs, R, Rn, Ct);
    decode_CASL_C_R_C(L, Cs, R, Rn, Ct)
}

val execute_BUILD_C_C_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BUILD_C_C_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    data : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let key : bits(129) = if m == 31 then CSP_read() else C_read(m);
    result : bits(129) = undefined;
    let dataWasSealed : bool = CapIsSealed(data);
    if dataWasSealed then {
        data = CapUnseal(data)
    } else ();
    if ((not_bool(CapIsTagSet(key)) | CapIsSealed(key)) | not_bool(CapIsSubSetOf(data, key))) | CapIsBaseAboveLimit(data) then {
        if dataWasSealed then {
            result = CapWithTagClear(data)
        } else {
            result = data
        }
    } else {
        result = CapWithTagSet(data)
    };
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_BUILD_C_C_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BUILD_C_C_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_BUILD_C_C_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_BUILD_C_C_C(Cm, opc, Cn, Cd)
}

val execute_CSEAL_C_C_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CSEAL_C_C_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let sealingcap : bits(129) = if m == 31 then CSP_read() else C_read(m);
    let otype : bits(64) = CapGetValue(sealingcap);
    result : bits(129) = operand1;
    if otype == CAP_NO_SEALING then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0001
    } else if (((((CapIsTagSet(operand1) & CapIsTagSet(sealingcap)) & not_bool(CapIsSealed(operand1))) & not_bool(CapIsSealed(sealingcap))) & CapCheckPermissions(sealingcap, CAP_PERM_SEAL)) & CapIsInBounds(sealingcap)) & UInt(otype) <= CAP_MAX_OBJECT_TYPE then {
        result = CapSetObjectType(operand1, otype);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0001
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    };
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_CSEAL_C_C_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CSEAL_C_C_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CSEAL_C_C_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CSEAL_C_C_C(Cm, opc, Cn, Cd)
}

val execute_CLRPERM_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CLRPERM_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let data : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let mask : bits(64) = X_read(64, m);
    result : bits(129) = CapClearPerms(data, mask);
    if CapIsSealed(data) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_CLRPERM_C_CR_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CLRPERM_C_CR_C (Rm, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_CLRPERM_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CLRPERM_C_CR_C(Rm, Cn, Cd)
}

val execute_CLRTAG_C_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CLRTAG_C_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let result : bits(129) = CapWithTagClear(operand);
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_CLRTAG_C_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CLRTAG_C_C_C (opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    execute_CLRTAG_C_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CLRTAG_C_C_C(opc, Cn, Cd)
}

val execute_CPY_C_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CPY_C_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let result : bits(129) = if n == 31 then CSP_read() else C_read(n);
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_CPY_C_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CPY_C_C_C (opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    execute_CPY_C_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CPY_C_C_C(opc, Cn, Cd)
}

val execute_SEAL_C_CI_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(64), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SEAL_C_CI_C (d, f, n) = {
    if f == 0 then {
        throw(Error_Undefined())
    } else ();
    CheckCapabilitiesEnabled();
    let operand : bits(129) = C_read(n);
    let result : bits(129) = CapSetObjectType(operand, f);
    if CapIsTagSet(operand) & not_bool(CapIsSealed(operand)) then {
        C_set(d) = result
    } else {
        C_set(d) = CapWithTagClear(result)
    }
}

val decode_SEAL_C_CI_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SEAL_C_CI_C (form, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let f : bits(64) = ZeroExtend(form, 64);
    execute_SEAL_C_CI_C(d, f, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let form = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SEAL_C_CI_C(form, Cn, Cd)
}

val execute_SEAL_C_CC_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SEAL_C_CC_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let auth : bits(129) = C_read(m);
    let operand : bits(129) = C_read(n);
    let otype : bits(64) = CapGetValue(auth);
    let result : bits(129) = CapSetObjectType(operand, otype);
    if (((((CapIsTagSet(operand) & CapIsTagSet(auth)) & not_bool(CapIsSealed(operand))) & not_bool(CapIsSealed(auth))) & CapCheckPermissions(auth, CAP_PERM_SEAL)) & CapIsInBounds(auth)) & UInt(otype) <= CAP_MAX_OBJECT_TYPE then {
        C_set(d) = result
    } else {
        C_set(d) = CapWithTagClear(result)
    }
}

val decode_SEAL_C_CC_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SEAL_C_CC_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_SEAL_C_CC_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SEAL_C_CC_C(Cm, opc, Cn, Cd)
}

val execute_CSEL_C_CI_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (bits(4), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CSEL_C_CI_C (cond, d, m, n) = {
    CheckCapabilitiesEnabled();
    result : bits(129) = undefined;
    if ConditionHolds(cond) then {
        result = C_read(n)
    } else {
        result = C_read(m)
    };
    C_set(d) = result
}

val decode_CSEL_C_CI_C : (bits(5), bits(4), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CSEL_C_CI_C (Cm, cond, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CSEL_C_CI_C(cond, d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let cond = Slice(__opcode, 12, 4);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CSEL_C_CI_C(Cm, cond, Cn, Cd)
}

val execute_UNSEAL_C_CC_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_UNSEAL_C_CC_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let auth : bits(129) = C_read(m);
    let operand : bits(129) = C_read(n);
    let value_name : bits(64) = CapGetValue(auth);
    let otype : bits(64) = CapGetObjectType(operand);
    c : bits(129) = CapUnseal(operand);
    if not_bool(CapCheckPermissions(auth, CAP_PERM_GLOBAL)) then {
        c = CapClearPerms(c, CAP_PERM_GLOBAL)
    } else ();
    if (((((CapIsTagSet(operand) & CapIsTagSet(auth)) & CapIsSealed(operand)) & not_bool(CapIsSealed(auth))) & CapCheckPermissions(auth, CAP_PERM_UNSEAL)) & CapIsInBounds(auth)) & otype == value_name then {
        C_set(d) = c
    } else {
        C_set(d) = CapWithTagClear(c)
    }
}

val decode_UNSEAL_C_CC_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_UNSEAL_C_CC_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_UNSEAL_C_CC_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_UNSEAL_C_CC_C(Cm, opc, Cn, Cd)
}

val execute_EORFLGS_C_CI_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(8), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_EORFLGS_C_CI_C (d, mask, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let oldvalue : bits(64) = CapGetValue(operand);
    let newflags : bits(8) = EOR(oldvalue[63 .. 56], mask);
    let newvalue : bits(64) = newflags @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_EORFLGS_C_CI_C : (bits(8), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_EORFLGS_C_CI_C (imm8, Cn, Cd) = {
    let 'n = UInt(Cn);
    let 'd = UInt(Cd);
    let mask : bits(8) = imm8;
    execute_EORFLGS_C_CI_C(d, mask, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm8 = Slice(__opcode, 13, 8);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_EORFLGS_C_CI_C(imm8, Cn, Cd)
}

val execute_EORFLGS_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_EORFLGS_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let mask : bits(64) = X_read(64, m);
    let oldvalue : bits(64) = CapGetValue(operand);
    let newflags : bits(8) = EOR(oldvalue[63 .. 56], mask[63 .. 56]);
    let newvalue : bits(64) = newflags @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_EORFLGS_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_EORFLGS_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_EORFLGS_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_EORFLGS_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_CFHI_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CFHI_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let result : bits(64) = operand[127 .. 64];
    X_set(64, d) = result
}

val decode_CFHI_R_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CFHI_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_CFHI_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_CFHI_R_C_C(opc, Cn, Rd)
}

val execute_GCBASE_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCBASE_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(CAP_BOUND_NUM_BITS) = undefined;
    let (__tup_0 : bits(CAP_BOUND_NUM_BITS), _, _) = CapGetBounds(operand) in
      {
          result = __tup_0
      };
    X_set(0 + (63 - 0 + 1), d) = result[63 .. 0]
}

val decode_GCBASE_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCBASE_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCBASE_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCBASE_R_C_C(opc, Cn, Rd)
}

val execute_GCVALUE_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCVALUE_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let result : bits(64) = CapGetValue(operand);
    X_set(64, d) = result
}

val decode_GCVALUE_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCVALUE_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCVALUE_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCVALUE_R_C_C(opc, Cn, Rd)
}

val execute_GCLEN_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCLEN_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(64) = undefined;
    let length : bits(65) = CapGetLength(operand);
    if [length[64]] == 0b1 then {
        result = Ones(64)
    } else {
        result = length[63 .. 0]
    };
    X_set(64, d) = result
}

val decode_GCLEN_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCLEN_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCLEN_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCLEN_R_C_C(opc, Cn, Rd)
}

val execute_GCLIM_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCLIM_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(64) = undefined;
    limit : bits(CAP_BOUND_NUM_BITS) = undefined;
    let (_, __tup_1 : bits(CAP_BOUND_NUM_BITS), _) = CapGetBounds(operand) in
      {
          limit = __tup_1
      };
    if [limit[64]] == 0b1 then {
        result = Ones(64)
    } else {
        result = limit[63 .. 0]
    };
    X_set(64, d) = result
}

val decode_GCLIM_R_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCLIM_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCLIM_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCLIM_R_C_C(opc, Cn, Rd)
}

val execute_GCOFF_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCOFF_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let result : bits(64) = CapGetOffset(operand);
    X_set(64, d) = result
}

val decode_GCOFF_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCOFF_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCOFF_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCOFF_R_C_C(opc, Cn, Rd)
}

val execute_GCPERM_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCPERM_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let result : bits(64) = ZeroExtend(CapGetPermissions(operand), 64);
    X_set(64, d) = result
}

val decode_GCPERM_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCPERM_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCPERM_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCPERM_R_C_C(opc, Cn, Rd)
}

val execute_GCSEAL_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCSEAL_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(64) = undefined;
    if CapIsSealed(operand) then {
        result = 1[63 .. 0]
    } else {
        result = 0[63 .. 0]
    };
    X_set(64, d) = result
}

val decode_GCSEAL_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCSEAL_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCSEAL_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCSEAL_R_C_C(opc, Cn, Rd)
}

val execute_GCTAG_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCTAG_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(64) = undefined;
    if CapIsTagSet(operand) then {
        result = 1[63 .. 0]
    } else {
        result = 0[63 .. 0]
    };
    X_set(64, d) = result
}

val decode_GCTAG_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCTAG_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCTAG_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCTAG_R_C_C(opc, Cn, Rd)
}

val execute_GCTYPE_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCTYPE_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let result : bits(64) = CapGetObjectType(operand);
    X_set(64, d) = result
}

val decode_GCTYPE_R_C_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCTYPE_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCTYPE_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCTYPE_R_C_C(opc, Cn, Rd)
}

val execute_GCFLGS_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_GCFLGS_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let value_name : bits(64) = CapGetValue(operand);
    let result : bits(64) = value_name[63 .. 56] @ Zeros(56);
    X_set(64, d) = result
}

val decode_GCFLGS_R_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_GCFLGS_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_GCFLGS_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_GCFLGS_R_C_C(opc, Cn, Rd)
}

val execute_CTHI_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CTHI_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    result : bits(129) = C_read(n);
    result[127 .. 64] = X_read(0 + (127 - 64 + 1), m);
    if d == 31 then {
        CSP_set() = CapWithTagClear(result)
    } else {
        C_set(d) = CapWithTagClear(result)
    }
}

val decode_CTHI_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CTHI_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_CTHI_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CTHI_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_LDAPR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDAPR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDAPR_C_R_C : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDAPR_C_R_C (Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDERED;
    execute_LDAPR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_LDAPR_C_R_C (Rn, Ct);
        decode_LDAPR_C_R_C(Rn, Ct)
    }
}

val execute_LDAR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDAR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDAR_C_R_C : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDAR_C_R_C (L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDERED;
    execute_LDAR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_LDAR_C_R_C (L, Rn, Ct);
        decode_LDAR_C_R_C(L, Rn, Ct)
    }
}

val execute_LDAXP_C_R_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDAXP_C_R_C (acctype, n, t, t2) = {
    CheckCapabilitiesEnabled();
    rt_unknown : bool = false;
    if t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, acctype);
    AArch64_SetExclusiveMonitors(addr, CAPABILITY_DBYTES * 2);
    if addr != Align(addr, CAPABILITY_DBYTES * 2) then {
        let iswrite : bool = false;
        let secondstage : bool = false;
        AArch64_Abort(addr, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    } else ();
    let data1 : bits(129) = MemC_read(addr, acctype);
    let data2 : bits(129) = MemC_read(addr + CAPABILITY_DBYTES, acctype);
    if rt_unknown then {
        C_set(t) = __UNKNOWN_bits(129);
        C_set(t2) = __UNKNOWN_bits(129)
    } else {
        C_set(t) = CapSquashPostLoadCap(data1, base);
        C_set(t2) = CapSquashPostLoadCap(data2, base)
    }
}

val decode_LDAXP_C_R_C : (bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDAXP_C_R_C (L, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDEREDATOMIC;
    execute_LDAXP_C_R_C(acctype, n, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_LDAXP_C_R_C (L, Ct2, Rn, Ct);
        decode_LDAXP_C_R_C(L, Ct2, Rn, Ct)
    }
}

val execute_LDAXR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDAXR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    AArch64_SetExclusiveMonitors(addr, CAPABILITY_DBYTES);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDAXR_C_R_C : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDAXR_C_R_C (L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDEREDATOMIC;
    execute_LDAXR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_LDAXR_C_R_C (L, Rn, Ct);
        decode_LDAXR_C_R_C(L, Rn, Ct)
    }
}

val execute_ALDAR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDAR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_ALDAR_C_R_C : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDAR_C_R_C (L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDERED;
    execute_ALDAR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_ALDAR_C_R_C (L, Rn, Ct);
        decode_ALDAR_C_R_C(L, Rn, Ct)
    }
}

val execute_ALDARB_R_R_B : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (AccType, int('datasize), int('n), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDARB_R_R_B (acctype, datasize, n, regsize, t) = {
    CheckCapabilitiesEnabled();
    address : VirtualAddress = undefined;
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), acctype);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDARB_R_R_B : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDARB_R_R_B (L, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'datasize = 8;
    let 'regsize = 32;
    let acctype : AccType = AccType_ORDERED;
    execute_ALDARB_R_R_B(acctype, datasize, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ALDARB_R_R_B(L, Rn, Rt)
    }
}

val execute_ALDAR_R_R_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (AccType, int('datasize), int('n), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDAR_R_R_32 (acctype, datasize, n, regsize, t) = {
    CheckCapabilitiesEnabled();
    address : VirtualAddress = undefined;
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), acctype);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDAR_R_R_32 : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDAR_R_R_32 (L, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'datasize = 32;
    let 'regsize = 32;
    let acctype : AccType = AccType_ORDERED;
    execute_ALDAR_R_R_32(acctype, datasize, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ALDAR_R_R_32(L, Rn, Rt)
    }
}

val execute_LDNP_C_RIB_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDNP_C_RIB_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    rt_unknown : bool = false;
    if t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, acctype);
    let data1 : bits(129) = MemC_read(addr, acctype);
    let data2 : bits(129) = MemC_read(addr + CAPABILITY_DBYTES, acctype);
    if rt_unknown then {
        C_set(t) = __UNKNOWN_bits(129);
        C_set(t2) = __UNKNOWN_bits(129)
    } else {
        C_set(t) = CapSquashPostLoadCap(data1, base);
        C_set(t2) = CapSquashPostLoadCap(data2, base)
    }
}

val decode_LDNP_C_RIB_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDNP_C_RIB_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_STREAM;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_LDNP_C_RIB_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDNP_C_RIB_C (L, imm7, Ct2, Rn, Ct);
    decode_LDNP_C_RIB_C(L, imm7, Ct2, Rn, Ct)
}

val execute_LDP_C_RIB_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDP_C_RIB_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    rt_unknown : bool = false;
    if t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, acctype);
    let data1 : bits(129) = MemC_read(addr, acctype);
    let data2 : bits(129) = MemC_read(addr + CAPABILITY_DBYTES, acctype);
    if rt_unknown then {
        C_set(t) = __UNKNOWN_bits(129);
        C_set(t2) = __UNKNOWN_bits(129)
    } else {
        C_set(t) = CapSquashPostLoadCap(data1, base);
        C_set(t2) = CapSquashPostLoadCap(data2, base)
    }
}

val decode_LDP_C_RIB_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDP_C_RIB_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_NORMAL;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_LDP_C_RIB_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDP_C_RIB_C (L, imm7, Ct2, Rn, Ct);
    decode_LDP_C_RIB_C(L, imm7, Ct2, Rn, Ct)
}

val execute_LDP_C_RIBW_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDP_C_RIBW_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    rt_unknown : bool = false;
    if t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    wback : bool = true;
    wb_unknown : bool = false;
    if (t == n | t2 == n) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, acctype);
    let data1 : bits(129) = MemC_read(addr, acctype);
    let data2 : bits(129) = MemC_read(addr + CAPABILITY_DBYTES, acctype);
    if rt_unknown then {
        C_set(t) = __UNKNOWN_bits(129);
        C_set(t2) = __UNKNOWN_bits(129)
    } else {
        C_set(t) = CapSquashPostLoadCap(data1, base);
        C_set(t2) = CapSquashPostLoadCap(data2, base)
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_LDP_C_RIBW_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDP_C_RIBW_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_NORMAL;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_LDP_C_RIBW_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDP_C_RIBW_C (L, imm7, Ct2, Rn, Ct);
    decode_LDP_C_RIBW_C(L, imm7, Ct2, Rn, Ct)
}

val execute_LDP_CC_RIAW_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDP_CC_RIAW_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    rt_unknown : bool = false;
    if t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    wback : bool = true;
    wb_unknown : bool = false;
    if (t == n | t2 == n) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, acctype);
    let data1 : bits(129) = MemC_read(addr, acctype);
    let data2 : bits(129) = MemC_read(addr + CAPABILITY_DBYTES, acctype);
    if rt_unknown then {
        C_set(t) = __UNKNOWN_bits(129);
        C_set(t2) = __UNKNOWN_bits(129)
    } else {
        C_set(t) = CapSquashPostLoadCap(data1, base);
        C_set(t2) = CapSquashPostLoadCap(data2, base)
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_LDP_CC_RIAW_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDP_CC_RIAW_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_NORMAL;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_LDP_CC_RIAW_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDP_CC_RIAW_C (L, imm7, Ct2, Rn, Ct);
    decode_LDP_CC_RIAW_C(L, imm7, Ct2, Rn, Ct)
}

val execute_LDPBLR_C_C_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (BranchType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDPBLR_C_C_C (branch_type, n, t) = {
    CheckCapabilitiesEnabled();
    base : bits(129) = undefined;
    data : bits(129) = undefined;
    target : bits(129) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        base = CSP_read()
    } else {
        base = C_read(n)
    };
    wb_unknown : bool = false;
    linkoffset : int = 4;
    if IsInC64() then {
        linkoffset = linkoffset + 1
    } else ();
    let 'linkoffset = linkoffset;
    link : bits(129) = CapAdd__1(PCC_read(), linkoffset);
    if [CCTLR_read__1()[7]] == 0b1 then {
        link = CapSetObjectType(link, CAP_SEAL_TYPE_RB)
    } else ();
    if t == 30 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LINKTRANSFEROVERLAPLD);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if t == 29 then {
        if (CapIsTagSet(base) & CapIsSealed(base)) & CapGetObjectType(base) == CAP_SEAL_TYPE_LPB then {
            base = CapUnseal(base)
        } else ();
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase);
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, AccType_NORMAL);
        data : bits(129) = MemC_read(addr, AccType_NORMAL);
        target = MemC_read(addr + CAPABILITY_DBYTES, AccType_NORMAL);
        let data : bits(129) = CapSquashPostLoadCap(data, vabase);
        target = CapSquashPostLoadCap(target, vabase);
        C_set(30) = link;
        C_set(29) = data
    } else {
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase);
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, AccType_NORMAL);
        data : bits(129) = MemC_read(addr, AccType_NORMAL);
        target = MemC_read(addr + CAPABILITY_DBYTES, AccType_NORMAL);
        let data : bits(129) = CapSquashPostLoadCap(data, vabase);
        target = CapSquashPostLoadCap(target, vabase);
        if wb_unknown then {
            C_set(30) = __UNKNOWN_bits(129);
            C_set(t) = __UNKNOWN_bits(129)
        } else {
            C_set(30) = link;
            C_set(t) = data
        }
    };
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    let target = target;
    BranchXToCapability(target, branch_type)
}

val decode_LDPBLR_C_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDPBLR_C_C_C (opc, Cn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDCALL;
    execute_LDPBLR_C_C_C(branch_type, n, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDPBLR_C_C_C (opc, Cn, Ct);
    decode_LDPBLR_C_C_C(opc, Cn, Ct)
}

val execute_LDPBR_C_C_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (BranchType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDPBR_C_C_C (branch_type, n, t) = {
    CheckCapabilitiesEnabled();
    base : bits(129) = undefined;
    data : bits(129) = undefined;
    target : bits(129) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        base = CSP_read()
    } else {
        base = C_read(n)
    };
    if t == 29 then {
        if (CapIsTagSet(base) & CapIsSealed(base)) & CapGetObjectType(base) == CAP_SEAL_TYPE_LPB then {
            base = CapUnseal(base)
        } else ();
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase);
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, AccType_NORMAL);
        data : bits(129) = MemC_read(addr, AccType_NORMAL);
        target = MemC_read(addr + CAPABILITY_DBYTES, AccType_NORMAL);
        let data : bits(129) = CapSquashPostLoadCap(data, vabase);
        target = CapSquashPostLoadCap(target, vabase);
        C_set(29) = data
    } else {
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase);
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, AccType_NORMAL);
        data : bits(129) = MemC_read(addr, AccType_NORMAL);
        target = MemC_read(addr + CAPABILITY_DBYTES, AccType_NORMAL);
        let data : bits(129) = CapSquashPostLoadCap(data, vabase);
        target = CapSquashPostLoadCap(target, vabase);
        C_set(t) = data
    };
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    let target = target;
    BranchXToCapability(target, branch_type)
}

val decode_LDPBR_C_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDPBR_C_C_C (opc, Cn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDIR;
    execute_LDPBR_C_C_C(branch_type, n, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDPBR_C_C_C (opc, Cn, Ct);
    decode_LDPBR_C_C_C(opc, Cn, Ct)
}

val execute_LDR_C_I_C : forall ('t : Int), (0 <= 't & 't <= 31).
  (bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDR_C_I_C (offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = VAFromCapability(PCC);
    let address : bits(64) = Align(VAddress(base) + offset, CAPABILITY_DBYTES);
    VACheckAddress(base, address, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
    data : bits(129) = MemC_read(address, AccType_NORMAL);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDR_C_I_C : (bits(17), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDR_C_I_C (imm17, Ct) = {
    let 't = UInt(Ct);
    let offset : bits(64) = SignExtend(imm17 @ 0b0000, 64);
    execute_LDR_C_I_C(offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm17 = Slice(__opcode, 5, 17);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDR_C_I_C (imm17, Ct);
    decode_LDR_C_I_C(imm17, Ct)
}

val execute_LDR_C_RIAW_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDR_C_RIAW_C (n, offset, t) = {
    c : Constraint = undefined;
    CheckCapabilitiesEnabled();
    let acctype : AccType = AccType_NORMAL;
    wback : bool = true;
    wb_unknown : bool = false;
    if n == t & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data;
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_LDR_C_RIAW_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDR_C_RIAW_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9 @ 0b0000, 64);
    execute_LDR_C_RIAW_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDR_C_RIAW_C (opc, imm9, Rn, Ct);
    decode_LDR_C_RIAW_C(opc, imm9, Rn, Ct)
}

val execute_LDR_C_RUIB_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDR_C_RUIB_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let acctype : AccType = AccType_NORMAL;
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDR_C_RUIB_C : (bits(1), bits(12), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDR_C_RUIB_C (L, imm12, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm12 @ 0b0000, 64);
    execute_LDR_C_RUIB_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm12 = Slice(__opcode, 10, 12);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDR_C_RUIB_C (L, imm12, Rn, Ct);
    decode_LDR_C_RUIB_C(L, imm12, Rn, Ct)
}

val execute_LDR_C_RIBW_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDR_C_RIBW_C (n, offset, t) = {
    c : Constraint = undefined;
    CheckCapabilitiesEnabled();
    let acctype : AccType = AccType_NORMAL;
    wback : bool = true;
    wb_unknown : bool = false;
    if n == t & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data;
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_LDR_C_RIBW_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDR_C_RIBW_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9 @ 0b0000, 64);
    execute_LDR_C_RIBW_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDR_C_RIBW_C (opc, imm9, Rn, Ct);
    decode_LDR_C_RIBW_C(opc, imm9, Rn, Ct)
}

val execute_LDR_C_RRB_C : forall 'm 'n 'shift 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDR_C_RRB_C (extend_type, m, n, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
    data : bits(129) = MemC_read(addr, AccType_NORMAL);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDR_C_RRB_C : (bits(2), bits(5), bits(1), bits(1), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDR_C_RRB_C (opc, Rm, sign, sz, S, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = LOG2_CAPABILITY_DBYTES;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_LDR_C_RRB_C(extend_type, m, n, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDR_C_RRB_C (opc, Rm, sign, sz, S, Rn, Ct);
    decode_LDR_C_RRB_C(opc, Rm, sign, sz, S, Rn, Ct)
}

val execute_LDCT_R_R__ : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDCT_R_R__ (n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let 'count = 4;
    addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES * count, CAP_PERM_LOAD, AccType_NORMAL);
    data : bits(64) = Zeros(64);
    if addr != Align(addr, CAPABILITY_DBYTES * count) then {
        let iswrite : bool = false;
        let secondstage : bool = false;
        AArch64_Abort(addr, AArch64_AlignmentFault(AccType_NORMAL, iswrite, secondstage))
    } else ();
    foreach (i from 0 to (count - 1) by 1 in inc) {
        let tag : bits(1) = AArch64_CapabilityTag(addr, AccType_NORMAL);
        data[i] = Bit(tag);
        addr = addr + CAPABILITY_DBYTES
    };
    if not_bool(VACheckPerm(base, CAP_PERM_LOAD_CAP)) then {
        data = Zeros(64)
    } else ();
    X_set(64, t) = data
}

val decode_LDCT_R_R__ : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDCT_R_R__ (opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    execute_LDCT_R_R__(n, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDCT_R_R__ (opc, Rn, Rt);
    decode_LDCT_R_R__(opc, Rn, Rt)
}

val execute_LDTR_C_RIB_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDTR_C_RIB_C (n, offset, t) = {
    acctype : AccType = undefined;
    CheckCapabilitiesEnabled();
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDTR_C_RIB_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDTR_C_RIB_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9 @ 0b0000, 64);
    execute_LDTR_C_RIB_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDTR_C_RIB_C (opc, imm9, Rn, Ct);
    decode_LDTR_C_RIB_C(opc, imm9, Rn, Ct)
}

val execute_LDUR_C_RI_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDUR_C_RI_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let acctype : AccType = AccType_NORMAL;
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDUR_C_RI_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDUR_C_RI_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    execute_LDUR_C_RI_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_LDUR_C_RI_C (opc, imm9, Rn, Ct);
    decode_LDUR_C_RI_C(opc, imm9, Rn, Ct)
}

val execute_LDXP_C_R_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDXP_C_R_C (acctype, n, t, t2) = {
    CheckCapabilitiesEnabled();
    rt_unknown : bool = false;
    if t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES * 2, CAP_PERM_LOAD, acctype);
    AArch64_SetExclusiveMonitors(addr, CAPABILITY_DBYTES * 2);
    if addr != Align(addr, CAPABILITY_DBYTES * 2) then {
        let iswrite : bool = false;
        let secondstage : bool = false;
        AArch64_Abort(addr, AArch64_AlignmentFault(acctype, iswrite, secondstage))
    } else ();
    let data1 : bits(129) = MemC_read(addr, acctype);
    let data2 : bits(129) = MemC_read(addr + CAPABILITY_DBYTES, acctype);
    if rt_unknown then {
        C_set(t) = __UNKNOWN_bits(129);
        C_set(t2) = __UNKNOWN_bits(129)
    } else {
        C_set(t) = CapSquashPostLoadCap(data1, base);
        C_set(t2) = CapSquashPostLoadCap(data2, base)
    }
}

val decode_LDXP_C_R_C : (bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDXP_C_R_C (L, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ATOMIC;
    execute_LDXP_C_R_C(acctype, n, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_LDXP_C_R_C (L, Ct2, Rn, Ct);
        decode_LDXP_C_R_C(L, Ct2, Rn, Ct)
    }
}

val execute_LDXR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_LDXR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, acctype);
    AArch64_SetExclusiveMonitors(addr, CAPABILITY_DBYTES);
    data : bits(129) = MemC_read(addr, acctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_LDXR_C_R_C : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_LDXR_C_R_C (L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ATOMIC;
    execute_LDXR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        __ThisInstrAbstract = Instr_LDXR_C_R_C (L, Rn, Ct);
        decode_LDXR_C_R_C(L, Rn, Ct)
    }
}

val execute_MRS_C_I_C : forall 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  (0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 in {2, 3} & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_MRS_C_I_C (sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    CheckCapabilitiesEnabled();
    C_set(t) = AArch64_CapSysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
}

val decode_MRS_C_I_C : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(3), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_MRS_C_I_C (L, o0, op1, CRn, CRm, op2, Ct) = {
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let 'sys_op2 = UInt(op2);
    let 't = UInt(Ct);
    execute_MRS_C_I_C(sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 20, 1);
    let o0 = Slice(__opcode, 19, 1);
    let op1 = Slice(__opcode, 16, 3);
    let CRn = Slice(__opcode, 12, 4);
    let CRm = Slice(__opcode, 8, 4);
    let op2 = Slice(__opcode, 5, 3);
    let Ct = Slice(__opcode, 0, 5);
    decode_MRS_C_I_C(L, o0, op1, CRn, CRm, op2, Ct)
}

val execute_MSR_C_I_C : forall 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  (0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 in {2, 3} & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_MSR_C_I_C (sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    CheckCapabilitiesEnabled();
    AArch64_CapSysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, C_read(t))
}

val decode_MSR_C_I_C : (bits(1), bits(1), bits(3), bits(4), bits(4), bits(3), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_MSR_C_I_C (L, o0, op1, CRn, CRm, op2, Ct) = {
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let 'sys_op2 = UInt(op2);
    let 't = UInt(Ct);
    execute_MSR_C_I_C(sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 20, 1);
    let o0 = Slice(__opcode, 19, 1);
    let op1 = Slice(__opcode, 16, 3);
    let CRn = Slice(__opcode, 12, 4);
    let CRm = Slice(__opcode, 8, 4);
    let op2 = Slice(__opcode, 5, 3);
    let Ct = Slice(__opcode, 0, 5);
    decode_MSR_C_I_C(L, o0, op1, CRn, CRm, op2, Ct)
}

val execute_ORRFLGS_C_CI_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(8), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_ORRFLGS_C_CI_C (d, mask, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let oldvalue : bits(64) = CapGetValue(operand);
    let newflags : bits(8) = oldvalue[63 .. 56] | mask;
    let newvalue : bits(64) = newflags @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_ORRFLGS_C_CI_C : (bits(8), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ORRFLGS_C_CI_C (imm8, Cn, Cd) = {
    let 'n = UInt(Cn);
    let 'd = UInt(Cd);
    let mask : bits(8) = imm8;
    execute_ORRFLGS_C_CI_C(d, mask, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm8 = Slice(__opcode, 13, 8);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_ORRFLGS_C_CI_C(imm8, Cn, Cd)
}

val execute_ORRFLGS_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_ORRFLGS_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let mask : bits(64) = X_read(64, m);
    let oldvalue : bits(64) = CapGetValue(operand);
    let newflags : bits(8) = oldvalue[63 .. 56] | mask[63 .. 56];
    let newvalue : bits(64) = newflags @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand, newvalue);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_ORRFLGS_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ORRFLGS_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_ORRFLGS_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_ORRFLGS_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_RET_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_RET_C_C (branch_type, n) = {
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    BranchXToCapability(target, branch_type)
}

val decode_RET_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_RET_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_RET;
    execute_RET_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_RET_C_C (opc, Cn);
    decode_RET_C_C(opc, Cn)
}

val execute_RETR_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_RETR_C_C (branch_type, n) = {
    if IsInRestricted() then {
        UndefinedFault()
    } else ();
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else {
        if [CCTLR_read__1()[7]] == 0b1 then {
            target = CapWithTagClear(target)
        } else ()
    };
    BranchXToCapability(target, branch_type)
}

val decode_RETR_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_RETR_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_RET;
    execute_RETR_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_RETR_C_C (opc, Cn);
    decode_RETR_C_C(opc, Cn)
}

val execute_RETS_C_C_C : forall 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (BranchType, int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_RETS_C_C_C (branch_type, m, n) = {
    CheckCapabilitiesEnabled();
    sealed_target : bits(129) = C_read(n);
    let sealed_data : bits(129) = C_read(m);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(sealed_target, CAP_PERM_EXECUTIVE)) then {
        sealed_target = CapWithTagClear(sealed_target)
    } else ();
    target : bits(129) = undefined;
    if ((((((((CapIsTagSet(sealed_target) & CapIsTagSet(sealed_data)) & CapIsSealed(sealed_target)) & CapIsSealed(sealed_data)) & UInt(CapGetObjectType(sealed_target)) > CAP_MAX_FIXED_SEAL_TYPE) & CapGetObjectType(sealed_target) == CapGetObjectType(sealed_data)) & CapCheckPermissions(sealed_target, CAP_PERM_BRANCH_SEALED_PAIR)) & CapCheckPermissions(sealed_data, CAP_PERM_BRANCH_SEALED_PAIR)) & CapCheckPermissions(sealed_target, CAP_PERM_EXECUTE)) & not_bool(CapCheckPermissions(sealed_data, CAP_PERM_EXECUTE)) then {
        target = CapUnseal(sealed_target);
        C_set(29) = CapUnseal(sealed_data)
    } else {
        target = CapWithTagClear(sealed_target);
        C_set(29) = sealed_data
    };
    BranchXToCapability(target, branch_type)
}

val decode_RETS_C_C_C : (bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_RETS_C_C_C (Cm, opc, Cn) = {
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    let branch_type : BranchType = BranchType_RET;
    execute_RETS_C_C_C(branch_type, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_RETS_C_C_C (Cm, opc, Cn);
    decode_RETS_C_C_C(Cm, opc, Cn)
}

val execute_RRLEN_R_R_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_RRLEN_R_R_C (d, n) = {
    CheckCapabilitiesEnabled();
    let request : bits(64) = X_read(64, n);
    let mask : bits(64) = CapGetRepresentableMask(request);
    X_set(64, d) = request + not_vec(mask) & mask
}

val decode_RRLEN_R_R_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_RRLEN_R_R_C (opc, Rn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    execute_RRLEN_R_R_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_RRLEN_R_R_C(opc, Rn, Rd)
}

val execute_RRMASK_R_R_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_RRMASK_R_R_C (d, n) = {
    CheckCapabilitiesEnabled();
    let request : bits(64) = X_read(64, n);
    let mask : bits(64) = CapGetRepresentableMask(request);
    X_set(64, d) = mask
}

val decode_RRMASK_R_R_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_RRMASK_R_R_C (opc, Rn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    execute_RRMASK_R_R_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_RRMASK_R_R_C(opc, Rn, Rd)
}

val execute_SCBNDS_C_CI_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(65), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCBNDS_C_CI_C (d, length, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(129) = CapSetBounds(operand, length, true);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCBNDS_C_CI_C : (bits(6), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCBNDS_C_CI_C (imm6, S, Cn, Cd) = {
    let 'n = UInt(Cn);
    let 'd = UInt(Cd);
    let length : bits(65) = if S == 0b1 then ZeroExtend(imm6 @ 0b0000, 65) else ZeroExtend(imm6, 65);
    execute_SCBNDS_C_CI_C(d, length, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm6 = Slice(__opcode, 15, 6);
    let S = Slice(__opcode, 14, 1);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCBNDS_C_CI_C(imm6, S, Cn, Cd)
}

val execute_SCBNDS_C_CI_S : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(65), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCBNDS_C_CI_S (d, length, n) = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    result : bits(129) = CapSetBounds(operand, length, true);
    if CapIsSealed(operand) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCBNDS_C_CI_S : (bits(6), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCBNDS_C_CI_S (imm6, S, Cn, Cd) = {
    let 'n = UInt(Cn);
    let 'd = UInt(Cd);
    let length : bits(65) = if S == 0b1 then ZeroExtend(imm6 @ 0b0000, 65) else ZeroExtend(imm6, 65);
    execute_SCBNDS_C_CI_S(d, length, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm6 = Slice(__opcode, 15, 6);
    let S = Slice(__opcode, 14, 1);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCBNDS_C_CI_S(imm6, S, Cn, Cd)
}

val execute_SCBNDS_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCBNDS_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let xm : bits(64) = X_read(64, m);
    let length : bits(65) = ZeroExtend(xm, 65);
    result : bits(129) = CapSetBounds(operand1, length, false);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCBNDS_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCBNDS_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_SCBNDS_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCBNDS_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_SCBNDSE_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCBNDSE_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let xm : bits(64) = X_read(64, m);
    let length : bits(65) = ZeroExtend(xm, 65);
    result : bits(129) = CapSetBounds(operand1, length, true);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCBNDSE_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCBNDSE_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_SCBNDSE_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCBNDSE_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_SCVALUE_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCVALUE_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let newvalue : bits(64) = X_read(64, m);
    result : bits(129) = CapSetValue(operand1, newvalue);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCVALUE_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCVALUE_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_SCVALUE_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCVALUE_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_SCOFF_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCOFF_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let newoffset : bits(64) = X_read(64, m);
    result : bits(129) = CapSetOffset(operand1, newoffset);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCOFF_C_CR_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCOFF_C_CR_C (Rm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_SCOFF_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCOFF_C_CR_C(Rm, opc, Cn, Cd)
}

val execute_SCTAG_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCTAG_C_CR_C (d, m, n) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    } else ();
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let newtag : bits(64) = X_read(64, m);
    result : bits(129) = undefined;
    if ([newtag[0]] == 0b1 & CapIsSystemAccessEnabled()) & not_bool(IsTagSettingDisabled()) then {
        result = CapWithTagSet(operand1)
    } else {
        result = CapWithTagClear(operand1)
    };
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCTAG_C_CR_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCTAG_C_CR_C (Rm, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_SCTAG_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCTAG_C_CR_C(Rm, Cn, Cd)
}

val execute_SCFLGS_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SCFLGS_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let newflags : bits(64) = X_read(64, m);
    let oldvalue : bits(64) = CapGetValue(operand1);
    let newvalue : bits(64) = newflags[63 .. 56] @ oldvalue[55 .. 0];
    result : bits(129) = CapSetFlags(operand1, newvalue);
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SCFLGS_C_CR_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SCFLGS_C_CR_C (Rm, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_SCFLGS_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SCFLGS_C_CR_C(Rm, Cn, Cd)
}

val execute_CPYTYPE_C_C_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CPYTYPE_C_C_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let key : bits(129) = C_read(n);
    let data : bits(129) = C_read(m);
    result : bits(129) = undefined;
    if CapIsSealed(data) then {
        result = CapSetValue(key, CapGetObjectType(data))
    } else {
        result = CapSetValue(key, CAP_NO_SEALING)
    };
    if CapIsSealed(key) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CPYTYPE_C_C_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CPYTYPE_C_C_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CPYTYPE_C_C_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CPYTYPE_C_C_C(Cm, opc, Cn, Cd)
}

val execute_CPYVALUE_C_C_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CPYVALUE_C_C_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = C_read(n);
    let operand2 : bits(129) = C_read(m);
    let result : bits(129) = CapSetValue(operand1, CapGetValue(operand2));
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CPYVALUE_C_C_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CPYVALUE_C_C_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CPYVALUE_C_C_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CPYVALUE_C_C_C(Cm, opc, Cn, Cd)
}

val execute_STLR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STLR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data
}

val decode_STLR_C_R_C : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STLR_C_R_C (L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDERED;
    execute_STLR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_STLR_C_R_C(L, Rn, Ct)
    }
}

val execute_STLXP_R_CR_C : forall 'n 's 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_STLXP_R_CR_C (acctype, n, s, t, t2) = {
    CheckCapabilitiesEnabled();
    base : VirtualAddress = undefined;
    data1 : bits(129) = undefined;
    data2 : bits(129) = undefined;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if s == t | s == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if s == n & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rn_unknown = true
          },
          Constraint_NONE => {
              rn_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if rt_unknown then {
        data1 = __UNKNOWN_bits(129);
        data2 = __UNKNOWN_bits(129)
    } else {
        data1 = C_read(t);
        data2 = C_read(t2)
    };
    if rn_unknown then {
        base = __UNKNOWN_VirtualAddress()
    } else {
        base = BaseReg_read__1(n)
    };
    cap_required1 : bits(64) = CAP_PERM_STORE;
    cap_required2 : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data1) then {
        cap_required1 = cap_required1 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data1) then {
            cap_required1 = cap_required1 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    if CapIsTagSet(data2) then {
        cap_required2 = cap_required2 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data2) then {
            cap_required2 = cap_required2 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required1, acctype);
    VACheckAddress(base, addr + CAPABILITY_DBYTES[63 .. 0], CAPABILITY_DBYTES, cap_required2, acctype);
    status : bits(1) = 0b1;
    if AArch64_ExclusiveMonitorsPass(addr, CAPABILITY_DBYTES * 2) then {
        MemCP__1(addr, acctype, data1, data2);
        status = ExclusiveMonitorsStatus()
    } else ();
    X_set(32, s) = ZeroExtend(status, 32)
}

val decode_STLXP_R_CR_C : (bits(1), bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STLXP_R_CR_C (L, Rs, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ORDEREDATOMIC;
    execute_STLXP_R_CR_C(acctype, n, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rs = Slice(__opcode, 16, 5);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STLXP_R_CR_C(L, Rs, Ct2, Rn, Ct)
}

val execute_STLXR_R_CR_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STLXR_R_CR_C (acctype, n, s, t) = {
    CheckCapabilitiesEnabled();
    base : VirtualAddress = undefined;
    data : bits(129) = undefined;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if s == t then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if s == n & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rn_unknown = true
          },
          Constraint_NONE => {
              rn_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if rn_unknown then {
        base = __UNKNOWN_VirtualAddress()
    } else {
        base = BaseReg_read__1(n)
    };
    if rt_unknown then {
        data = __UNKNOWN_bits(129)
    } else {
        data = C_read(t)
    };
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    status : bits(1) = 0b1;
    if AArch64_ExclusiveMonitorsPass(addr, CAPABILITY_DBYTES) then {
        MemC_set(addr, acctype) = data;
        status = ExclusiveMonitorsStatus()
    } else ();
    X_set(32, s) = ZeroExtend(status, 32)
}

val decode_STLXR_R_CR_C : (bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STLXR_R_CR_C (L, Rs, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ORDEREDATOMIC;
    execute_STLXR_R_CR_C(acctype, n, s, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rs = Slice(__opcode, 16, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_STLXR_R_CR_C(L, Rs, Rn, Ct)
    }
}

val execute_ASTLR_C_R_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTLR_C_R_C (acctype, n, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data
}

val decode_ASTLR_C_R_C : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTLR_C_R_C (L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_ORDERED;
    execute_ASTLR_C_R_C(acctype, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ASTLR_C_R_C(L, Rn, Ct)
    }
}

val execute_ASTLRB_R_R_B : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (AccType, int('datasize), int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTLRB_R_R_B (acctype, datasize, n, t) = {
    CheckCapabilitiesEnabled();
    address : VirtualAddress = undefined;
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let data : bits('datasize) = X_read(datasize, t);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, acctype);
    Mem_set(addr, DIV(datasize, 8), acctype) = data
}

val decode_ASTLRB_R_R_B : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTLRB_R_R_B (L, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'datasize = 8;
    regsize = 32;
    let acctype : AccType = AccType_ORDERED;
    execute_ASTLRB_R_R_B(acctype, datasize, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ASTLRB_R_R_B(L, Rn, Rt)
    }
}

val execute_ASTLR_R_R_32 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (AccType, int('datasize), int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTLR_R_R_32 (acctype, datasize, n, t) = {
    CheckCapabilitiesEnabled();
    address : VirtualAddress = undefined;
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let data : bits('datasize) = X_read(datasize, t);
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, acctype);
    Mem_set(addr, DIV(datasize, 8), acctype) = data
}

val decode_ASTLR_R_R_32 : (bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTLR_R_R_32 (L, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'datasize = 32;
    regsize = 32;
    let acctype : AccType = AccType_ORDERED;
    execute_ASTLR_R_R_32(acctype, datasize, n, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    if (((((((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1) | [__opcode[10]] != 0b1) | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ASTLR_R_R_32(L, Rn, Rt)
    }
}

val execute_STNP_C_RIB_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_STNP_C_RIB_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr1 : bits(64) = VAddress(base) + offset;
    let addr2 : bits(64) = addr1 + CAPABILITY_DBYTES[63 .. 0];
    let data1 : bits(129) = C_read(t);
    let data2 : bits(129) = C_read(t2);
    cap_required1 : bits(64) = CAP_PERM_STORE;
    cap_required2 : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data1) then {
        cap_required1 = cap_required1 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data1) then {
            cap_required1 = cap_required1 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    if CapIsTagSet(data2) then {
        cap_required2 = cap_required2 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data2) then {
            cap_required2 = cap_required2 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr1, CAPABILITY_DBYTES, cap_required1, acctype);
    MemC_set(addr1, acctype) = data1;
    VACheckAddress(base, addr2, CAPABILITY_DBYTES, cap_required2, acctype);
    MemC_set(addr2, acctype) = data2
}

val decode_STNP_C_RIB_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STNP_C_RIB_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_STREAM;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_STNP_C_RIB_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STNP_C_RIB_C(L, imm7, Ct2, Rn, Ct)
}

val execute_STP_C_RIB_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_STP_C_RIB_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr1 : bits(64) = VAddress(base) + offset;
    let addr2 : bits(64) = addr1 + CAPABILITY_DBYTES[63 .. 0];
    let data1 : bits(129) = C_read(t);
    let data2 : bits(129) = C_read(t2);
    cap_required1 : bits(64) = CAP_PERM_STORE;
    cap_required2 : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data1) then {
        cap_required1 = cap_required1 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data1) then {
            cap_required1 = cap_required1 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    if CapIsTagSet(data2) then {
        cap_required2 = cap_required2 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data2) then {
            cap_required2 = cap_required2 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr1, CAPABILITY_DBYTES, cap_required1, acctype);
    MemC_set(addr1, acctype) = data1;
    VACheckAddress(base, addr2, CAPABILITY_DBYTES, cap_required2, acctype);
    MemC_set(addr2, acctype) = data2
}

val decode_STP_C_RIB_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STP_C_RIB_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_NORMAL;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_STP_C_RIB_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STP_C_RIB_C(L, imm7, Ct2, Rn, Ct)
}

val execute_STP_C_RIBW_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_STP_C_RIBW_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    data1 : bits(129) = undefined;
    data2 : bits(129) = undefined;
    rt_unknown : bool = false;
    if (t == n | t2 == n) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr1 : bits(64) = VAddress(base) + offset;
    let addr2 : bits(64) = addr1 + CAPABILITY_DBYTES[63 .. 0];
    if rt_unknown & t == n then {
        data1 = __UNKNOWN_bits(129)
    } else {
        data1 = C_read(t)
    };
    if rt_unknown & t2 == n then {
        data2 = __UNKNOWN_bits(129)
    } else {
        data2 = C_read(t2)
    };
    cap_required1 : bits(64) = CAP_PERM_STORE;
    cap_required2 : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data1) then {
        cap_required1 = cap_required1 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data1) then {
            cap_required1 = cap_required1 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    if CapIsTagSet(data2) then {
        cap_required2 = cap_required2 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data2) then {
            cap_required2 = cap_required2 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr1, CAPABILITY_DBYTES, cap_required1, acctype);
    MemC_set(addr1, acctype) = data1;
    VACheckAddress(base, addr2, CAPABILITY_DBYTES, cap_required2, acctype);
    MemC_set(addr2, acctype) = data2;
    BaseReg_set(n) = VAAdd(base, offset)
}

val decode_STP_C_RIBW_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STP_C_RIBW_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_NORMAL;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_STP_C_RIBW_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STP_C_RIBW_C(L, imm7, Ct2, Rn, Ct)
}

val execute_STP_CC_RIAW_C : forall 'n 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), bits(64), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_STP_CC_RIAW_C (acctype, n, offset, t, t2) = {
    CheckCapabilitiesEnabled();
    data1 : bits(129) = undefined;
    data2 : bits(129) = undefined;
    rt_unknown : bool = false;
    if (t == n | t2 == n) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr1 : bits(64) = VAddress(base);
    let addr2 : bits(64) = addr1 + CAPABILITY_DBYTES[63 .. 0];
    if rt_unknown & t == n then {
        data1 = __UNKNOWN_bits(129)
    } else {
        data1 = C_read(t)
    };
    if rt_unknown & t2 == n then {
        data2 = __UNKNOWN_bits(129)
    } else {
        data2 = C_read(t2)
    };
    cap_required1 : bits(64) = CAP_PERM_STORE;
    cap_required2 : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data1) then {
        cap_required1 = cap_required1 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data1) then {
            cap_required1 = cap_required1 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    if CapIsTagSet(data2) then {
        cap_required2 = cap_required2 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data2) then {
            cap_required2 = cap_required2 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr1, CAPABILITY_DBYTES, cap_required1, acctype);
    MemC_set(addr1, acctype) = data1;
    VACheckAddress(base, addr2, CAPABILITY_DBYTES, cap_required2, acctype);
    MemC_set(addr2, acctype) = data2;
    BaseReg_set(n) = VAAdd(base, offset)
}

val decode_STP_CC_RIAW_C : (bits(1), bits(7), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STP_CC_RIAW_C (L, imm7, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let acctype : AccType = AccType_NORMAL;
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    execute_STP_CC_RIAW_C(acctype, n, offset, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm7 = Slice(__opcode, 15, 7);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STP_CC_RIAW_C(L, imm7, Ct2, Rn, Ct)
}

val execute_STR_C_RIAW_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STR_C_RIAW_C (n, offset, t) = {
    c : Constraint = undefined;
    CheckCapabilitiesEnabled();
    data : bits(129) = undefined;
    let acctype : AccType = AccType_NORMAL;
    rt_unknown : bool = false;
    if n == t & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    if rt_unknown then {
        data = __UNKNOWN_bits(129)
    } else {
        data = C_read(t)
    };
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data;
    BaseReg_set(n) = VAAdd(base, offset)
}

val decode_STR_C_RIAW_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STR_C_RIAW_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9 @ 0b0000, 64);
    execute_STR_C_RIAW_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STR_C_RIAW_C(opc, imm9, Rn, Ct)
}

val execute_STR_C_RUIB_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STR_C_RUIB_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let acctype : AccType = AccType_NORMAL;
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data
}

val decode_STR_C_RUIB_C : (bits(1), bits(12), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STR_C_RUIB_C (L, imm12, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm12 @ 0b0000, 64);
    execute_STR_C_RUIB_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let imm12 = Slice(__opcode, 10, 12);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STR_C_RUIB_C(L, imm12, Rn, Ct)
}

val execute_STR_C_RIBW_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STR_C_RIBW_C (n, offset, t) = {
    c : Constraint = undefined;
    CheckCapabilitiesEnabled();
    data : bits(129) = undefined;
    let acctype : AccType = AccType_NORMAL;
    rt_unknown : bool = false;
    if n == t & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    if rt_unknown then {
        data = __UNKNOWN_bits(129)
    } else {
        data = C_read(t)
    };
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data;
    BaseReg_set(n) = VAAdd(base, offset)
}

val decode_STR_C_RIBW_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STR_C_RIBW_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9 @ 0b0000, 64);
    execute_STR_C_RIBW_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STR_C_RIBW_C(opc, imm9, Rn, Ct)
}

val execute_STR_C_RRB_C : forall 'm 'n 'shift 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STR_C_RRB_C (extend_type, m, n, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = BaseReg_read__1(n);
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, AccType_NORMAL);
    MemC_set(addr, AccType_NORMAL) = data
}

val decode_STR_C_RRB_C : (bits(2), bits(5), bits(1), bits(1), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STR_C_RRB_C (opc, Rm, sign, sz, S, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = LOG2_CAPABILITY_DBYTES;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_STR_C_RRB_C(extend_type, m, n, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STR_C_RRB_C(opc, Rm, sign, sz, S, Rn, Ct)
}

val execute_STCT_R_R__ : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STCT_R_R__ (n, t) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    } else ();
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let 'count = 4;
    willabort : bool = false;
    iswrite : bool = undefined;
    secondstage : bool = undefined;
    let data : bits(64) = X_read(64, t);
    addr : bits(64) = VAddress(base);
    if addr != Align(addr, CAPABILITY_DBYTES * count) then {
        iswrite = true;
        secondstage = false;
        willabort = true
    } else ();
    let secondstage = secondstage;
    let iswrite = iswrite;
    foreach (i from 0 to (count - 1) by 1 in inc) {
        tag : bits(1) = undefined;
        if CapIsSystemAccessEnabled() & not_bool(IsTagSettingDisabled()) then {
            tag = [data[i]]
        } else {
            tag = 0b0
        };
        cap_required : bits(64) = CAP_PERM_STORE;
        if tag == 0b1 then {
            cap_required = cap_required | CAP_PERM_STORE_CAP
        } else ();
        VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, AccType_NORMAL);
        if willabort == true then {
            AArch64_Abort(addr, AArch64_AlignmentFault(AccType_NORMAL, iswrite, secondstage))
        } else ();
        AArch64_CapabilityTag_set(addr, AccType_NORMAL) = tag;
        addr = addr + CAPABILITY_DBYTES
    }
}

val decode_STCT_R_R__ : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STCT_R_R__ (opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    execute_STCT_R_R__(n, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_STCT_R_R__(opc, Rn, Rt)
}

val execute_STTR_C_RIB_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STTR_C_RIB_C (n, offset, t) = {
    acctype : AccType = undefined;
    CheckCapabilitiesEnabled();
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data
}

val decode_STTR_C_RIB_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STTR_C_RIB_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9 @ 0b0000, 64);
    execute_STTR_C_RIB_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STTR_C_RIB_C(opc, imm9, Rn, Ct)
}

val execute_STUR_C_RI_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STUR_C_RI_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let acctype : AccType = AccType_NORMAL;
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    MemC_set(addr, acctype) = data
}

val decode_STUR_C_RI_C : (bits(2), bits(9), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STUR_C_RI_C (opc, imm9, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = SignExtend(imm9, 64);
    execute_STUR_C_RI_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 22, 2);
    let imm9 = Slice(__opcode, 12, 9);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STUR_C_RI_C(opc, imm9, Rn, Ct)
}

val execute_STXP_R_CR_C : forall 'n 's 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_STXP_R_CR_C (acctype, n, s, t, t2) = {
    CheckCapabilitiesEnabled();
    base : VirtualAddress = undefined;
    data1 : bits(129) = undefined;
    data2 : bits(129) = undefined;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if s == t | s == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if s == n & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rn_unknown = true
          },
          Constraint_NONE => {
              rn_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if rt_unknown then {
        data1 = __UNKNOWN_bits(129);
        data2 = __UNKNOWN_bits(129)
    } else {
        data1 = C_read(t);
        data2 = C_read(t2)
    };
    if rn_unknown then {
        base = __UNKNOWN_VirtualAddress()
    } else {
        base = BaseReg_read__1(n)
    };
    cap_required1 : bits(64) = CAP_PERM_STORE;
    cap_required2 : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data1) then {
        cap_required1 = cap_required1 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data1) then {
            cap_required1 = cap_required1 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    if CapIsTagSet(data2) then {
        cap_required2 = cap_required2 | CAP_PERM_STORE_CAP;
        if CapIsLocal(data2) then {
            cap_required2 = cap_required2 | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required1, acctype);
    VACheckAddress(base, addr + CAPABILITY_DBYTES[63 .. 0], CAPABILITY_DBYTES, cap_required2, acctype);
    status : bits(1) = 0b1;
    if AArch64_ExclusiveMonitorsPass(addr, CAPABILITY_DBYTES * 2) then {
        MemCP__1(addr, acctype, data1, data2);
        status = ExclusiveMonitorsStatus()
    } else ();
    X_set(32, s) = ZeroExtend(status, 32)
}

val decode_STXP_R_CR_C : (bits(1), bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STXP_R_CR_C (L, Rs, Ct2, Rn, Ct) = {
    let 't = UInt(Ct);
    let 't2 = UInt(Ct2);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ATOMIC;
    execute_STXP_R_CR_C(acctype, n, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rs = Slice(__opcode, 16, 5);
    let Ct2 = Slice(__opcode, 10, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_STXP_R_CR_C(L, Rs, Ct2, Rn, Ct)
}

val execute_STXR_R_CR_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_STXR_R_CR_C (acctype, n, s, t) = {
    CheckCapabilitiesEnabled();
    base : VirtualAddress = undefined;
    data : bits(129) = undefined;
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if s == t then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if s == n & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rn_unknown = true
          },
          Constraint_NONE => {
              rn_unknown = false
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if rn_unknown then {
        base = __UNKNOWN_VirtualAddress()
    } else {
        base = BaseReg_read__1(n)
    };
    if rt_unknown then {
        data = __UNKNOWN_bits(129)
    } else {
        data = C_read(t)
    };
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, acctype);
    status : bits(1) = 0b1;
    if AArch64_ExclusiveMonitorsPass(addr, CAPABILITY_DBYTES) then {
        MemC_set(addr, acctype) = data;
        status = ExclusiveMonitorsStatus()
    } else ();
    X_set(32, s) = ZeroExtend(status, 32)
}

val decode_STXR_R_CR_C : (bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_STXR_R_CR_C (L, Rs, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ATOMIC;
    execute_STXR_R_CR_C(acctype, n, s, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rs = Slice(__opcode, 16, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_STXR_R_CR_C(L, Rs, Rn, Ct)
    }
}

val execute_SUB_C_CIS_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(64), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SUB_C_CIS_C (d, imm, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let 'operand2 = UInt(imm);
    result : bits(129) = CapAdd__1(operand1, negate(operand2));
    if CapIsSealed(operand1) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_SUB_C_CIS_C : (bits(1), bits(1), bits(12), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SUB_C_CIS_C (A, sh, imm12, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    imm : bits(64) = undefined;
    match sh {
      0b0 => {
          imm = ZeroExtend(imm12, 64)
      },
      0b1 => {
          imm = ZeroExtend(imm12 @ Zeros(12), 64)
      }
    };
    let imm = imm;
    execute_SUB_C_CIS_C(d, imm, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let A = Slice(__opcode, 23, 1);
    let sh = Slice(__opcode, 22, 1);
    let imm12 = Slice(__opcode, 10, 12);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_SUB_C_CIS_C(A, sh, imm12, Cn, Cd)
}

val execute_SUBS_R_CC_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_SUBS_R_CC_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = C_read(n);
    let operand2 : bits(129) = C_read(m);
    let tag1 : bool = CapIsTagSet(operand1);
    let tag2 : bool = CapIsTagSet(operand2);
    result : bits(64) = undefined;
    nzcv : bits(4) = undefined;
    if tag1 != tag2 then {
        interim : bits(2) = undefined;
        let tvalue1 : bits(2) = if tag1 then 0b01 else 0b00;
        let tvalue2 : bits(2) = if tag2 then 0b01 else 0b00;
        (interim, nzcv) = AddWithCarry(tvalue1, not_vec(tvalue2), 0b1);
        result = ZeroExtend(interim, 64)
    } else {
        let value1_name : bits(64) = CapGetValue(operand1);
        let value2_name : bits(64) = CapGetValue(operand2);
        (result, nzcv) = AddWithCarry(value1_name, not_vec(value2_name), 0b1)
    };
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv;
    X_set(64, d) = result
}

val decode_SUBS_R_CC_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SUBS_R_CC_C (Cm, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_SUBS_R_CC_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_SUBS_R_CC_C(Cm, Cn, Rd)
}

val execute_SWP_CC_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_SWP_CC_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    let store_data : bits(129) = C_read(s);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(store_data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(store_data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    data : bits(129) = MemAtomicC(addr, MemAtomicOp_SWP, store_data, ldacctype, stacctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_SWP_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SWP_CC_R_C (A, R, Cs, Rn, Ct) = {
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = AccType_ATOMICRW;
    execute_SWP_CC_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let A = Slice(__opcode, 23, 1);
    let R = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_SWP_CC_R_C (A, R, Cs, Rn, Ct);
    decode_SWP_CC_R_C(A, R, Cs, Rn, Ct)
}

val execute_SWPA_CC_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_SWPA_CC_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    let store_data : bits(129) = C_read(s);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(store_data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(store_data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    data : bits(129) = MemAtomicC(addr, MemAtomicOp_SWP, store_data, ldacctype, stacctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_SWPA_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SWPA_CC_R_C (A, R, Cs, Rn, Ct) = {
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    let ldacctype : AccType = if Ct != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = AccType_ATOMICRW;
    execute_SWPA_CC_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let A = Slice(__opcode, 23, 1);
    let R = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_SWPA_CC_R_C (A, R, Cs, Rn, Ct);
    decode_SWPA_CC_R_C(A, R, Cs, Rn, Ct)
}

val execute_SWPAL_CC_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_SWPAL_CC_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    let store_data : bits(129) = C_read(s);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(store_data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(store_data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    data : bits(129) = MemAtomicC(addr, MemAtomicOp_SWP, store_data, ldacctype, stacctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_SWPAL_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SWPAL_CC_R_C (A, R, Cs, Rn, Ct) = {
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    let ldacctype : AccType = if Ct != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = AccType_ORDEREDATOMICRW;
    execute_SWPAL_CC_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let A = Slice(__opcode, 23, 1);
    let R = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_SWPAL_CC_R_C (A, R, Cs, Rn, Ct);
    decode_SWPAL_CC_R_C(A, R, Cs, Rn, Ct)
}

val execute_SWPL_CC_R_C : forall 'n 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31).
  (AccType, int('n), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_SWPL_CC_R_C (ldacctype, n, s, stacctype, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = BaseReg_read__1(n);
    let addr : bits(64) = VAddress(base);
    let store_data : bits(129) = C_read(s);
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, ldacctype);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(store_data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(store_data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, stacctype);
    data : bits(129) = MemAtomicC(addr, MemAtomicOp_SWP, store_data, ldacctype, stacctype);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_SWPL_CC_R_C : (bits(1), bits(1), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_SWPL_CC_R_C (A, R, Cs, Rn, Ct) = {
    let 't = UInt(Ct);
    let 's = UInt(Cs);
    let 'n = UInt(Rn);
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = AccType_ORDEREDATOMICRW;
    execute_SWPL_CC_R_C(ldacctype, n, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let A = Slice(__opcode, 23, 1);
    let R = Slice(__opcode, 22, 1);
    let Cs = Slice(__opcode, 16, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_SWPL_CC_R_C (A, R, Cs, Rn, Ct);
    decode_SWPL_CC_R_C(A, R, Cs, Rn, Ct)
}

val execute_CHKEQ___CC_C : forall 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CHKEQ___CC_C (m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(129) = C_read(m);
    if operand1 == operand2 then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0100
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    }
}

val decode_CHKEQ___CC_C : (bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CHKEQ___CC_C (Cm, opc, Cn) = {
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CHKEQ___CC_C(m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    decode_CHKEQ___CC_C(Cm, opc, Cn)
}

val execute_CHKSS___CC_C : forall 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CHKSS___CC_C (m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let testingcap : bits(129) = if m == 31 then CSP_read() else C_read(m);
    if CapIsSubSetOf(operand1, testingcap) & CapGetTag(operand1) == CapGetTag(testingcap) then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b1000
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    }
}

val decode_CHKSS___CC_C : (bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CHKSS___CC_C (Cm, opc, Cn) = {
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CHKSS___CC_C(m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    decode_CHKSS___CC_C(Cm, opc, Cn)
}

val execute_CHKSSU_C_CC_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CHKSSU_C_CC_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let testingcap : bits(129) = if m == 31 then CSP_read() else C_read(m);
    result : bits(129) = operand1;
    if CapIsSubSetOf(operand1, testingcap) & CapGetTag(operand1) == CapGetTag(testingcap) then {
        if ((CapIsTagSet(testingcap) & not_bool(CapIsSealed(testingcap))) & CapIsTagSet(operand1)) & CapIsSealed(operand1) then {
            result = CapUnseal(operand1)
        } else ();
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b1000
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    };
    C_set(d) = result
}

val decode_CHKSSU_C_CC_C : (bits(5), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CHKSSU_C_CC_C (Cm, opc, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CHKSSU_C_CC_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 14, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CHKSSU_C_CC_C(Cm, opc, Cn, Cd)
}

val execute_CVT_R_CC_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVT_R_CC_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(129) = C_read(m);
    result : bits(64) = undefined;
    if CapIsTagSet(operand1) then {
        if [CCTLR_read__1()[2]] == 0b1 then {
            result = CapGetValue(operand1) - CapGetBase(operand2)
        } else {
            result = CapGetValue(operand1)
        };
        if result == 0 then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0110
        } else {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0010
        }
    } else {
        result = Zeros(64);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    };
    X_set(64, d) = result
}

val decode_CVT_R_CC_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVT_R_CC_C (Cm, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    let 'm = UInt(Cm);
    execute_CVT_R_CC_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Cm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_CVT_R_CC_C(Cm, Cn, Rd)
}

val execute_CVTD_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTD_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(129) = DDC_read();
    result : bits(64) = undefined;
    if CapIsTagSet(operand1) then {
        if [CCTLR_read__1()[2]] == 0b1 then {
            result = CapGetValue(operand1) - CapGetBase(operand2)
        } else {
            result = CapGetValue(operand1)
        };
        if result == 0 then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0110
        } else {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0010
        }
    } else {
        result = Zeros(64);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    };
    X_set(64, d) = result
}

val decode_CVTD_R_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTD_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_CVTD_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_CVTD_R_C_C(opc, Cn, Rd)
}

val execute_CVTP_R_C_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTP_R_C_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(129) = PCC_read();
    result : bits(64) = undefined;
    if CapIsTagSet(operand1) then {
        if [CCTLR_read__1()[3]] == 0b1 then {
            result = CapGetValue(operand1) - CapGetBase(operand2)
        } else {
            result = CapGetValue(operand1)
        };
        if result == 0 then {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0110
        } else {
            (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0010
        }
    } else {
        result = Zeros(64);
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    };
    X_set(64, d) = result
}

val decode_CVTP_R_C_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTP_R_C_C (opc, Cn, Rd) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Cn);
    execute_CVTP_R_C_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    let Rd = Slice(__opcode, 0, 5);
    decode_CVTP_R_C_C(opc, Cn, Rd)
}

val execute_CVTD_C_R_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTD_C_R_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = DDC_read();
    let operand2 : bits(64) = X_read(64, n);
    result : bits(129) = undefined;
    if [CCTLR_read__1()[2]] == 0b1 then {
        result = CapSetOffset(operand1, operand2)
    } else {
        result = CapSetValue(operand1, operand2)
    };
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CVTD_C_R_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTD_C_R_C (opc, Rn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Rn);
    execute_CVTD_C_R_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CVTD_C_R_C(opc, Rn, Cd)
}

val execute_CVTP_C_R_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTP_C_R_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = PCC_read();
    let operand2 : bits(64) = X_read(64, n);
    result : bits(129) = undefined;
    if [CCTLR_read__1()[3]] == 0b1 then {
        result = CapSetOffset(operand1, operand2)
    } else {
        result = CapSetValue(operand1, operand2)
    };
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CVTP_C_R_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTP_C_R_C (opc, Rn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Rn);
    execute_CVTP_C_R_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CVTP_C_R_C(opc, Rn, Cd)
}

val execute_CVTDZ_C_R_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTDZ_C_R_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = DDC_read();
    let operand2 : bits(64) = X_read(64, n);
    result : bits(129) = undefined;
    if operand2 == 0 then {
        result = CapNull()
    } else {
        if [CCTLR_read__1()[2]] == 0b1 then {
            result = CapSetOffset(operand1, operand2)
        } else {
            result = CapSetValue(operand1, operand2)
        }
    };
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CVTDZ_C_R_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTDZ_C_R_C (opc, Rn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Rn);
    execute_CVTDZ_C_R_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CVTDZ_C_R_C(opc, Rn, Cd)
}

val execute_CVTPZ_C_R_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTPZ_C_R_C (d, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = PCC_read();
    let operand2 : bits(64) = X_read(64, n);
    result : bits(129) = undefined;
    if operand2 == 0 then {
        result = CapNull()
    } else {
        if [CCTLR_read__1()[3]] == 0b1 then {
            result = CapSetOffset(operand1, operand2)
        } else {
            result = CapSetValue(operand1, operand2)
        }
    };
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CVTPZ_C_R_C : (bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTPZ_C_R_C (opc, Rn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Rn);
    execute_CVTPZ_C_R_C(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CVTPZ_C_R_C(opc, Rn, Cd)
}

val execute_CVT_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVT_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(64) = X_read(64, m);
    result : bits(129) = undefined;
    if [CCTLR_read__1()[2]] == 0b1 then {
        result = CapSetOffset(operand1, operand2)
    } else {
        result = CapSetValue(operand1, operand2)
    };
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CVT_C_CR_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVT_C_CR_C (Rm, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_CVT_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CVT_C_CR_C(Rm, Cn, Cd)
}

val execute_CVTZ_C_CR_C : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CVTZ_C_CR_C (d, m, n) = {
    CheckCapabilitiesEnabled();
    let operand1 : bits(129) = if n == 31 then CSP_read() else C_read(n);
    let operand2 : bits(64) = X_read(64, m);
    result : bits(129) = undefined;
    if operand2 == 0 then {
        result = CapNull()
    } else {
        if [CCTLR_read__1()[2]] == 0b1 then {
            result = CapSetOffset(operand1, operand2)
        } else {
            result = CapSetValue(operand1, operand2)
        }
    };
    if CapIsSealed(operand1) then {
        C_set(d) = CapWithTagClear(result)
    } else {
        C_set(d) = result
    }
}

val decode_CVTZ_C_CR_C : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CVTZ_C_CR_C (Rm, Cn, Cd) = {
    let 'd = UInt(Cd);
    let 'n = UInt(Cn);
    let 'm = UInt(Rm);
    execute_CVTZ_C_CR_C(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CVTZ_C_CR_C(Rm, Cn, Cd)
}

val execute_CHKSLD_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  int('n) -> unit effect {escape, rreg, undef, wreg}

function execute_CHKSLD_C_C n = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    if CapIsSealed(operand) then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0001
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    }
}

val decode_CHKSLD_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CHKSLD_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    execute_CHKSLD_C_C(n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    decode_CHKSLD_C_C(opc, Cn)
}

val execute_CHKTGD_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  int('n) -> unit effect {escape, rreg, undef, wreg}

function execute_CHKTGD_C_C n = {
    CheckCapabilitiesEnabled();
    let operand : bits(129) = if n == 31 then CSP_read() else C_read(n);
    if CapIsTagSet(operand) then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0010
    } else {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = 0b0000
    }
}

val decode_CHKTGD_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CHKTGD_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    execute_CHKTGD_C_C(n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    decode_CHKTGD_C_C(opc, Cn)
}

val execute_CLRPERM_C_CI_C : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(3), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_CLRPERM_C_CI_C (d, imm, n) = {
    CheckCapabilitiesEnabled();
    let data : bits(129) = if n == 31 then CSP_read() else C_read(n);
    clr_perms : bits(64) = Zeros(64);
    if [imm[0]] == 0b1 then {
        clr_perms = clr_perms | CAP_PERM_EXECUTE
    } else ();
    if [imm[1]] == 0b1 then {
        clr_perms = clr_perms | CAP_PERM_STORE
    } else ();
    if [imm[2]] == 0b1 then {
        clr_perms = clr_perms | CAP_PERM_LOAD
    } else ();
    result : bits(129) = CapClearPerms(data, clr_perms);
    if CapIsSealed(data) then {
        result = CapWithTagClear(result)
    } else ();
    if d == 31 then {
        CSP_set() = result
    } else {
        C_set(d) = result
    }
}

val decode_CLRPERM_C_CI_C : (bits(3), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_CLRPERM_C_CI_C (perm, Cn, Cd) = {
    let 'n = UInt(Cn);
    let 'd = UInt(Cd);
    let imm : bits(3) = perm;
    execute_CLRPERM_C_CI_C(d, imm, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let perm = Slice(__opcode, 13, 3);
    let Cn = Slice(__opcode, 5, 5);
    let Cd = Slice(__opcode, 0, 5);
    decode_CLRPERM_C_CI_C(perm, Cn, Cd)
}

val execute_BR_CI_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_BR_CI_C (branch_type, n, offset) = {
    CheckCapabilitiesEnabled();
    base : bits(129) = undefined;
    target : bits(129) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        base = CSP_read()
    } else {
        base = C_read(n)
    };
    if n == 29 then {
        if (CapIsTagSet(base) & CapIsSealed(base)) & CapGetObjectType(base) == CAP_SEAL_TYPE_LB then {
            base = CapUnseal(base)
        } else ();
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase) + offset;
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
        target = MemC_read(addr, AccType_NORMAL);
        target = CapSquashPostLoadCap(target, vabase);
        C_set(29) = base
    } else {
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase) + offset;
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
        target = MemC_read(addr, AccType_NORMAL);
        target = CapSquashPostLoadCap(target, vabase)
    };
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    let target = target;
    BranchXToCapability(target, branch_type)
}

val decode_BR_CI_C : (bits(7), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BR_CI_C (imm7, Cn) = {
    let 'n = UInt(Cn);
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    let branch_type : BranchType = BranchType_INDIR;
    execute_BR_CI_C(branch_type, n, offset)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let imm7 = Slice(__opcode, 13, 7);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BR_CI_C (imm7, Cn);
    decode_BR_CI_C(imm7, Cn)
}

val execute_BLR_CI_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_BLR_CI_C (branch_type, n, offset) = {
    CheckCapabilitiesEnabled();
    base : bits(129) = undefined;
    target : bits(129) = undefined;
    if n == 31 then {
        CheckSPAlignment();
        base = CSP_read()
    } else {
        base = C_read(n)
    };
    linkoffset : int = 4;
    if IsInC64() then {
        linkoffset = linkoffset + 1
    } else ();
    let 'linkoffset = linkoffset;
    link : bits(129) = CapAdd__1(PCC_read(), linkoffset);
    if [CCTLR_read__1()[7]] == 0b1 then {
        link = CapSetObjectType(link, CAP_SEAL_TYPE_RB)
    } else ();
    if n == 29 then {
        if (CapIsTagSet(base) & CapIsSealed(base)) & CapGetObjectType(base) == CAP_SEAL_TYPE_LB then {
            base = CapUnseal(base)
        } else ();
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase) + offset;
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
        target = MemC_read(addr, AccType_NORMAL);
        target = CapSquashPostLoadCap(target, vabase);
        C_set(29) = base;
        C_set(30) = link
    } else {
        wb_unknown : bool = false;
        if n == 30 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_LINKBASEOVERLAPLD);
            assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  wb_unknown = true
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        } else ();
        let vabase : VirtualAddress = VAFromCapability(base);
        let addr : bits(64) = VAddress(vabase) + offset;
        VACheckAddress(vabase, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
        target = MemC_read(addr, AccType_NORMAL);
        target = CapSquashPostLoadCap(target, vabase);
        if wb_unknown then {
            C_set(30) = __UNKNOWN_bits(129)
        } else {
            C_set(30) = link
        }
    };
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else ();
    let target = target;
    BranchXToCapability(target, branch_type)
}

val decode_BLR_CI_C : (bits(7), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BLR_CI_C (imm7, Cn) = {
    let 'n = UInt(Cn);
    let offset : bits(64) = SignExtend(imm7 @ 0b0000, 64);
    let branch_type : BranchType = BranchType_INDCALL;
    execute_BLR_CI_C(branch_type, n, offset)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let imm7 = Slice(__opcode, 13, 7);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BLR_CI_C (imm7, Cn);
    decode_BLR_CI_C(imm7, Cn)
}

val execute_BX___C : BranchType -> unit effect {escape, rreg, undef, wreg}

function execute_BX___C branch_type = {
    CheckCapabilitiesEnabled();
    offset : int = 4;
    if not_bool(IsInC64()) then {
        offset = offset + 1
    } else ();
    let 'offset = offset;
    let target : bits(129) = CapAdd__1(PCC_read(), offset);
    BranchXToCapability(target, branch_type)
}

val decode_BX___C : bits(2) -> unit effect {escape, rreg, undef, wreg}

function decode_BX___C opc = {
    let branch_type : BranchType = BranchType_DIR;
    execute_BX___C(branch_type)
}

function clause __DecodeA64 (pc, (0b11000010110000100111001111100000 as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    if ((([__opcode[5]] != 0b1 | [__opcode[6]] != 0b1) | [__opcode[7]] != 0b1) | [__opcode[8]] != 0b1) | [__opcode[9]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_BX___C(opc)
    }
}

val execute_ASTR_C_RUI_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_C_RUI_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, AccType_NORMAL);
    MemC_set(addr, AccType_NORMAL) = data
}

val decode_ASTR_C_RUI_C : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_C_RUI_C (L, imm9, op, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9 @ 0b0000, 64);
    execute_ASTR_C_RUI_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_ASTR_C_RUI_C(L, imm9, op, Rn, Ct)
}

val execute_ASTRB_R_RUI_B : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTRB_R_RUI_B (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTRB_R_RUI_B : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTRB_R_RUI_B (L, imm9, op, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9, 64);
    let 'datasize = 8;
    regsize = 32;
    execute_ASTRB_R_RUI_B(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTRB_R_RUI_B(L, imm9, op, Rn, Rt)
}

val execute_ASTR_R_RUI_32 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_R_RUI_32 (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTR_R_RUI_32 : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_R_RUI_32 (L, imm9, op, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9 @ 0b00, 64);
    let 'datasize = 32;
    regsize = 32;
    execute_ASTR_R_RUI_32(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTR_R_RUI_32(L, imm9, op, Rn, Rt)
}

val execute_ASTR_R_RUI_64 : forall 'datasize 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize == 64).
  (int('datasize), int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_R_RUI_64 (datasize, n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTR_R_RUI_64 : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_R_RUI_64 (L, imm9, op, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9 @ 0b000, 64);
    let 'datasize = 64;
    regsize = 64;
    execute_ASTR_R_RUI_64(datasize, n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTR_R_RUI_64(L, imm9, op, Rn, Rt)
}

val execute_ALDR_C_RUI_C : forall 'n 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31).
  (int('n), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_C_RUI_C (n, offset, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
    data : bits(129) = MemC_read(addr, AccType_NORMAL);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_ALDR_C_RUI_C : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_C_RUI_C (L, imm9, op, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9 @ 0b0000, 64);
    execute_ALDR_C_RUI_C(n, offset, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_ALDR_C_RUI_C (L, imm9, op, Rn, Ct);
    decode_ALDR_C_RUI_C(L, imm9, op, Rn, Ct)
}

val execute_ALDRB_R_RUI_B : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 8).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRB_R_RUI_B (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDRB_R_RUI_B : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRB_R_RUI_B (L, imm9, op, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9, 64);
    let 'datasize = 8;
    let 'regsize = 32;
    execute_ALDRB_R_RUI_B(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRB_R_RUI_B(L, imm9, op, Rn, Rt)
}

val execute_ALDR_R_RUI_32 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 'datasize == 32).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_R_RUI_32 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDR_R_RUI_32 : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_R_RUI_32 (L, imm9, op, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9 @ 0b00, 64);
    let 'datasize = 32;
    let 'regsize = 32;
    execute_ALDR_R_RUI_32(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDR_R_RUI_32(L, imm9, op, Rn, Rt)
}

val execute_ALDR_R_RUI_64 : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 'datasize == 64).
  (int('datasize), int('n), bits(64), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_R_RUI_64 (datasize, n, offset, regsize, t) = {
    CheckCapabilitiesEnabled();
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDR_R_RUI_64 : (bits(1), bits(9), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_R_RUI_64 (L, imm9, op, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let offset : bits(64) = ZeroExtend(imm9 @ 0b000, 64);
    let 'datasize = 64;
    let 'regsize = 64;
    execute_ALDR_R_RUI_64(datasize, n, offset, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 21, 1);
    let imm9 = Slice(__opcode, 12, 9);
    let op = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDR_R_RUI_64(L, imm9, op, Rn, Rt)
}

val execute_ASTR_C_RRB_C : forall 'm 'n 'shift 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_C_RRB_C (extend_type, m, n, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let data : bits(129) = C_read(t);
    cap_required : bits(64) = CAP_PERM_STORE;
    if CapIsTagSet(data) then {
        cap_required = cap_required | CAP_PERM_STORE_CAP;
        if CapIsLocal(data) then {
            cap_required = cap_required | CAP_PERM_STORE_LOCAL
        } else ()
    } else ();
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, cap_required, AccType_NORMAL);
    MemC_set(addr, AccType_NORMAL) = data
}

val decode_ASTR_C_RRB_C : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_C_RRB_C (Rm, sign, sz, S, L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = LOG2_CAPABILITY_DBYTES;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_ASTR_C_RRB_C(extend_type, m, n, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let L = Slice(__opcode, 11, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    decode_ASTR_C_RRB_C(Rm, sign, sz, S, L, Rn, Ct)
}

val execute_ASTRB_R_RRB_B : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift == 0 & 'scale == 0 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTRB_R_RRB_B (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTRB_R_RRB_B : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTRB_R_RRB_B (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 0;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ASTRB_R_RRB_B(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTRB_R_RRB_B(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ASTRH_R_RRB_32 : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 1} & 'scale == 1 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTRH_R_RRB_32 (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTRH_R_RRB_32 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTRH_R_RRB_32 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 1;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ASTRH_R_RRB_32(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTRH_R_RRB_32(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ASTR_R_RRB_32 : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 2} & 'scale == 2 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_R_RRB_32 (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTR_R_RRB_32 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_R_RRB_32 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 2;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ASTR_R_RRB_32(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTR_R_RRB_32(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ASTR_R_RRB_64 : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 3} & 'scale == 3 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_R_RRB_64 (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = X_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTR_R_RRB_64 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_R_RRB_64 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 3;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 64;
    execute_ASTR_R_RRB_64(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTR_R_RRB_64(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ASTR_V_RRB_D : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 3} & 'scale == 3 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_V_RRB_D (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTR_V_RRB_D : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_V_RRB_D (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 3;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_ASTR_V_RRB_D(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTR_V_RRB_D(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ASTR_V_RRB_S : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 2} & 'scale == 2 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ASTR_V_RRB_S (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_STORE, AccType_NORMAL);
    let data : bits('datasize) = V_read(datasize, t);
    Mem_set(addr, DIV(datasize, 8), AccType_NORMAL) = data
}

val decode_ASTR_V_RRB_S : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ASTR_V_RRB_S (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 2;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_ASTR_V_RRB_S(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ASTR_V_RRB_S(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDR_C_RRB_C : forall 'm 'n 'shift 't,
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_C_RRB_C (extend_type, m, n, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, CAPABILITY_DBYTES, CAP_PERM_LOAD, AccType_NORMAL);
    data : bits(129) = MemC_read(addr, AccType_NORMAL);
    let data : bits(129) = CapSquashPostLoadCap(data, base);
    C_set(t) = data
}

val decode_ALDR_C_RRB_C : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_C_RRB_C (Rm, sign, sz, S, L, Rn, Ct) = {
    let 't = UInt(Ct);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = LOG2_CAPABILITY_DBYTES;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_ALDR_C_RRB_C(extend_type, m, n, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let L = Slice(__opcode, 11, 1);
    let Rn = Slice(__opcode, 5, 5);
    let Ct = Slice(__opcode, 0, 5);
    __ThisInstrAbstract = Instr_ALDR_C_RRB_C (Rm, sign, sz, S, L, Rn, Ct);
    decode_ALDR_C_RRB_C(Rm, sign, sz, S, L, Rn, Ct)
}

val execute_ALDRB_R_RRB_B : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift == 0 & 'scale == 0 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRB_R_RRB_B (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDRB_R_RRB_B : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRB_R_RRB_B (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 0;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ALDRB_R_RRB_B(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRB_R_RRB_B(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDRH_R_RRB_32 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 1} & 'scale == 1 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRH_R_RRB_32 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDRH_R_RRB_32 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRH_R_RRB_32 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 1;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ALDRH_R_RRB_32(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRH_R_RRB_32(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDR_R_RRB_32 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 2} & 'scale == 2 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_R_RRB_32 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDR_R_RRB_32 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_R_RRB_32 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 2;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ALDR_R_RRB_32(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDR_R_RRB_32(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDR_R_RRB_64 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 3} & 'scale == 3 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_R_RRB_64 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ALDR_R_RRB_64 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_R_RRB_64 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 3;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 64;
    execute_ALDR_R_RRB_64(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDR_R_RRB_64(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDRSB_R_RRB_64 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift == 0 & 'scale == 0 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRSB_R_RRB_64 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDRSB_R_RRB_64 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRSB_R_RRB_64 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 0;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 64;
    execute_ALDRSB_R_RRB_64(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRSB_R_RRB_64(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDRSB_R_RRB_32 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift == 0 & 'scale == 0 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRSB_R_RRB_32 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDRSB_R_RRB_32 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRSB_R_RRB_32 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 0;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ALDRSB_R_RRB_32(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRSB_R_RRB_32(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDRSH_R_RRB_64 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 1} & 'scale == 1 & 'regsize == 64 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRSH_R_RRB_64 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDRSH_R_RRB_64 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRSH_R_RRB_64 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 1;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 64;
    execute_ALDRSH_R_RRB_64(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRSH_R_RRB_64(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDRSH_R_RRB_32 : forall 'm 'n 'regsize 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 1} & 'scale == 1 & 'regsize == 32 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('regsize), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDRSH_R_RRB_32 (extend_type, m, n, regsize, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = SignExtend(data, regsize)
}

val decode_ALDRSH_R_RRB_32 : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDRSH_R_RRB_32 (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 1;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    let 'regsize = 32;
    execute_ALDRSH_R_RRB_32(extend_type, m, n, regsize, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDRSH_R_RRB_32(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDR_V_RRB_D : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 3} & 'scale == 3 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_V_RRB_D (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDR_V_RRB_D : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_V_RRB_D (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 3;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_ALDR_V_RRB_D(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDR_V_RRB_D(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_ALDR_V_RRB_S : forall 'm 'n 'scale 'shift 't,
  (0 <= 't & 't <= 31 & 'shift in {0, 2} & 'scale == 2 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31).
  (ExtendType, int('m), int('n), int('scale), int('shift), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_ALDR_V_RRB_S (extend_type, m, n, scale, shift, t) = {
    CheckCapabilitiesEnabled();
    CheckFPAdvSIMDEnabled64();
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    let base : VirtualAddress = AltBaseReg_read__1(n);
    let 'datasize = (8 << scale);
    let addr : bits(64) = VAddress(base) + offset;
    VACheckAddress(base, addr, DIV(datasize, 8), CAP_PERM_LOAD, AccType_NORMAL);
    let data : bits('datasize) = Mem_read(addr, DIV(datasize, 8), AccType_NORMAL);
    V_set(datasize, t) = data
}

val decode_ALDR_V_RRB_S : (bits(1), bits(5), bits(1), bits(1), bits(1), bits(2), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ALDR_V_RRB_S (L, Rm, sign, sz, S, opc, Rn, Rt) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'scale = 2;
    let extend_type : ExtendType = DecodeRegExtend((sign @ 0b1) @ sz);
    let 'shift = if S == 0b1 then scale else 0;
    execute_ALDR_V_RRB_S(extend_type, m, n, scale, shift, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, bitone, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let L = Slice(__opcode, 22, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sign = Slice(__opcode, 15, 1);
    let sz = Slice(__opcode, 13, 1);
    let S = Slice(__opcode, 12, 1);
    let opc = Slice(__opcode, 10, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rt = Slice(__opcode, 0, 5);
    decode_ALDR_V_RRB_S(L, Rm, sign, sz, S, opc, Rn, Rt)
}

val execute_BRS_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BRS_C_C (branch_type, n) = {
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else {
        if [CCTLR_read__1()[7]] == 0b1 then {
            target = CapWithTagClear(target)
        } else ()
    };
    BranchXToCapability(target, branch_type)
}

val decode_BRS_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BRS_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDIR;
    execute_BRS_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BRS_C_C (opc, Cn);
    decode_BRS_C_C(opc, Cn)
}

val execute_BLRS_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_BLRS_C_C (branch_type, n) = {
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else {
        if [CCTLR_read__1()[7]] == 0b1 then {
            target = CapWithTagClear(target)
        } else ()
    };
    linkoffset : int = 4;
    if IsInC64() then {
        linkoffset = linkoffset + 1
    } else ();
    let 'linkoffset = linkoffset;
    link : bits(129) = CapAdd__1(PCC_read(), linkoffset);
    if [CCTLR_read__1()[7]] == 0b1 then {
        link = CapSetObjectType(link, CAP_SEAL_TYPE_RB)
    } else ();
    C_set(30) = link;
    BranchXToCapability(target, branch_type)
}

val decode_BLRS_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_BLRS_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_INDCALL;
    execute_BLRS_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_BLRS_C_C (opc, Cn);
    decode_BLRS_C_C(opc, Cn)
}

val execute_RETS_C_C : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_RETS_C_C (branch_type, n) = {
    CheckCapabilitiesEnabled();
    target : bits(129) = C_read(n);
    if not_bool(IsInRestricted()) & not_bool(CapCheckPermissions(target, CAP_PERM_EXECUTIVE)) then {
        target = CapWithTagClear(target)
    } else ();
    if (CapIsTagSet(target) & CapIsSealed(target)) & CapGetObjectType(target) == CAP_SEAL_TYPE_RB then {
        target = CapUnseal(target)
    } else {
        if [CCTLR_read__1()[7]] == 0b1 then {
            target = CapWithTagClear(target)
        } else ()
    };
    BranchXToCapability(target, branch_type)
}

val decode_RETS_C_C : (bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_RETS_C_C (opc, Cn) = {
    let 'n = UInt(Cn);
    let branch_type : BranchType = BranchType_RET;
    execute_RETS_C_C(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 13, 2);
    let Cn = Slice(__opcode, 5, 5);
    __ThisInstrAbstract = Instr_RETS_C_C (opc, Cn);
    decode_RETS_C_C(opc, Cn)
}

val execute_aarch64_instrs_vector_arithmetic_unary_clsz : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (CountOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_clsz (countop, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    count : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if countop == CountOp_CLS then {
            count = CountLeadingSignBits(Elem_read(operand, e, esize))
        } else {
            count = CountLeadingZeroBits(Elem_read(operand, e, esize))
        };
        result = Elem_set(result, e, esize, count[esize - 1 .. 0])
    };
    V_set(datasize, d) = result
}

val decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let countop : CountOp = if U == 0b1 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_vector_arithmetic_unary_clsz(countop, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz(Rd, Rn, size, U, Q)
}

val decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let countop : CountOp = if U == 0b1 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_vector_arithmetic_unary_clsz(countop, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_logical : forall 'datasize 'rd,
  (0 <= 'rd & 'rd <= 31 & 'datasize in {64, 128}).
  (int('datasize), bits('datasize), ImmediateOp, int('rd)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_logical (datasize, imm, operation, rd) = {
    CheckFPAdvSIMDEnabled64();
    operand : bits('datasize) = undefined;
    result : bits('datasize) = undefined;
    match operation {
      ImmediateOp_MOVI => {
          result = imm
      },
      ImmediateOp_MVNI => {
          result = not_vec(imm)
      },
      ImmediateOp_ORR => {
          let operand : bits('datasize) = V_read(datasize, rd);
          result = operand | imm
      },
      ImmediateOp_BIC => {
          let operand : bits('datasize) = V_read(datasize, rd);
          result = operand & not_vec(imm)
      }
    };
    V_set(datasize, rd) = result
}

val decode_orr_advsimd_imm_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_orr_advsimd_imm_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          } else ();
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_orr_advsimd_imm_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val decode_mvni_advsimd_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mvni_advsimd_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          } else ();
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mvni_advsimd_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val decode_movi_advsimd_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_movi_advsimd_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          } else ();
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64 (pc, ([bitzero, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_movi_advsimd_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val decode_bic_advsimd_imm_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bic_advsimd_imm_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          } else ();
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_logical(datasize, imm, operation, rd)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_bic_advsimd_imm_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val execute_aarch64_instrs_vector_transfer_integer_move_unsigned : forall 'd 'datasize 'esize 'idxdsize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('idxdsize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_integer_move_unsigned (d, datasize, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V_read(idxdsize, n);
    assert(constraint('datasize >= 'esize));
    X_set(datasize, d) = ZeroExtend(Elem_read(operand, index, esize), datasize)
}

val decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    size : {|0, 1, 2, 3|} = 0;
    match Q @ imm5 {
      [bitzero, _, _, _, _, bitone] => {
          size = 0
      },
      [bitzero, _, _, _, bitone, bitzero] => {
          size = 1
      },
      [bitzero, _, _, bitone, bitzero, bitzero] => {
          size = 2
      },
      [bitone, _, bitone, bitzero, bitzero, bitzero] => {
          size = 3
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 64 else 32;
    execute_aarch64_instrs_vector_transfer_integer_move_unsigned(d, datasize, esize, idxdsize, index, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : forall 'datasize ('is_signed : Bool) 'n ('postindex : Bool) 'regsize 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('is_signed), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback__arg) = {
    wback : bool = wback__arg;
    c : Constraint = undefined;
    data : bits('datasize) = undefined;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read(n, memop == MemOp_PREFETCH);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(datasize, t)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          } else ();
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          } else ();
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          if is_signed then {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = SignExtend(data, regsize)
          } else {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          let address : bits(64) = VAddress(base);
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPDiv(element1, element2, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16(Rd, Rn, Rm, Q)
}

val decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_integer_logical_shiftedreg : forall 'd 'datasize ('invert : Bool) 'm 'n ('setflags : Bool) 'shift_amount,
  (0 <= 'shift_amount & 'shift_amount <= 63 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp, bool('setflags), int('shift_amount), ShiftType) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_logical_shiftedreg (d, datasize, invert, m, n, op, setflags, shift_amount, shift_type) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(datasize, n);
    operand2 : bits('datasize) = ShiftReg(datasize, m, shift_type, shift_amount);
    if invert then {
        operand2 = not_vec(operand2)
    } else ();
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = EOR(operand1, operand2)
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    } else ();
    X_set(datasize, d) = result
}

val decode_eon_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_eon_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_eon_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_bics_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bics_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_bics_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd, Rn, imm6, Rm, N, shift, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    let invert : bool = N == 0b1;
    execute_aarch64_instrs_integer_logical_shiftedreg(d, datasize, invert, m, n, op, setflags, shift_amount, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 21, 1);
    let shift = Slice(__opcode, 22, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg(Rd, Rn, imm6, Rm, N, shift, opc, sf)
}

val execute_aarch64_instrs_memory_vector_multiple_no_wb : forall 'datasize 'elements 'esize 'm 'n 'rpt 'selem 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'selem in {1, 2, 3, 4} & 'rpt in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128}).
  (int('datasize), int('elements), int('esize), int('m), MemOp, int('n), int('rpt), int('selem), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_vector_multiple_no_wb (datasize, elements, esize, m, memop, n, rpt, selem, t, wback) = {
    CheckFPAdvSIMDEnabled64();
    rval : bits('datasize) = undefined;
    tt : int = undefined;
    let 'ebytes = DIV(esize, 8);
    let base : VirtualAddress = BaseReg_read__1(n);
    let address : bits(64) = VAddress(base);
    if memop == MemOp_LOAD then {
        VACheckAddress(base, address, rpt * elements * selem * ebytes, CAP_PERM_LOAD, AccType_VEC)
    } else {
        VACheckAddress(base, address, rpt * elements * selem * ebytes, CAP_PERM_STORE, AccType_VEC)
    };
    offs : bits(64) = Zeros();
    foreach (r from 0 to (rpt - 1) by 1 in inc) {
        foreach (e from 0 to (elements - 1) by 1 in inc) {
            tt = MOD(t + r, 32);
            foreach (s from 0 to (selem - 1) by 1 in inc) {
                let 'tt = tt in
                  {
                      rval = V_read(datasize, tt)
                  };
                let 'tt = tt in
                  {
                      if memop == MemOp_LOAD then {
                          rval = Elem_set(rval, e, esize, Mem_read(address + offs, ebytes, AccType_VEC));
                          V_set(datasize, tt) = rval
                      } else {
                          Mem_set(address + offs, ebytes, AccType_VEC) = Elem_read(rval, e, esize)
                      }
                  };
                offs = offs + ebytes;
                tt = MOD(tt + 1, 32)
            }
        }
    };
    if wback then {
        if m != 31 then {
            offs = X_read(64, m)
        } else ();
        BaseReg_set(n) = VAAdd(base, offs)
    } else ()
}

val decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb : (bits(5), bits(5), bits(2), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt, Rn, size, opcode, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb(Rt, Rn, size, opcode, L, Q)
}

val decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc : (bits(5), bits(5), bits(2), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt, Rn, size, opcode, Rm, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << UInt(size));
    let 'elements = DIV(datasize, esize);
    rpt : {|1, 2, 3, 4|} = 1;
    selem : {|1, 2, 3, 4|} = 1;
    match opcode {
      0b0000 => {
          rpt = 1;
          selem = 4
      },
      0b0010 => {
          rpt = 4;
          selem = 1
      },
      0b0100 => {
          rpt = 1;
          selem = 3
      },
      0b0110 => {
          rpt = 3;
          selem = 1
      },
      0b0111 => {
          rpt = 1;
          selem = 1
      },
      0b1000 => {
          rpt = 1;
          selem = 2
      },
      0b1010 => {
          rpt = 2;
          selem = 1
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'selem = selem;
    let 'rpt = rpt;
    if (size @ Q) == 0b110 & selem != 1 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_memory_vector_multiple_no_wb(datasize, elements, esize, m, memop, n, rpt, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let opcode = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc(Rt, Rn, size, opcode, Rm, L, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (d, datasize, elements, esize, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    let operand3 : bits(2 * 'datasize) = V_read(2 * datasize, d);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    accum : bits(2 * 'esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        product = (element1 * element2)[2 * esize - 1 .. 0];
        if sub_op then {
            accum = Elem_read(operand3, e, 2 * esize) - product
        } else {
            accum = Elem_read(operand3, e, 2 * esize) + product
        };
        result = Elem_set(result, e, 2 * esize, accum)
    };
    V_set(2 * datasize, d) = result
}

val decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff (accumulate, d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    element1 : int = undefined;
    element2 : int = undefined;
    absdiff : bits('esize) = undefined;
    result : bits('datasize) = if accumulate then V_read(datasize, d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        absdiff = Abs(element1 - element2)[esize - 1 .. 0];
        result = Elem_set(result, e, esize, Elem_read(result, e, esize) + absdiff)
    };
    V_set(datasize, d) = result
}

val decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd, Rn, ac, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let accumulate : bool = ac == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff(accumulate, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff(Rd, Rn, ac, Rm, size, U, Q)
}

val execute_aarch64_instrs_integer_logical_immediate : forall 'd 'datasize 'n ('setflags : Bool),
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits('datasize), int('n), LogicalOp, bool('setflags)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_logical_immediate (d, datasize, imm, n, op, setflags) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = imm;
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      LogicalOp_EOR => {
          result = EOR(operand1, operand2)
      }
    };
    let result = result;
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = ([result[datasize - 1]] @ IsZeroBit(result)) @ 0b00
    } else ();
    if d == 31 & not_bool(setflags) then {
        SP_set(datasize) = result
    } else {
        X_set(datasize, d) = result
    }
}

val decode_and_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_and_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    } else ();
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(datasize, N, imms, immr, true)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_and_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_orr_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_orr_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    } else ();
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(datasize, N, imms, immr, true)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_orr_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_ands_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ands_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    } else ();
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(datasize, N, imms, immr, true)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ands_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_eor_log_imm_aarch64_instrs_integer_logical_immediate : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_eor_log_imm_aarch64_instrs_integer_logical_immediate (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    setflags : bool = undefined;
    op : LogicalOp = undefined;
    match opc {
      0b00 => {
          op = LogicalOp_AND;
          setflags = false
      },
      0b01 => {
          op = LogicalOp_ORR;
          setflags = false
      },
      0b10 => {
          op = LogicalOp_EOR;
          setflags = false
      },
      0b11 => {
          op = LogicalOp_AND;
          setflags = true
      }
    };
    let op = op;
    let setflags = setflags;
    imm : bits('datasize) = undefined;
    if sf == 0b0 & N != 0b0 then {
        throw(Error_Undefined())
    } else ();
    let (__tup_0 : bits('datasize), _) =
      DecodeBitMasks(datasize, N, imms, immr, true)
    in
      {
          imm = __tup_0
      };
    execute_aarch64_instrs_integer_logical_immediate(d, datasize, imm, n, op, setflags)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_eor_log_imm_aarch64_instrs_integer_logical_immediate(Rd, Rn, imms, immr, N, opc, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (d, datasize, elements, esize, m, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let 'round_const = if rounding then (1 << (esize - 1)) else 0;
    element1 : int = undefined;
    element2 : int = undefined;
    product : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        product = 2 * element1 * element2 + round_const;
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ((product >> esize), esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd(d, datasize, elements, esize, m, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_right_sisd : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n ('round : Bool) 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('n), bool('round), int('shift), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_right_sisd (accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    let 'round_const = if round then (1 << (shift - 1)) else 0;
    element : int = undefined;
    let operand2 : bits('datasize) = if accumulate then V_read(datasize, d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((0 <= 'loop_e * 'esize & 'loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('datasize in {8, 16, 32, 64, 128}))));
        element = ((asl_Int(Elem_read(operand, e, esize), is_unsigned) + round_const) >> shift);
        result = Elem_set(result, e, esize, Elem_read(operand2, e, esize) + element[esize - 1 .. 0])
    };
    V_set(datasize, d) = result
}

val decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd, Rn, o0, o1, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd(Rd, Rn, o0, o1, immb, immh, U)
}

val decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd : (bits(5), bits(5), bits(1), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd, Rn, o0, o1, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let round : bool = o1 == 0b1;
    let accumulate : bool = o0 == 0b1;
    execute_aarch64_instrs_vector_shift_right_sisd(accumulate, d, datasize, elements, esize, n, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let o1 = Slice(__opcode, 13, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd(Rd, Rn, o0, o1, immb, immh, U, Q)
}

val execute_aarch64_instrs_memory_pair_general_post_idx : forall 'datasize ('is_signed : Bool) 'n ('postindex : Bool) 't 't2 ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), bool('is_signed), int('t), int('t2), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_pair_general_post_idx (acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback__arg) = {
    wback : bool = wback__arg;
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    rt_unknown : bool = false;
    wb_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if ((memop == MemOp_STORE & wback) & (t == n | t2 == n)) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_STORE, acctype);
          if rt_unknown & t == n then {
              data1 = __UNKNOWN_bits(datasize)
          } else {
              data1 = X_read(datasize, t)
          };
          if rt_unknown & t2 == n then {
              data2 = __UNKNOWN_bits(datasize)
          } else {
              data2 = X_read(datasize, t2)
          };
          Mem_set(address + 0, dbytes, acctype) = data1;
          Mem_set(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_LOAD, acctype);
          data1 : bits('datasize) = Mem_read(address + 0, dbytes, acctype);
          data2 : bits('datasize) = Mem_read(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          } else ();
          if is_signed then {
              X_set(64, t) = SignExtend(data1, 64);
              X_set(64, t2) = SignExtend(data2, 64)
          } else {
              X_set(datasize, t) = data1;
              X_set(datasize, t2) = data2
          }
      },
      _ => ()
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_gen_aarch64_instrs_memory_pair_general_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stp_gen_aarch64_instrs_memory_pair_general_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_gen_aarch64_instrs_memory_pair_general_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldpsw_aarch64_instrs_memory_pair_general_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldpsw_aarch64_instrs_memory_pair_general_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldpsw_aarch64_instrs_memory_pair_general_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_gen_aarch64_instrs_memory_pair_general_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldp_gen_aarch64_instrs_memory_pair_general_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_NORMAL;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if (L @ [opc[0]]) == 0b01 | opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = [opc[0]] != 0b0;
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_post_idx(acctype, datasize, memop, n, offset, postindex, is_signed, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_gen_aarch64_instrs_memory_pair_general_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_memory_exclusive_single : forall 'datasize 'elsize 'n ('pair : Bool) 'regsize 's 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'elsize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128}).
  (AccType, int('datasize), int('elsize), MemOp, int('n), bool('pair), int('regsize), int('s), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_exclusive_single (acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2) = {
    iswrite : bool = undefined;
    secondstage : bool = undefined;
    data : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_NONE => {
                  rt_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        } else ();
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_NONE => {
                  rn_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        } else ()
    } else ();
    base : VirtualAddress = undefined;
    if rn_unknown then {
        base = __UNKNOWN_VirtualAddress()
    } else {
        base = BaseReg_read__1(n)
    };
    let address : bits(64) = VAddress(base);
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else if pair then {
              assert(constraint((div('datasize, 2) == 8 | div('datasize, 2) == 16 | div('datasize, 2) == 32 | div('datasize, 2) == 64)));
              let el1 : bits(div('datasize, 2)) = X_read(DIV(datasize, 2), t);
              let el2 : bits(div('datasize, 2)) = X_read(DIV(datasize, 2), t2);
              data = if BigEndian() then el1 @ el2 else el2 @ el1
          } else {
              assert(constraint('datasize in {8, 16, 32, 64}));
              data = X_read(datasize, t)
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              Mem_set(address, dbytes, acctype) = data;
              status = ExclusiveMonitorsStatus()
          } else ();
          X_set(32, s) = ZeroExtend(status, 32)
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  assert(constraint('datasize in {32, 64}));
                  X_set(datasize, t) = __UNKNOWN_bits(datasize)
              } else if elsize == 32 then {
                  let data : bits('datasize) = Mem_read(address, dbytes, acctype);
                  if BigEndian() then {
                      assert(constraint('elsize <= 'datasize - 1));
                      assert(constraint((0 + ('datasize - 1 - 'elsize + 1) == 32 | 0 + ('datasize - 1 - 'elsize + 1) == 64)));
                      X_set(0 + (datasize - 1 - elsize + 1), t) = data[datasize - 1 .. elsize];
                      X_set(0 + (elsize - 1 - 0 + 1), t2) = data[elsize - 1 .. 0]
                  } else {
                      assert(constraint('elsize - 1 < 'datasize));
                      X_set(0 + (elsize - 1 - 0 + 1), t) = data[elsize - 1 .. 0];
                      assert(constraint('elsize <= 'datasize - 1));
                      assert(constraint((0 + ('datasize - 1 - 'elsize + 1) == 32 | 0 + ('datasize - 1 - 'elsize + 1) == 64)));
                      X_set(0 + (datasize - 1 - elsize + 1), t2) = data[datasize - 1 .. elsize]
                  }
              } else {
                  if address != Align(address, dbytes) then {
                      let iswrite : bool = false;
                      let secondstage : bool = false;
                      AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
                  } else ();
                  X_set(8 * 8, t) = Mem_read(address + 0, 8, acctype);
                  X_set(8 * 8, t2) = Mem_read(address + 8, 8, acctype)
              }
          } else {
              let data : bits('datasize) = Mem_read(address, dbytes, acctype);
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      _ => ()
    }
}

val decode_ldaxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldaxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldaxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlxrb_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlxrb_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlxrb_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlxrh_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlxrh_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlxrh_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stxr_aarch64_instrs_memory_exclusive_single : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stxr_aarch64_instrs_memory_exclusive_single (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = false;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_single(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stxr_aarch64_instrs_memory_exclusive_single(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val execute_aarch64_instrs_memory_atomicops_ld : forall 'datasize 'n 'regsize 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), AccType, int('n), MemAtomicOp, int('regsize), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_atomicops_ld (datasize, ldacctype, n, op, regsize, s, stacctype, t) = {
    address : bits(64) = undefined;
    let value_name : bits('datasize) = X_read(datasize, s);
    let base : VirtualAddress = BaseReg_read__1(n);
    let data : bits('datasize) = MemAtomic(base, op, value_name, ldacctype, stacctype);
    if t != 31 then {
        assert(constraint('regsize >= 'datasize));
        X_set(regsize, t) = ZeroExtend(data, regsize)
    } else ()
}

val decode_ldsmax_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsmax_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmax_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsminh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsminh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsminh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldseth_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldseth_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldseth_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldeorb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldeorb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldeorb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldset_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldset_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldset_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldaddb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaddb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldaddb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldeorh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldeorh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldeorh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsetb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsetb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsetb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_lduminh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_lduminh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_lduminh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmin_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsmin_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmin_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumaxh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldumaxh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumaxh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldclrh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldclrh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldclrh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldeor_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldeor_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldeor_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumax_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldumax_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumax_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumin_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldumin_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumin_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldclr_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldclr_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldclr_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_lduminb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_lduminb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_lduminb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldadd_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldadd_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldadd_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldaddh_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaddh_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldaddh_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldclrb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldclrb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldclrb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldsminb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldsminb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldsminb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val decode_ldumaxb_aarch64_instrs_memory_atomicops_ld : (bits(5), bits(5), bits(3), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldumaxb_aarch64_instrs_memory_atomicops_ld (Rt, Rn, opc, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_ld(datasize, ldacctype, n, op, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_ldumaxb_aarch64_instrs_memory_atomicops_ld(Rt, Rn, opc, Rs, R, A, size)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift ('sub_op : Bool),
  ('shift in {0, 1, 2, 3, 4, 5, 6, 7} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), ExtendType, int('m), int('n), bool('setflags), int('shift), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (d, datasize, extend_type, m, n, setflags, shift, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = if n == 31 then SP_read(datasize) else X_read(datasize, n);
    operand2 : bits('datasize) = ExtendReg(datasize, m, extend_type, shift);
    nzcv : bits(4) = undefined;
    carry_in : bits(1) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    } else ();
    if d == 31 & not_bool(setflags) then {
        SP_set(datasize) = result
    } else {
        X_set(datasize, d) = result
    }
}

val decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg : (bits(5), bits(5), bits(3), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd, Rn, imm3, option_name, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = UInt(imm3);
    if shift > 4 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(d, datasize, extend_type, m, n, setflags, shift, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm3 = Slice(__opcode, 10, 3);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg(Rd, Rn, imm3, option_name, Rm, S, op, sf)
}

val execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (d, datasize, elements, esize, n, part, round, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize * 2) = V_read(datasize * 2, n);
    result : bits('datasize) = undefined;
    let 'round_const = if round then (1 << (shift - 1)) else 0;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = ((SInt(Elem_read(operand, e, 2 * esize)) + round_const) >> shift);
        let (__tup_0 : bits('esize), __tup_1 : bool) = UnsignedSatQ(element, esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    Vpart_set(datasize, d, part) = result
}

val decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (Rd, Rn, op, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(Rd, Rn, op, immb, immh)
}

val decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd (Rd, Rn, op, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd(Rd, Rn, op, immb, immh, Q)
}

val decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (Rd, Rn, op, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(Rd, Rn, op, immb, immh)
}

val decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd (Rd, Rn, op, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd(Rd, Rn, op, immb, immh, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (d, datasize, elements, esize, idxdsize, index, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    let operand3 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    let element2 : bits('esize) = Elem_read(operand2, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        if sub_op then {
            element1 = FPNeg(element1)
        } else ();
        result = Elem_set(result, e, esize, FPMulAdd(Elem_read(operand3, e, esize), element1, element2, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (Rd, Rn, H, o2, Rm, M, L) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(Rd, Rn, H, o2, Rm, M, L)
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd (Rd, Rn, H, o2, Rm, M, L, sz) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd(Rd, Rn, H, o2, Rm, M, L, sz)
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd (Rd, Rn, H, o2, Rm, M, L, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd(Rd, Rn, H, o2, Rm, M, L, Q)
}

val decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd (Rd, Rn, H, o2, Rm, M, L, sz, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd(Rd, Rn, H, o2, Rm, M, L, sz, Q)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (Rd, Rn, H, o2, Rm, M, L) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(Rd, Rn, H, o2, Rm, M, L)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd (Rd, Rn, H, o2, Rm, M, L, sz) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd(Rd, Rn, H, o2, Rm, M, L, sz)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd (Rd, Rn, H, o2, Rm, M, L, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd(Rd, Rn, H, o2, Rm, M, L, Q)
}

val decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd (Rd, Rn, H, o2, Rm, M, L, sz, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd(Rd, Rn, H, o2, Rm, M, L, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (d, datasize, elements, esize, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(2 * 'datasize) = V_read(2 * datasize, n);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, 2 * esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        result = Elem_set(result, e, 2 * esize, sum[2 * esize - 1 .. 0])
    };
    V_set(2 * datasize, d) = result
}

val decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_right_narrow_logical : forall 'd 'datasize 'elements 'esize 'n 'part ('round : Bool) 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_right_narrow_logical (d, datasize, elements, esize, n, part, round, shift) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize * 2) = V_read(datasize * 2, n);
    result : bits('datasize) = undefined;
    let 'round_const = if round then (1 << (shift - 1)) else 0;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = ((UInt(Elem_read(operand, e, 2 * esize)) + round_const) >> shift);
        result = Elem_set(result, e, esize, element[esize - 1 .. 0])
    };
    Vpart_set(datasize, d, part) = result
}

val decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical (Rd, Rn, op, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_logical(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical(Rd, Rn, op, immb, immh, Q)
}

val decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical (Rd, Rn, op, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_logical(d, datasize, elements, esize, n, part, round, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical(Rd, Rn, op, immb, immh, Q)
}

val execute_aarch64_instrs_memory_atomicops_cas_single : forall 'datasize 'n 'regsize 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_atomicops_cas_single (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    let comparevalue : bits('datasize) = X_read(datasize, s);
    let newvalue : bits('datasize) = X_read(datasize, t);
    let base : VirtualAddress = BaseReg_read__1(n);
    let data : bits('datasize) = MemAtomicCompareAndSwap(base, comparevalue, newvalue, ldacctype, stacctype);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, s) = ZeroExtend(data, regsize)
}

val decode_cas_aarch64_instrs_memory_atomicops_cas_single : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_cas_aarch64_instrs_memory_atomicops_cas_single (Rt, Rn, o0, Rs, L, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_cas_single(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_cas_aarch64_instrs_memory_atomicops_cas_single(Rt, Rn, o0, Rs, L, size)
}

val decode_casb_aarch64_instrs_memory_atomicops_cas_single : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_casb_aarch64_instrs_memory_atomicops_cas_single (Rt, Rn, o0, Rs, L, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_cas_single(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_casb_aarch64_instrs_memory_atomicops_cas_single(Rt, Rn, o0, Rs, L, size)
}

val decode_cash_aarch64_instrs_memory_atomicops_cas_single : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_cash_aarch64_instrs_memory_atomicops_cas_single (Rt, Rn, o0, Rs, L, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_cas_single(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    decode_cash_aarch64_instrs_memory_atomicops_cas_single(Rt, Rn, o0, Rs, L, size)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff : forall ('accumulate : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (bool('accumulate), int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff (accumulate, d, datasize, elements, esize, m, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    element1 : int = undefined;
    element2 : int = undefined;
    absdiff : bits(2 * 'esize) = undefined;
    result : bits(2 * 'datasize) = if accumulate then V_read(2 * datasize, d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        absdiff = Abs(element1 - element2)[2 * esize - 1 .. 0];
        result = Elem_set(result, e, 2 * esize, Elem_read(result, e, 2 * esize) + absdiff)
    };
    V_set(2 * datasize, d) = result
}

val decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd, Rn, op, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let accumulate : bool = op == 0b0;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff(accumulate, d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff(Rd, Rn, op, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm ('mulx_op : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), bool('mulx_op), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (d, datasize, elements, esize, idxdsize, index, m, mulx_op, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    let element2 : bits('esize) = Elem_read(operand2, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        if mulx_op then {
            result = Elem_set(result, e, esize, FPMulX(element1, element2, FPCR))
        } else {
            result = Elem_set(result, e, esize, FPMul(element1, element2, FPCR))
        }
    };
    V_set(datasize, d) = result
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (Rd, Rn, H, Rm, M, L, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(Rd, Rn, H, Rm, M, L, U)
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd (Rd, Rn, H, Rm, M, L, sz, U) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd(Rd, Rn, H, Rm, M, L, sz, U)
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd (Rd, Rn, H, Rm, M, L, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd(Rd, Rn, H, Rm, M, L, U, Q)
}

val decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd (Rd, Rn, H, Rm, M, L, sz, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd(Rd, Rn, H, Rm, M, L, sz, U, Q)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (Rd, Rn, H, Rm, M, L, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(Rd, Rn, H, Rm, M, L, U)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd (Rd, Rn, H, Rm, M, L, sz, U) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd(Rd, Rn, H, Rm, M, L, sz, U)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd (Rd, Rn, H, Rm, M, L, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'd = UInt(Rd);
    let 'index = UInt((H @ L) @ M);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd(Rd, Rn, H, Rm, M, L, U, Q)
}

val decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd (Rd, Rn, H, Rm, M, L, sz, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 3) = undefined;
    let Rmhi : bits(1) = M;
    match sz @ L {
      [bitzero, _] => {
          index = UInt(H @ L)
      },
      0b10 => {
          index = UInt(H)
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let mulx_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd(d, datasize, elements, esize, idxdsize, index, m, mulx_op, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd(Rd, Rn, H, Rm, M, L, sz, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd : forall ('and_test : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('and_test), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (and_test, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if and_test then {
            test_passed = not_bool(IsZero(element1 & element2))
        } else {
            test_passed = element1 == element2
        };
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(Rd, Rn, Rm, size, U)
}

val decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(Rd, Rn, Rm, size, U)
}

val decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let and_test : bool = U == 0b0;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd(and_test, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        result = Elem_set(result, e, esize, (element1 + element2 + 1)[esize .. 1])
    };
    V_set(datasize, d) = result
}

val decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(Rd, Rn, Rm, size, U, Q)
}

val decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : forall ('cmp_eq : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('cmp_eq), int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (cmp_eq, d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd, Rn, eq, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(Rd, Rn, eq, Rm, size, U)
}

val decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd, Rn, eq, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let cmp_eq : bool = eq == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd(cmp_eq, d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let eq = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd(Rd, Rn, eq, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : forall 'd 'datasize ('invert : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('invert), int('m), int('n), LogicalOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (d, datasize, invert, m, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    if invert then {
        operand2 = not_vec(operand2)
    } else ();
    match op {
      LogicalOp_AND => {
          result = operand1 & operand2
      },
      LogicalOp_ORR => {
          result = operand1 | operand2
      },
      _ => ()
    };
    V_set(datasize, d) = result
}

val decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let invert : bool = [size[0]] == 0b1;
    let op : LogicalOp = if [size[1]] == 0b1 then LogicalOp_ORR else LogicalOp_AND;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(d, datasize, invert, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_integer_arithmetic_rev : forall 'container_size 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31 & 'container_size in {16, 32, 64}).
  (int('container_size), int('d), int('datasize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_rev (container_size, d, datasize, n) = {
    let operand : bits('datasize) = X_read(datasize, n);
    result : bits('datasize) = undefined;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, 8);
    index : int = 0;
    rev_index : int = undefined;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_index = index + (elements_per_container - 1) * 8;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            let 'rev_index = rev_index in
              {
                  let 'index = index;
                  assert(constraint((0 <= 'rev_index & 'rev_index + 7 < 'datasize)));
                  assert(constraint((0 <= 'index & 'index + 7 < 'datasize)));
                  result[rev_index + 7 .. rev_index] = operand[index + 7 .. index]
              };
            index = index + 8;
            rev_index = rev_index - 8
        }
    };
    X_set(datasize, d) = result
}

val decode_rev16_int_aarch64_instrs_integer_arithmetic_rev : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rev16_int_aarch64_instrs_integer_arithmetic_rev (Rd, Rn, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : {|16, 32, 64|} = 16;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          } else ();
          container_size = 64
      }
    };
    let 'container_size = container_size;
    execute_aarch64_instrs_integer_arithmetic_rev(container_size, d, datasize, n)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 10, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_rev16_int_aarch64_instrs_integer_arithmetic_rev(Rd, Rn, opc, sf)
}

val decode_rev32_int_aarch64_instrs_integer_arithmetic_rev : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rev32_int_aarch64_instrs_integer_arithmetic_rev (Rd, Rn, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : {|16, 32, 64|} = 16;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          } else ();
          container_size = 64
      }
    };
    let 'container_size = container_size;
    execute_aarch64_instrs_integer_arithmetic_rev(container_size, d, datasize, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 10, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_rev32_int_aarch64_instrs_integer_arithmetic_rev(Rd, Rn, opc, sf)
}

val decode_rev_aarch64_instrs_integer_arithmetic_rev : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rev_aarch64_instrs_integer_arithmetic_rev (Rd, Rn, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    container_size : {|16, 32, 64|} = 16;
    match opc {
      0b00 => {
          Unreachable()
      },
      0b01 => {
          container_size = 16
      },
      0b10 => {
          container_size = 32
      },
      0b11 => {
          if sf == 0b0 then {
              throw(Error_Undefined())
          } else ();
          container_size = 64
      }
    };
    let 'container_size = container_size;
    execute_aarch64_instrs_integer_arithmetic_rev(container_size, d, datasize, n)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 10, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_rev_aarch64_instrs_integer_arithmetic_rev(Rd, Rn, opc, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (d, datasize, elements, esize, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    let operand3 : bits(2 * 'datasize) = V_read(2 * datasize, d);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    accum : int = undefined;
    sat1 : bool = undefined;
    sat2 : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
        if sub_op then {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) - SInt(product)
        } else {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) + SInt(product)
        };
        let (__tup_0 : bits(2 * 'esize), __tup_1 : bool) = SignedSatQ(accum, 2 * esize) in
          {
              result = Elem_set(result, e, 2 * esize, __tup_0);
              sat2 = __tup_1
          };
        if sat1 | sat2 then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(2 * datasize, d) = result
}

val decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (Rd, Rn, o1, Rm, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(Rd, Rn, o1, Rm, size)
}

val decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd (Rd, Rn, o1, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd(Rd, Rn, o1, Rm, size, Q)
}

val decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (Rd, Rn, o1, Rm, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(Rd, Rn, o1, Rm, size)
}

val decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd (Rd, Rn, o1, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd(d, datasize, elements, esize, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd(Rd, Rn, o1, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('pair : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('pair)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (d, datasize, elements, esize, m, minimum, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            element1 = Elem_read(concat, 2 * e, esize);
            element2 = Elem_read(concat, 2 * e + 1, esize)
        } else {
            element1 = Elem_read(operand1, e, esize);
            element2 = Elem_read(operand2, e, esize)
        };
        if minimum then {
            result = Elem_set(result, e, esize, FPMinNum(element1, element2, FPCR))
        } else {
            result = Elem_set(result, e, esize, FPMaxNum(element1, element2, FPCR))
        }
    };
    V_set(datasize, d) = result
}

val decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd, Rn, Rm, a, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(Rd, Rn, Rm, a, U, Q)
}

val decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008(Rd, Rn, Rm, sz, o1, U, Q)
}

val execute_aarch64_instrs_system_hints : SystemHintOp -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_hints op = {
    match op {
      SystemHintOp_YIELD => {
          Hint_Yield()
      },
      SystemHintOp_WFE => {
          if IsEventRegisterSet() then {
              ClearEventRegister()
          } else {
              if PSTATE.EL == EL0 then {
                  AArch64_CheckForWFxTrap(EL1, true)
              } else ();
              if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(IsInHost()) then {
                  AArch64_CheckForWFxTrap(EL2, true)
              } else ();
              if HaveEL(EL3) & PSTATE.EL != EL3 then {
                  AArch64_CheckForWFxTrap(EL3, true)
              } else ();
              WaitForEvent()
          }
      },
      SystemHintOp_WFI => {
          if not_bool(InterruptPending()) then {
              if PSTATE.EL == EL0 then {
                  AArch64_CheckForWFxTrap(EL1, false)
              } else ();
              if ((PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled()) & not_bool(IsInHost()) then {
                  AArch64_CheckForWFxTrap(EL2, false)
              } else ();
              if HaveEL(EL3) & PSTATE.EL != EL3 then {
                  AArch64_CheckForWFxTrap(EL3, false)
              } else ();
              WaitForInterrupt()
          } else ()
      },
      SystemHintOp_SEV => {
          SendEvent()
      },
      SystemHintOp_SEVL => {
          SendEventLocal()
      },
      SystemHintOp_ESB => {
          SynchronizeErrors();
          AArch64_ESBOperation();
          if (PSTATE.EL == EL0 | PSTATE.EL == EL1) & EL2Enabled() then {
              AArch64_vESBOperation()
          } else ();
          TakeUnmaskedSErrorInterrupts()
      },
      SystemHintOp_PSB => {
          ProfilingSynchronizationBarrier()
      },
      SystemHintOp_CSDB => {
          ConsumptionOfSpeculativeDataBarrier()
      },
      _ => ()
    }
}

val decode_wfe_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_wfe_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010000001011111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_wfe_aarch64_instrs_system_hints(op2, CRm)
}

val decode_wfi_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_wfi_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010000001111111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_wfi_aarch64_instrs_system_hints(op2, CRm)
}

val decode_hint_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_hint_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_hint_aarch64_instrs_system_hints(op2, CRm)
}

val decode_nop_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_nop_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010000000011111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_nop_aarch64_instrs_system_hints(op2, CRm)
}

val decode_sevl_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_sevl_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010000010111111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_sevl_aarch64_instrs_system_hints(op2, CRm)
}

val decode_sev_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_sev_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010000010011111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_sev_aarch64_instrs_system_hints(op2, CRm)
}

val decode_esb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_esb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010001000011111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_esb_aarch64_instrs_system_hints(op2, CRm)
}

val decode_yield_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_yield_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010000000111111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_yield_aarch64_instrs_system_hints(op2, CRm)
}

val decode_psb_aarch64_instrs_system_hints : (bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_psb_aarch64_instrs_system_hints (op2, CRm) = {
    op : SystemHintOp = undefined;
    match CRm @ op2 {
      0b0000000 => {
          op = SystemHintOp_NOP
      },
      0b0000001 => {
          op = SystemHintOp_YIELD
      },
      0b0000010 => {
          op = SystemHintOp_WFE
      },
      0b0000011 => {
          op = SystemHintOp_WFI
      },
      0b0000100 => {
          op = SystemHintOp_SEV
      },
      0b0000101 => {
          op = SystemHintOp_SEVL
      },
      0b0010000 => {
          if not_bool(HaveRASExt()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_ESB
      },
      0b0010001 => {
          if not_bool(HaveStatisticalProfiling()) then {
              EndOfInstruction()
          } else ();
          op = SystemHintOp_PSB
      },
      0b0010100 => {
          op = SystemHintOp_CSDB
      },
      _ => {
          EndOfInstruction()
      }
    };
    execute_aarch64_instrs_system_hints(op)
}

function clause __DecodeA64 (pc, (0b11010101000000110010001000111111 as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    decode_psb_aarch64_instrs_system_hints(op2, CRm)
}

val execute_aarch64_instrs_branch_unconditional_eret : unit -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_unconditional_eret () = {
    target : bits(129) = undefined;
    if IsAccessToCapabilitiesEnabledAtEL(PSTATE.EL) then {
        target = CELR_read__1()
    } else {
        target = CapSetValue(PCC_read(), ELR_read__1())
    };
    AArch64_ExceptionReturnToCapability(target, SPSR_read())
}

val decode_eret_aarch64_instrs_branch_unconditional_eret : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_eret_aarch64_instrs_branch_unconditional_eret (op4, Rn, M, A) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_branch_unconditional_eret()
}

function clause __DecodeA64 (pc, (0b11010110100111110000001111100000 as __opcode)) = {
    let op4 = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    decode_eret_aarch64_instrs_branch_unconditional_eret(op4, Rn, M, A)
}

val decode_ereta_aarch64_instrs_branch_unconditional_eret : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ereta_aarch64_instrs_branch_unconditional_eret (op4, Rn, M, A) = {
    if PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_branch_unconditional_eret()
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let op4 = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    decode_ereta_aarch64_instrs_branch_unconditional_eret(op4, Rn, M, A)
}

val execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd(Rd, Rn, o1, Q)
}

val decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd(Rd, Rn, sz, o1, Q)
}

val decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd(Rd, Rn, o1, Q)
}

val decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd(Rd, Rn, sz, o1, Q)
}

val execute_aarch64_instrs_float_arithmetic_max_min : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), FPMaxMinOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_max_min (d, datasize, m, n, operation) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    match operation {
      FPMaxMinOp_MAX => {
          result = FPMax(operand1, operand2, FPCR)
      },
      FPMaxMinOp_MIN => {
          result = FPMin(operand1, operand2, FPCR)
      },
      FPMaxMinOp_MAXNUM => {
          result = FPMaxNum(operand1, operand2, FPCR)
      },
      FPMaxMinOp_MINNUM => {
          result = FPMinNum(operand1, operand2, FPCR)
      }
    };
    let result = result;
    V_set(datasize, d) = result
}

val decode_fmax_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmax_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, datasize, m, n, operation)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmax_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, datasize, m, n, operation)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val decode_fmin_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmin_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, datasize, m, n, operation)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmin_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min : (bits(5), bits(5), bits(2), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    operation : FPMaxMinOp = undefined;
    match op {
      0b00 => {
          operation = FPMaxMinOp_MAX
      },
      0b01 => {
          operation = FPMaxMinOp_MIN
      },
      0b10 => {
          operation = FPMaxMinOp_MAXNUM
      },
      0b11 => {
          operation = FPMaxMinOp_MINNUM
      }
    };
    let operation = operation;
    execute_aarch64_instrs_float_arithmetic_max_min(d, datasize, m, n, operation)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min(Rd, Rn, op, Rm, ftype)
}

val execute_aarch64_instrs_integer_bitfield : forall 'R 'S 'd 'datasize ('extend : Bool) ('inzero : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'S & 'S <= 63 & 0 <= 'R & 'R <= 63).
  (int('R), int('S), int('d), int('datasize), bool('extend), bool('inzero), int('n), bits('datasize), bits('datasize)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_bitfield (R, S, d, datasize, extend, inzero, n, tmask, wmask) = {
    let dst : bits('datasize) = if inzero then Zeros() else X_read(datasize, d);
    let src : bits('datasize) = X_read(datasize, n);
    let bot : bits('datasize) = dst & not_vec(wmask) | ROR(src, R) & wmask;
    assert(constraint('S < 'datasize));
    let top : bits('datasize) = if extend then Replicate([src[S]]) else dst;
    X_set(datasize, d) = top & not_vec(tmask) | bot & tmask
}

val decode_sbfm_aarch64_instrs_integer_bitfield : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sbfm_aarch64_instrs_integer_bitfield (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined;
    extend : bool = undefined;
    wmask : bits('datasize) = undefined;
    tmask : bits('datasize) = undefined;
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    } else ();
    let 'R = UInt(immr);
    let 'S = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(datasize, N, imms, immr, false);
    execute_aarch64_instrs_integer_bitfield(R, S, d, datasize, extend, inzero, n, tmask, wmask)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_sbfm_aarch64_instrs_integer_bitfield(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_ubfm_aarch64_instrs_integer_bitfield : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ubfm_aarch64_instrs_integer_bitfield (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined;
    extend : bool = undefined;
    wmask : bits('datasize) = undefined;
    tmask : bits('datasize) = undefined;
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    } else ();
    let 'R = UInt(immr);
    let 'S = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(datasize, N, imms, immr, false);
    execute_aarch64_instrs_integer_bitfield(R, S, d, datasize, extend, inzero, n, tmask, wmask)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ubfm_aarch64_instrs_integer_bitfield(Rd, Rn, imms, immr, N, opc, sf)
}

val decode_bfm_aarch64_instrs_integer_bitfield : (bits(5), bits(5), bits(6), bits(6), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bfm_aarch64_instrs_integer_bitfield (Rd, Rn, imms, immr, N, opc, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    inzero : bool = undefined;
    extend : bool = undefined;
    wmask : bits('datasize) = undefined;
    tmask : bits('datasize) = undefined;
    match opc {
      0b00 => {
          inzero = true;
          extend = true
      },
      0b01 => {
          inzero = false;
          extend = false
      },
      0b10 => {
          inzero = true;
          extend = false
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let extend = extend;
    let inzero = inzero;
    if sf == 0b1 & N != 0b1 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & ((N != 0b0 | [immr[5]] != 0b0) | [imms[5]] != 0b0) then {
        throw(Error_Undefined())
    } else ();
    let 'R = UInt(immr);
    let 'S = UInt(imms);
    (wmask, tmask) = DecodeBitMasks(datasize, N, imms, immr, false);
    execute_aarch64_instrs_integer_bitfield(R, S, d, datasize, extend, inzero, n, tmask, wmask)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let immr = Slice(__opcode, 16, 6);
    let N = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_bfm_aarch64_instrs_integer_bitfield(Rd, Rn, imms, immr, N, opc, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_rev : forall 'containers 'd 'datasize 'elements_per_container 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('containers), int('d), int('datasize), int('elements_per_container), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_rev (containers, d, datasize, elements_per_container, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : int = 0;
    rev_element : int = undefined;
    foreach (c from 0 to (containers - 1) by 1 in inc) {
        rev_element = element + elements_per_container - 1;
        foreach (e from 0 to (elements_per_container - 1) by 1 in inc) {
            let 'rev_element = rev_element in
              {
                  let 'element = element;
                  result = Elem_set(result, rev_element, esize, Elem_read(operand, element, esize))
              };
            element = element + 1;
            rev_element = rev_element - 1
        }
    };
    V_set(datasize, d) = result
}

val decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd, Rn, o0, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let op : bits(2) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    } else ();
    container_size : {|16, 32, 64|} = 16;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      },
      _ => ()
    };
    let 'container_size = container_size;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev(Rd, Rn, o0, size, U, Q)
}

val decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd, Rn, o0, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let op : bits(2) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    } else ();
    container_size : {|16, 32, 64|} = 16;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      },
      _ => ()
    };
    let 'container_size = container_size;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev(Rd, Rn, o0, size, U, Q)
}

val decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd, Rn, o0, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let op : bits(2) = o0 @ U;
    if UInt(op) + UInt(size) >= 3 then {
        throw(Error_Undefined())
    } else ();
    container_size : {|16, 32, 64|} = 16;
    match op {
      0b10 => {
          container_size = 16
      },
      0b01 => {
          container_size = 32
      },
      0b00 => {
          container_size = 64
      },
      _ => ()
    };
    let 'container_size = container_size;
    let 'containers = DIV(datasize, container_size);
    let 'elements_per_container = DIV(container_size, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_rev(containers, d, datasize, elements_per_container, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o0 = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev(Rd, Rn, o0, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    let operand3 : bits(2 * 'datasize) = V_read(2 * datasize, d);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    accum : int = undefined;
    sat1 : bool = undefined;
    sat2 : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        (product, sat1) = SignedSatQ(2 * element1 * element2, 2 * esize);
        if sub_op then {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) - SInt(product)
        } else {
            accum = SInt(Elem_read(operand3, e, 2 * esize)) + SInt(product)
        };
        let (__tup_0 : bits(2 * 'esize), __tup_1 : bool) = SignedSatQ(accum, 2 * esize) in
          {
              result = Elem_set(result, e, 2 * esize, __tup_0);
              sat2 = __tup_1
          };
        if sat1 | sat2 then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(2 * datasize, d) = result
}

val decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (Rd, Rn, H, o2, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(Rd, Rn, H, o2, Rm, M, L, size)
}

val decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (Rd, Rn, H, o2, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(Rd, Rn, H, o2, Rm, M, L, size)
}

val decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_carry : forall 'd 'datasize 'm 'n ('setflags : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_add_sub_carry (d, datasize, m, n, setflags, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(datasize, n);
    operand2 : bits('datasize) = X_read(datasize, m);
    nzcv : bits(4) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2)
    } else ();
    (result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    } else ();
    X_set(datasize, d) = result
}

val decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd, Rn, Rm, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    execute_aarch64_instrs_integer_arithmetic_add_sub_carry(d, datasize, m, n, setflags, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry(Rd, Rn, Rm, S, op, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : forall 'd 'datasize 'elements 'esize 'm ('minimum : Bool) 'n ('pair : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('pair)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (d, datasize, elements, esize, m, minimum, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            element1 = Elem_read(concat, 2 * e, esize);
            element2 = Elem_read(concat, 2 * e + 1, esize)
        } else {
            element1 = Elem_read(operand1, e, esize);
            element2 = Elem_read(operand2, e, esize)
        };
        if minimum then {
            result = Elem_set(result, e, esize, FPMin(element1, element2, FPCR))
        } else {
            result = Elem_set(result, e, esize, FPMax(element1, element2, FPCR))
        }
    };
    V_set(datasize, d) = result
}

val decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd, Rn, Rm, o1, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(Rd, Rn, Rm, o1, U, Q)
}

val decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd, Rn, Rm, sz, o1, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985(d, datasize, elements, esize, m, minimum, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985(Rd, Rn, Rm, sz, o1, U, Q)
}

val execute_aarch64_instrs_vector_reduce_int_max : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) ('min : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), bool('min), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_int_max (d, datasize, elements, esize, min, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    element : int = undefined;
    maxmin : int = asl_Int(Elem_read(operand, 0, esize), is_unsigned);
    foreach (e from 1 to (elements - 1) by 1 in inc) {
        element = asl_Int(Elem_read(operand, e, esize), is_unsigned);
        maxmin = if min then Min(maxmin, element) else Max(maxmin, element)
    };
    let 'maxmin = maxmin;
    V_set(0 + (esize - 1 - 0 + 1), d) = maxmin[esize - 1 .. 0]
}

val decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let min : bool = op == 0b1;
    execute_aarch64_instrs_vector_reduce_int_max(d, datasize, elements, esize, min, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 16, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max(Rd, Rn, op, size, U, Q)
}

val execute_aarch64_instrs_integer_arithmetic_rbit : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_rbit (d, datasize, n) = {
    let operand : bits('datasize) = X_read(datasize, n);
    result : bits('datasize) = undefined;
    foreach (i from 0 to (datasize - 1) by 1 in inc) {
        result[datasize - 1 - i] = Bit([operand[i]])
    };
    X_set(datasize, d) = result
}

val decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit (Rd, Rn, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    execute_aarch64_instrs_integer_arithmetic_rbit(d, datasize, n)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit(Rd, Rn, sf)
}

val execute_aarch64_instrs_float_compare_cond : forall 'datasize 'm 'n ('signal_all_nans : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64}).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('signal_all_nans)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_compare_cond (condition, datasize, flags__arg, m, n, signal_all_nans) = {
    flags : bits(4) = flags__arg;
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    if ConditionHolds(condition) then {
        flags = FPCompare(operand1, operand2, signal_all_nans, FPCR)
    } else ();
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val decode_fccmpe_float_aarch64_instrs_float_compare_cond : (bits(4), bits(1), bits(5), bits(4), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fccmpe_float_aarch64_instrs_float_compare_cond (nzcv, op, Rn, cond, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_float_compare_cond(condition, datasize, flags, m, n, signal_all_nans)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _] as __opcode)) = {
    let nzcv = Slice(__opcode, 0, 4);
    let op = Slice(__opcode, 4, 1);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fccmpe_float_aarch64_instrs_float_compare_cond(nzcv, op, Rn, cond, Rm, ftype)
}

val decode_fccmp_float_aarch64_instrs_float_compare_cond : (bits(4), bits(1), bits(5), bits(4), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fccmp_float_aarch64_instrs_float_compare_cond (nzcv, op, Rn, cond, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_float_compare_cond(condition, datasize, flags, m, n, signal_all_nans)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) = {
    let nzcv = Slice(__opcode, 0, 4);
    let op = Slice(__opcode, 4, 1);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fccmp_float_aarch64_instrs_float_compare_cond(nzcv, op, Rn, cond, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    let operand3 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    product : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        product = (UInt(element1) * UInt(element2))[esize - 1 .. 0];
        if sub_op then {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) - product)
        } else {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) + product)
        }
    };
    V_set(datasize, d) = result
}

val decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(Rd, Rn, Rm, size, U, Q)
}

val decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_transfer_vector_insert : forall 'd 'dst_index 'esize 'idxdsize 'n 'src_index,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64, 128, 256} & 0 <= 'd & 'd <= 31).
  (int('d), int('dst_index), int('esize), int('idxdsize), int('n), int('src_index)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_insert (d, dst_index, esize, idxdsize, n, src_index) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V_read(idxdsize, n);
    result : bits(128) = V_read(128, d);
    result = Elem_set(result, dst_index, esize, Elem_read(operand, src_index, esize));
    V_set(128, d) = result
}

val decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert : (bits(5), bits(5), bits(4), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert (Rd, Rn, imm4, imm5) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    } else ();
    assert(constraint(0 <= 'size + 1));
    let 'dst_index = UInt(imm5[4 .. size + 1]);
    assert(constraint(0 <= 'size));
    let 'src_index = UInt(imm4[3 .. size]);
    let 'idxdsize = if [imm4[3]] == 0b1 then 128 else 64;
    let 'esize = (8 << size);
    match esize {
      8 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 8, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 8, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      16 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 16, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 16, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      32 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 32, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 32, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      64 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 64, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 64, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      128 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 128, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 128, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      256 => {
          match idxdsize {
            64 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 256, 64, n, src_index)
            },
            128 => {
                execute_aarch64_instrs_vector_transfer_vector_insert(d, dst_index, 256, 128, n, src_index)
            },
            _ => {
                assert(false)
            }
          }
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm4 = Slice(__opcode, 11, 4);
    let imm5 = Slice(__opcode, 16, 5);
    decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert(Rd, Rn, imm4, imm5)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    result : bits(2 * 'datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, 2 * esize, PolynomialMult(element1, element2))
    };
    V_set(2 * datasize, d) = result
}

val decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b01 | size == 0b10 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 & not_bool(HaveBit128PMULLExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_memory_single_general_register : forall 'datasize ('is_signed : Bool) 'm 'n ('postindex : Bool) 'regsize 'shift 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'shift in {0, 1, 2, 3} & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), ExtendType, int('m), MemOp, int('n), bool('postindex), int('regsize), int('shift), bool('is_signed), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_general_register (acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback__arg) = {
    wback : bool = wback__arg;
    c : Constraint = undefined;
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    data : bits('datasize) = undefined;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read(n, memop == MemOp_PREFETCH);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(datasize, t)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          } else ();
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          } else ();
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          if is_signed then {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = SignExtend(data, regsize)
          } else {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          let address : bits(64) = VAddress(base);
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_prfm_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_prfm_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_prfm_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_str_reg_gen_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_reg_gen_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_reg_gen_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrsw_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsw_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrb_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrb_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrsb_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsb_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_strb_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strb_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_strh_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strh_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrh_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrh_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldrsh_reg_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsh_reg_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_reg_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_register(acctype, datasize, extend_type, m, memop, n, postindex, regsize, shift, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val execute_aarch64_instrs_vector_reduce_fp16_max_simd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_fp16_max_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd(Rd, Rn, o1, Q)
}

val decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd(Rd, Rn, sz, o1, Q)
}

val decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd (Rd, Rn, o1, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd(Rd, Rn, o1, Q)
}

val decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd (Rd, Rn, sz, o1, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) != 0b01 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd(Rd, Rn, sz, o1, Q)
}

val execute_aarch64_instrs_float_arithmetic_mul_product : forall 'd 'datasize 'm 'n ('negated : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('negated)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_mul_product (d, datasize, m, n, negated) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = FPMul(operand1, operand2, FPCR);
    if negated then {
        result = FPNeg(result)
    } else ();
    V_set(datasize, d) = result
}

val decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let negated : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_mul_product(d, datasize, m, n, negated)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product(Rd, Rn, op, Rm, ftype)
}

val decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let negated : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_mul_product(d, datasize, m, n, negated)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product(Rd, Rn, op, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        if neg then {
            element = negate(element)
        } else {
            element = Abs(element)
        };
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ(element, esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(Rd, Rn, size, U)
}

val decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd(Rd, Rn, size, U, Q)
}

val decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(Rd, Rn, size, U)
}

val decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_dotp : forall 'd 'datasize 'elements 'esize 'index ('is_signed : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('index), int('m), int('n), bool('is_signed)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_dotp (d, datasize, elements, esize, index, m, n, is_signed) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits(128) = V_read(128, m);
    result : bits('datasize) = V_read(datasize, d);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        res : int = 0;
        element1 : int = undefined;
        element2 : int = undefined;
        foreach (i from 0 to 3 by 1 in inc) {
            if is_signed then {
                element1 = SInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = SInt(Elem_read(operand2, 4 * index + i, DIV(esize, 4)))
            } else {
                element1 = UInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = UInt(Elem_read(operand2, 4 * index + i, DIV(esize, 4)))
            };
            res = res + element1 * element2
        };
        let 'res = res;
        result = Elem_set(result, e, esize, Elem_read(result, e, esize) + res)
    };
    V_set(datasize, d) = result
}

val decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    } else ();
    if size != 0b10 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'index = UInt(H @ L);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_dotp(d, datasize, elements, esize, index, m, n, is_signed)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    } else ();
    if size != 0b10 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(M @ Rm);
    let 'index = UInt(H @ L);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_dotp(d, datasize, elements, esize, index, m, n, is_signed)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val execute_aarch64_instrs_float_compare_uncond : forall ('cmp_with_zero : Bool) 'datasize 'm 'n ('signal_all_nans : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64}).
  (bool('cmp_with_zero), int('datasize), int('m), int('n), bool('signal_all_nans)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_compare_uncond (cmp_with_zero, datasize, m, n, signal_all_nans) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = if cmp_with_zero then FPZero(datasize, 0b0) else V_read(datasize, m);
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = FPCompare(operand1, operand2, signal_all_nans, FPCR)
}

val decode_fcmpe_float_aarch64_instrs_float_compare_uncond : (bits(2), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmpe_float_aarch64_instrs_float_compare_uncond (opc, Rn, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = [opc[1]] == 0b1;
    let cmp_with_zero : bool = [opc[0]] == 0b1;
    execute_aarch64_instrs_float_compare_uncond(cmp_with_zero, datasize, m, n, signal_all_nans)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, _, bitzero, bitzero, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 3, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcmpe_float_aarch64_instrs_float_compare_uncond(opc, Rn, Rm, ftype)
}

val decode_fcmp_float_aarch64_instrs_float_compare_uncond : (bits(2), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmp_float_aarch64_instrs_float_compare_uncond (opc, Rn, Rm, ftype) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let signal_all_nans : bool = [opc[1]] == 0b1;
    let cmp_with_zero : bool = [opc[0]] == 0b1;
    execute_aarch64_instrs_float_compare_uncond(cmp_with_zero, datasize, m, n, signal_all_nans)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, bitzero, bitzero, bitzero] as __opcode)) = {
    let opc = Slice(__opcode, 3, 2);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcmp_float_aarch64_instrs_float_compare_uncond(opc, Rn, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), FPRounding, bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (d, datasize, elements, esize, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPToFixed(esize, element, 0, is_unsigned, FPCR, rounding))
    };
    V_set(datasize, d) = result
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd, Rn, o1, o2, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(Rd, Rn, o1, o2, U)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd, Rn, o1, sz, o2, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd(Rd, Rn, o1, sz, o2, U)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd(Rd, Rn, o1, o2, U, Q)
}

val decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPDecodeRounding(o1 @ o2);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd(Rd, Rn, o1, sz, o2, U, Q)
}

val execute_aarch64_instrs_integer_conditional_compare_immediate : forall 'datasize 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (bits(4), int('datasize), bits(4), bits('datasize), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_conditional_compare_immediate (condition, datasize, flags__arg, imm, n, sub_op) = {
    flags : bits(4) = flags__arg;
    let operand1 : bits('datasize) = X_read(datasize, n);
    operand2 : bits('datasize) = imm;
    carry_in : bits(1) = 0b0;
    if ConditionHolds(condition) then {
        if sub_op then {
            operand2 = not_vec(operand2);
            carry_in = 0b1
        } else ();
        let (_, __tup_1 : bits(4)) = AddWithCarry(operand1, operand2, carry_in);
        flags = __tup_1
    } else ();
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate (nzcv, Rn, cond, imm5, op, sf) = {
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    let imm : bits('datasize) = ZeroExtend(imm5, datasize);
    execute_aarch64_instrs_integer_conditional_compare_immediate(condition, datasize, flags, imm, n, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) = {
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let imm5 = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate(nzcv, Rn, cond, imm5, op, sf)
}

val decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate (nzcv, Rn, cond, imm5, op, sf) = {
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    let imm : bits('datasize) = ZeroExtend(imm5, datasize);
    execute_aarch64_instrs_integer_conditional_compare_immediate(condition, datasize, flags, imm, n, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) = {
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let imm5 = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate(nzcv, Rn, cond, imm5, op, sf)
}

val execute_aarch64_instrs_integer_arithmetic_div : forall 'd 'datasize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_div (d, datasize, m, n, is_unsigned) = {
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = X_read(datasize, m);
    result : int = undefined;
    if IsZero(operand2) then {
        result = 0
    } else {
        result = RoundTowardsZero(Real(asl_Int(operand1, is_unsigned)) / Real(asl_Int(operand2, is_unsigned)))
    };
    let 'result = result;
    X_set(0 + (datasize - 1 - 0 + 1), d) = result[datasize - 1 .. 0]
}

val decode_udiv_aarch64_instrs_integer_arithmetic_div : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_udiv_aarch64_instrs_integer_arithmetic_div (Rd, Rn, o1, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let is_unsigned : bool = o1 == 0b0;
    execute_aarch64_instrs_integer_arithmetic_div(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 10, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_udiv_aarch64_instrs_integer_arithmetic_div(Rd, Rn, o1, Rm, sf)
}

val decode_sdiv_aarch64_instrs_integer_arithmetic_div : (bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sdiv_aarch64_instrs_integer_arithmetic_div (Rd, Rn, o1, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let is_unsigned : bool = o1 == 0b0;
    execute_aarch64_instrs_integer_arithmetic_div(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 10, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_sdiv_aarch64_instrs_integer_arithmetic_div(Rd, Rn, o1, Rm, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n ('rounding : Bool) ('saturating : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding), bool('saturating), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    round_const : int = 0;
    shift : int = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        shift = SInt(Elem_read(operand2, e, esize)[7 .. 0]);
        if rounding then {
            round_const = (1 << (negate(shift) - 1))
        } else ();
        element = ((asl_Int(Elem_read(operand1, e, esize), is_unsigned) + round_const) << shift);
        if saturating then {
            let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(element, esize, is_unsigned) in
              {
                  result = Elem_set(result, e, esize, __tup_0);
                  sat = __tup_1
              };
            if sat then {
                FPSR = SetSlice(1, FPSR, 27, 0b1)
            } else ()
        } else {
            result = Elem_set(result, e, esize, element[esize - 1 .. 0])
        }
    };
    V_set(datasize, d) = result
}

val decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd, Rn, S, R, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    if S == 0b0 & size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(Rd, Rn, S, R, Rm, size, U)
}

val decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd : (bits(5), bits(5), bits(1), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd, Rn, S, R, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let rounding : bool = R == 0b1;
    let saturating : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd(d, datasize, elements, esize, m, n, rounding, saturating, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let R = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd(Rd, Rn, S, R, Rm, size, U, Q)
}

val execute_aarch64_instrs_memory_atomicops_swp : forall 'datasize 'n 'regsize 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_atomicops_swp (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    address : bits(64) = undefined;
    let store_value : bits('datasize) = X_read(datasize, s);
    let base : VirtualAddress = BaseReg_read__1(n);
    let data : bits('datasize) = MemAtomic(base, MemAtomicOp_SWP, store_value, ldacctype, stacctype);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_swp_aarch64_instrs_memory_atomicops_swp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_swp_aarch64_instrs_memory_atomicops_swp (Rt, Rn, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_swp(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_swp_aarch64_instrs_memory_atomicops_swp(Rt, Rn, Rs, R, A, size)
}

val decode_swph_aarch64_instrs_memory_atomicops_swp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_swph_aarch64_instrs_memory_atomicops_swp (Rt, Rn, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_swp(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_swph_aarch64_instrs_memory_atomicops_swp(Rt, Rn, Rs, R, A, size)
}

val decode_swpb_aarch64_instrs_memory_atomicops_swp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_swpb_aarch64_instrs_memory_atomicops_swp (Rt, Rn, Rs, R, A, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = if A == 0b1 & Rt != 0b11111 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_swp(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let size = Slice(__opcode, 30, 2);
    decode_swpb_aarch64_instrs_memory_atomicops_swp(Rt, Rn, Rs, R, A, size)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : forall 'datasize ('is_signed : Bool) 'n ('postindex : Bool) 'regsize 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('is_signed), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback__arg) = {
    wback : bool = wback__arg;
    c : Constraint = undefined;
    data : bits('datasize) = undefined;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read(n, memop == MemOp_PREFETCH);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(datasize, t)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          } else ();
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          } else ();
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          if is_signed then {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = SignExtend(data, regsize)
          } else {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          let address : bits(64) = VAddress(base);
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    acctype : AccType = undefined;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let unpriv_at_el1 : bool = PSTATE.EL == EL1;
    let unpriv_at_el2 : bool = (PSTATE.EL == EL2 & HaveVirtHostExt()) & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11;
    let user_access_override : bool = HaveUAOExt() & PSTATE.UAO == 0b1;
    if not_bool(user_access_override) & (unpriv_at_el1 | unpriv_at_el2) then {
        acctype = AccType_UNPRIV
    } else {
        acctype = AccType_NORMAL
    };
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_float_arithmetic_mul_add_sub : forall 'a 'd 'datasize 'm 'n ('op1_neg : Bool) ('opa_neg : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('datasize), int('m), int('n), bool('op1_neg), bool('opa_neg)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_mul_add_sub (a, d, datasize, m, n, op1_neg, opa_neg) = {
    CheckFPAdvSIMDEnabled64();
    operanda : bits('datasize) = V_read(datasize, a);
    operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    if opa_neg then {
        operanda = FPNeg(operanda)
    } else ();
    if op1_neg then {
        operand1 = FPNeg(operand1)
    } else ();
    let result : bits('datasize) = FPMulAdd(operanda, operand1, operand2, FPCR);
    V_set(datasize, d) = result
}

val decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, datasize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, datasize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, datasize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitzero, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd, Rn, Ra, o0, Rm, o1, ftype) = {
    let 'd = UInt(Rd);
    let 'a = UInt(Ra);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let opa_neg : bool = o1 == 0b1;
    let op1_neg : bool = o0 != o1;
    execute_aarch64_instrs_float_arithmetic_mul_add_sub(a, d, datasize, m, n, op1_neg, opa_neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let o1 = Slice(__opcode, 21, 1);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub(Rd, Rn, Ra, o0, Rm, o1, ftype)
}

val execute_aarch64_instrs_branch_conditional_compare : forall 'datasize ('iszero : Bool) 't,
  (0 <= 't & 't <= 31 & 'datasize in {32, 64}).
  (int('datasize), bool('iszero), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_conditional_compare (datasize, iszero, offset, t) = {
    let operand1 : bits('datasize) = X_read(datasize, t);
    if IsZero(operand1) == iszero then {
        BranchToOffset(offset, BranchType_DIR)
    } else ()
}

val decode_cbnz_aarch64_instrs_branch_conditional_compare : (bits(5), bits(19), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cbnz_aarch64_instrs_branch_conditional_compare (Rt, imm19, op, sf) = {
    let 't = UInt(Rt);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let iszero : bool = op == 0b0;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_compare(datasize, iszero, offset, t)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let op = Slice(__opcode, 24, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_cbnz_aarch64_instrs_branch_conditional_compare(Rt, imm19, op, sf)
}

val decode_cbz_aarch64_instrs_branch_conditional_compare : (bits(5), bits(19), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cbz_aarch64_instrs_branch_conditional_compare (Rt, imm19, op, sf) = {
    let 't = UInt(Rt);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let iszero : bool = op == 0b0;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_compare(datasize, iszero, offset, t)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let op = Slice(__opcode, 24, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_cbz_aarch64_instrs_branch_conditional_compare(Rt, imm19, op, sf)
}

val execute_aarch64_instrs_memory_vector_single_no_wb : forall 'datasize 'esize 'index 'm 'n ('replicate : Bool) 'selem 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'selem in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128}).
  (int('datasize), int('esize), int('index), int('m), MemOp, int('n), bool('replicate), int('selem), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_vector_single_no_wb (datasize, esize, index, m, memop, n, replicate, selem, t__arg, wback) = {
    t : int = t__arg;
    CheckFPAdvSIMDEnabled64();
    rval : bits(128) = undefined;
    element : bits('esize) = undefined;
    let 'ebytes = DIV(esize, 8);
    let base : VirtualAddress = BaseReg_read__1(n);
    let address : bits(64) = VAddress(base);
    if replicate | memop == MemOp_LOAD then {
        VACheckAddress(base, address, ebytes * selem, CAP_PERM_LOAD, AccType_VEC)
    } else {
        VACheckAddress(base, address, ebytes * selem, CAP_PERM_STORE, AccType_VEC)
    };
    offs : bits(64) = Zeros();
    if replicate then {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            element = Mem_read(address + offs, ebytes, AccType_VEC);
            V_set(esize * DIV(datasize, esize), t) = Replicate(element, DIV(datasize, esize));
            offs = offs + ebytes;
            t = MOD(t + 1, 32)
        }
    } else {
        foreach (s from 0 to (selem - 1) by 1 in inc) {
            rval = V_read(128, t);
            if memop == MemOp_LOAD then {
                rval = Elem_set(rval, index, esize, Mem_read(address + offs, ebytes, AccType_VEC));
                V_set(128, t) = rval
            } else {
                Mem_set(address + offs, ebytes, AccType_VEC) = Elem_read(rval, index, esize)
            };
            offs = offs + ebytes;
            t = MOD(t + 1, 32)
        }
    };
    if wback then {
        if m != 31 then {
            offs = X_read(64, m)
        } else ();
        BaseReg_set(n) = VAAdd(base, offs)
    } else ()
}

val decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt, Rn, size, S, opcode, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = __UNKNOWN_integer();
    let wback : bool = false;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb(Rt, Rn, size, S, opcode, R, L, Q)
}

val decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc : (bits(5), bits(5), bits(2), bits(1), bits(3), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt, Rn, size, S, opcode, Rm, R, L, Q) = {
    let 't = UInt(Rt);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let wback : bool = true;
    scale : range(0, 3) = UInt(opcode[2 .. 1]);
    let 'selem = UInt([opcode[0]] @ R) + 1;
    replicate : bool = false;
    index : int = undefined;
    match scale {
      3 => {
          if L == 0b0 | S == 0b1 then {
              throw(Error_Undefined())
          } else ();
          scale = UInt(size);
          replicate = true
      },
      0 => {
          index = UInt((Q @ S) @ size)
      },
      1 => {
          if [size[0]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          index = UInt((Q @ S) @ [size[1]])
      },
      2 => {
          if [size[1]] == 0b1 then {
              throw(Error_Undefined())
          } else ();
          if [size[0]] == 0b0 then {
              index = UInt(Q @ S)
          } else {
              if S == 0b1 then {
                  throw(Error_Undefined())
              } else ();
              index = UInt(Q);
              scale = 3
          }
      },
      _ => ()
    };
    let 'scale = scale;
    let 'index = index;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'esize = (8 << scale);
    execute_aarch64_instrs_memory_vector_single_no_wb(datasize, esize, index, m, memop, n, replicate, selem, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 10, 2);
    let S = Slice(__opcode, 12, 1);
    let opcode = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 21, 1);
    let L = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc(Rt, Rn, size, S, opcode, Rm, R, L, Q)
}

val execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part ('round : Bool) 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('round), int('shift), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (d, datasize, elements, esize, n, part, round, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize * 2) = V_read(datasize * 2, n);
    result : bits('datasize) = undefined;
    let 'round_const = if round then (1 << (shift - 1)) else 0;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = ((asl_Int(Elem_read(operand, e, 2 * esize), is_unsigned) + round_const) >> shift);
        let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(element, esize, is_unsigned) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    Vpart_set(datasize, d, part) = result
}

val decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64})));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = 2 * esize - UInt(immh @ immb);
    let round : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd(d, datasize, elements, esize, n, part, round, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 11, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd(Rd, Rn, op, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_shift_left_long : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part 'shift,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), int('shift), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_left_long (d, datasize, elements, esize, n, part, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart_read(datasize, n, part);
    result : bits('datasize * 2) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = (asl_Int(Elem_read(operand, e, esize), is_unsigned) << shift);
        result = Elem_set(result, e, 2 * esize, element[2 * esize - 1 .. 0])
    };
    V_set(datasize * 2, d) = result
}

val decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long (Rd, Rn, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_long(d, datasize, elements, esize, n, part, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long(Rd, Rn, immb, immh, U, Q)
}

val decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long (Rd, Rn, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if [immh[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    let is_unsigned : bool = U == 0b1;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_long(d, datasize, elements, esize, n, part, shift, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long(Rd, Rn, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(128, d);
    let operand2 : bits(128) = V_read(128, n);
    result : bits(128) = undefined;
    let T : bits(128) = EOR(operand1, LSR(operand2, 32));
    result[31 .. 0] = ROL(T[31 .. 0], 1);
    result[63 .. 32] = ROL(T[63 .. 32], 1);
    result[95 .. 64] = ROL(T[95 .. 64], 1);
    result[127 .. 96] = EOR(ROL(T[127 .. 96], 1), ROL(T[31 .. 0], 2));
    V_set(128, d) = result
}

val decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 (Rd, Rn) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1(d, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1(Rd, Rn)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('rounding : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('rounding), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (d, datasize, elements, esize, m, n, rounding, sub_op) = {
    accum : int = undefined;
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    let operand3 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    let 'rounding_const = if rounding then (1 << (esize - 1)) else 0;
    element1 : int = undefined;
    element2 : int = undefined;
    element3 : int = undefined;
    product : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        element3 = SInt(Elem_read(operand3, e, esize));
        if sub_op then {
            accum = (element3 << esize) - 2 * (element1 * element2) + rounding_const
        } else {
            accum = (element3 << esize) + 2 * (element1 * element2) + rounding_const
        };
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ((accum >> esize), esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (Rd, Rn, S, Rm, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(Rd, Rn, S, Rm, size)
}

val decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd (Rd, Rn, S, Rm, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd(Rd, Rn, S, Rm, size, Q)
}

val decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (Rd, Rn, S, Rm, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(Rd, Rn, S, Rm, size)
}

val decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd (Rd, Rn, S, Rm, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 | size == 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd(d, datasize, elements, esize, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd(Rd, Rn, S, Rm, size, Q)
}

val execute_aarch64_instrs_vector_shift_left_sat_sisd : forall 'd 'datasize ('dst_unsigned : Bool) 'elements 'esize 'n 'shift ('src_unsigned : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bool('dst_unsigned), int('elements), int('esize), int('n), int('shift), bool('src_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_left_sat_sisd (d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = (asl_Int(Elem_read(operand, e, esize), src_unsigned) << shift);
        let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(element, esize, dst_unsigned) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128})));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128})));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd(Rd, Rn, op, immb, immh, U, Q)
}

val decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd (Rd, Rn, op, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint(('esize in {4, 8, 16, 32, 64} & 'datasize in {4, 8, 16, 32, 64, 128})));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd(Rd, Rn, op, immb, immh, U)
}

val decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd : (bits(5), bits(5), bits(1), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd (Rd, Rn, op, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    src_unsigned : bool = undefined;
    dst_unsigned : bool = undefined;
    match op @ U {
      0b00 => {
          throw(Error_Undefined())
      },
      0b01 => {
          src_unsigned = false;
          dst_unsigned = true
      },
      0b10 => {
          src_unsigned = false;
          dst_unsigned = false
      },
      0b11 => {
          src_unsigned = true;
          dst_unsigned = true
      }
    };
    let dst_unsigned = dst_unsigned;
    let src_unsigned = src_unsigned;
    assert(constraint('esize in {4, 8, 16, 32, 64}));
    execute_aarch64_instrs_vector_shift_left_sat_sisd(d, datasize, dst_unsigned, elements, esize, n, shift, src_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd(Rd, Rn, op, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_reduce_add_simd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_add_simd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let op : ReduceOp = ReduceOp_ADD;
    execute_aarch64_instrs_vector_reduce_add_simd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (d, datasize, elements, esize, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        result = Elem_set(result, e, 2 * esize, sum[2 * esize - 1 .. 0])
    };
    V_set(2 * datasize, d) = result
}

val decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(d, datasize, elements, esize, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    let zero : bits('esize) = FPZero(esize, 0b0);
    element : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        match comparison {
          CompareOp_GT => {
              test_passed = FPCompareGT(element, zero, FPCR)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element, zero, FPCR)
          },
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element, zero, FPCR)
          },
          CompareOp_LE => {
              test_passed = FPCompareGE(zero, element, FPCR)
          },
          CompareOp_LT => {
              test_passed = FPCompareGT(zero, element, FPCR)
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd, Rn, op, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(Rd, Rn, op, U)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd, Rn, op, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd(Rd, Rn, op, sz, U)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd, Rn, op, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd(Rd, Rn, op, U, Q)
}

val decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd, Rn, op, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd(Rd, Rn, op, sz, U, Q)
}

val execute_aarch64_instrs_memory_atomicops_st : forall 'datasize 'n 's,
  (0 <= 's & 's <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (int('datasize), AccType, int('n), MemAtomicOp, int('s), AccType) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_atomicops_st (datasize, ldacctype, n, op, s, stacctype) = {
    address : bits(64) = undefined;
    let value_name : bits('datasize) = X_read(datasize, s);
    let base : VirtualAddress = BaseReg_read__1(n);
    data = MemAtomic(base, op, value_name, ldacctype, stacctype)
}

val decode_stumaxb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stumaxb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stumaxb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_steor_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_steor_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_steor_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stclrh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stclrh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stclrh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stadd_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stadd_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stadd_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stuminb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stuminb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stuminb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsminb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsminb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsminb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stclr_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stclr_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stclr_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stclrb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stclrb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stclrb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsmin_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsmin_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsmin_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stumin_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stumin_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stumin_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_staddb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_staddb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_staddb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsminh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsminh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsminh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsmaxh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsmaxh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsmaxh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsetb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsetb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsetb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stuminh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stuminh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stuminh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsmaxb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsmaxb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsmaxb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stsmax_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stsmax_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stsmax_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_steorh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_steorh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_steorh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stseth_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stseth_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stseth_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stset_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stset_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stset_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_steorb_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_steorb_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_steorb_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_staddh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_staddh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_staddh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stumaxh_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stumaxh_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stumaxh_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val decode_stumax_aarch64_instrs_memory_atomicops_st : (bits(5), bits(3), bits(1), bits(5), bits(1), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stumax_aarch64_instrs_memory_atomicops_st (Rn, opc, o3, Rs, R, A, V, size) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 's = UInt(Rs);
    let 'datasize = (8 << UInt(size));
    let 'regsize = if datasize == 64 then 64 else 32;
    let ldacctype : AccType = AccType_ATOMICRW;
    let stacctype : AccType = if R == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    op : MemAtomicOp = undefined;
    match opc {
      0b000 => {
          op = MemAtomicOp_ADD
      },
      0b001 => {
          op = MemAtomicOp_BIC
      },
      0b010 => {
          op = MemAtomicOp_EOR
      },
      0b011 => {
          op = MemAtomicOp_ORR
      },
      0b100 => {
          op = MemAtomicOp_SMAX
      },
      0b101 => {
          op = MemAtomicOp_SMIN
      },
      0b110 => {
          op = MemAtomicOp_UMAX
      },
      0b111 => {
          op = MemAtomicOp_UMIN
      }
    };
    let op = op;
    execute_aarch64_instrs_memory_atomicops_st(datasize, ldacctype, n, op, s, stacctype)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 12, 3);
    let o3 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let R = Slice(__opcode, 22, 1);
    let A = Slice(__opcode, 23, 1);
    let V = Slice(__opcode, 26, 1);
    let size = Slice(__opcode, 30, 2);
    decode_stumax_aarch64_instrs_memory_atomicops_st(Rn, opc, o3, Rs, R, A, V, size)
}

val execute_aarch64_instrs_vector_transfer_integer_move_signed : forall 'd 'datasize 'esize 'idxdsize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('idxdsize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_integer_move_signed (d, datasize, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V_read(idxdsize, n);
    X_set(datasize, d) = SignExtend(Elem_read(operand, index, esize), datasize)
}

val decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    size : {|0, 1, 2|} = 0;
    match Q @ imm5 {
      [_, _, _, _, _, bitone] => {
          size = 0
      },
      [_, _, _, _, bitone, bitzero] => {
          size = 1
      },
      [bitone, _, _, bitone, bitzero, bitzero] => {
          size = 2
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 64 else 32;
    assert(constraint('esize in {8, 16, 32}));
    execute_aarch64_instrs_vector_transfer_integer_move_signed(d, datasize, esize, idxdsize, index, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_float_arithmetic_add_sub : forall 'd 'datasize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_add_sub (d, datasize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    if sub_op then {
        result = FPSub(operand1, operand2, FPCR)
    } else {
        result = FPAdd(operand1, operand2, FPCR)
    };
    V_set(datasize, d) = result
}

val decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_add_sub(d, datasize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub(Rd, Rn, op, Rm, ftype)
}

val decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub : (bits(5), bits(5), bits(1), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub (Rd, Rn, op, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_float_arithmetic_add_sub(d, datasize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub(Rd, Rn, op, Rm, ftype)
}

val execute_aarch64_instrs_system_exceptions_debug_exception : bits(2) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_exceptions_debug_exception target_level = {
    DCPSInstruction(target_level)
}

val decode_dcps3_aarch64_instrs_system_exceptions_debug_exception : (bits(2), bits(16)) -> unit effect {escape, rreg, undef, wreg}

function decode_dcps3_aarch64_instrs_system_exceptions_debug_exception (LL, imm16) = {
    let target_level : bits(2) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    } else ();
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_system_exceptions_debug_exception(target_level)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) = {
    let LL = Slice(__opcode, 0, 2);
    let imm16 = Slice(__opcode, 5, 16);
    decode_dcps3_aarch64_instrs_system_exceptions_debug_exception(LL, imm16)
}

val decode_dcps2_aarch64_instrs_system_exceptions_debug_exception : (bits(2), bits(16)) -> unit effect {escape, rreg, undef, wreg}

function decode_dcps2_aarch64_instrs_system_exceptions_debug_exception (LL, imm16) = {
    let target_level : bits(2) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    } else ();
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_system_exceptions_debug_exception(target_level)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) = {
    let LL = Slice(__opcode, 0, 2);
    let imm16 = Slice(__opcode, 5, 16);
    decode_dcps2_aarch64_instrs_system_exceptions_debug_exception(LL, imm16)
}

val decode_dcps1_aarch64_instrs_system_exceptions_debug_exception : (bits(2), bits(16)) -> unit effect {escape, rreg, undef, wreg}

function decode_dcps1_aarch64_instrs_system_exceptions_debug_exception (LL, imm16) = {
    let target_level : bits(2) = LL;
    if LL == 0b00 then {
        throw(Error_Undefined())
    } else ();
    if not_bool(Halted()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_system_exceptions_debug_exception(target_level)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let LL = Slice(__opcode, 0, 2);
    let imm16 = Slice(__opcode, 5, 16);
    decode_dcps1_aarch64_instrs_system_exceptions_debug_exception(LL, imm16)
}

val execute_aarch64_instrs_vector_crypto_sm4_sm4enckey : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm4_sm4enckey (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    intval : bits(32) = undefined;
    sboxout : bits(8) = undefined;
    result : bits(128) = undefined;
    const : bits(32) = undefined;
    roundresult : bits(128) = V_read(128, n);
    foreach (index from 0 to 3 by 1 in inc) {
        const = Elem_read(Vm, index, 32);
        intval = EOR(EOR(EOR(roundresult[127 .. 96], roundresult[95 .. 64]), roundresult[63 .. 32]), const);
        foreach (i from 0 to 3 by 1 in inc) {
            intval = Elem_set(intval, i, 8, Sbox(Elem_read(intval, i, 8)))
        };
        intval = EOR(EOR(intval, ROL(intval, 13)), ROL(intval, 23));
        intval = EOR(intval, roundresult[31 .. 0]);
        roundresult[31 .. 0] = roundresult[63 .. 32];
        roundresult[63 .. 32] = roundresult[95 .. 64];
        roundresult[95 .. 64] = roundresult[127 .. 96];
        roundresult[127 .. 96] = intval
    };
    V_set(128, d) = roundresult
}

val decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey (Rd, Rn, Rm) = {
    if not_bool(HaveSM4Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sm4_sm4enckey(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey(Rd, Rn, Rm)
}

val execute_aarch64_instrs_float_convert_int : forall 'd 'fltsize 'intsize ('is_unsigned : Bool) 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'intsize in {32, 64} & 'fltsize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('fltsize), int('intsize), int('n), FPConvOp, int('part), FPRounding, bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_convert_int (d, fltsize, intsize, n, op, part, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    fltval : bits('fltsize) = undefined;
    intval : bits('intsize) = undefined;
    match op {
      FPConvOp_CVT_FtoI => {
          let fltval : bits('fltsize) = V_read(fltsize, n);
          assert(constraint('fltsize in {16, 32, 64}));
          let intval : bits('intsize) = FPToFixed(intsize, fltval, 0, is_unsigned, FPCR, rounding);
          X_set(intsize, d) = intval
      },
      FPConvOp_CVT_ItoF => {
          let intval : bits('intsize) = X_read(intsize, n);
          assert(constraint('fltsize in {16, 32, 64}));
          let fltval : bits('fltsize) = FixedToFP(fltsize, intval, 0, is_unsigned, FPCR, rounding);
          V_set(fltsize, d) = fltval
      },
      FPConvOp_MOV_FtoI => {
          let fltval : bits('fltsize) = Vpart_read(fltsize, n, part);
          assert(constraint('intsize >= 'fltsize));
          let intval : bits('intsize) = ZeroExtend(fltval, intsize);
          X_set(intsize, d) = intval
      },
      FPConvOp_MOV_ItoF => {
          let intval : bits('intsize) = X_read(intsize, n);
          assert(constraint('fltsize - 1 < 'intsize));
          let fltval : bits('fltsize) = intval[fltsize - 1 .. 0];
          Vpart_set(fltsize, d, part) = fltval
      }
    }
}

val decode_fcvtmu_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtmu_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtmu_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_scvtf_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_scvtf_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fjcvtzs_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fjcvtzs_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fjcvtzs_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtnu_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtnu_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtnu_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fmov_float_gen_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmov_float_gen_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, _, bitone, bitone, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fmov_float_gen_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtms_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtms_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtms_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtps_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtps_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtps_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_ucvtf_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ucvtf_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtns_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtns_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtns_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtzs_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzs_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtpu_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtpu_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtpu_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtas_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtas_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtas_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtzu_float_int_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_float_int_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzu_float_int_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val decode_fcvtau_float_aarch64_instrs_float_convert_int : (bits(5), bits(5), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtau_float_aarch64_instrs_float_convert_int (Rd, Rn, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64, 128|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    part : {|0, 1|} = 0;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          if (opcode[2 .. 1] @ rmode) != 0b1101 then {
              throw(Error_Undefined())
          } else ();
          fltsize = 128
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    match opcode[2 .. 1] @ rmode {
      [bitzero, bitzero, _, _] => {
          rounding = FPDecodeRounding(rmode);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      0b1000 => {
          rounding = FPRounding_TIEAWAY;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b1100 => {
          if fltsize != 16 & fltsize != intsize then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 0
      },
      0b1101 => {
          if intsize != 64 | fltsize != 128 then {
              throw(Error_Undefined())
          } else ();
          op = if [opcode[0]] == 0b1 then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
          part = 1;
          fltsize = 64
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let op = op;
    let 'part = part;
    let 'fltsize = fltsize;
    match fltsize {
      16 => {
          execute_aarch64_instrs_float_convert_int(d, 16, intsize, n, op, part, rounding, is_unsigned)
      },
      32 => {
          execute_aarch64_instrs_float_convert_int(d, 32, intsize, n, op, part, rounding, is_unsigned)
      },
      64 => {
          execute_aarch64_instrs_float_convert_int(d, 64, intsize, n, op, part, rounding, is_unsigned)
      },
      128 => {
          execute_aarch64_instrs_float_convert_int(d, 128, intsize, n, op, part, rounding, is_unsigned)
      },
      _ => {
          assert(false)
      }
    }
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtau_float_aarch64_instrs_float_convert_int(Rd, Rn, opcode, rmode, ftype, sf)
}

val execute_aarch64_instrs_vector_shift_left_insert_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_left_insert_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    assert(constraint('esize >= 0));
    let mask : bits('esize) = LSL(Ones(esize), shift);
    shifted : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((0 <= 'loop_e * 'esize & 'loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('esize >= 0) | not('datasize in {8, 16, 32, 64, 128}))));
        shifted = LSL(Elem_read(operand, e, esize), shift);
        result = Elem_set(result, e, esize, Elem_read(operand2, e, esize) & not_vec(mask) | shifted)
    };
    V_set(datasize, d) = result
}

val decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd : (bits(5), bits(5), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd (Rd, Rn, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd(Rd, Rn, immb, immh)
}

val decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd (Rd, Rn, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd(Rd, Rn, immb, immh, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_narrow : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {16, 32} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_float_narrow (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(2 * datasize, n);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, FPConvert__1(esize, Elem_read(operand, e, 2 * esize), FPCR))
    };
    Vpart_set(datasize, d, part) = result
}

val decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (16 << UInt(sz));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {16, 32}));
    execute_aarch64_instrs_vector_arithmetic_unary_float_narrow(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_memory_pair_simdfp_post_idx : forall 'datasize 'n ('postindex : Bool) 't 't2 ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64, 128, 256}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), int('t2), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_pair_simdfp_post_idx (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    CheckFPAdvSIMDEnabled64();
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_STORE, acctype);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data1 : bits('datasize) = V_read(datasize, t);
          let data2 : bits('datasize) = V_read(datasize, t2);
          Mem_set(address + 0, dbytes, acctype) = data1;
          Mem_set(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_LOAD, acctype);
          assert(constraint('dbytes in {1, 2, 4, 8, 16}));
          data1 : bits('datasize) = Mem_read(address + 0, dbytes, acctype);
          data2 : bits('datasize) = Mem_read(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          } else ();
          V_set(datasize, t) = data1;
          V_set(datasize, t2) = data2
      },
      _ => ()
    };
    if wback then {
        let base : VirtualAddress = VAAdd(base, offset);
        BaseReg_set(n) = base
    } else ()
}

val decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_post_idx(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_integer_conditional_select : forall 'd 'datasize ('else_inc : Bool) ('else_inv : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (bits(4), int('d), int('datasize), bool('else_inc), bool('else_inv), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_conditional_select (condition, d, datasize, else_inc, else_inv, m, n) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = X_read(datasize, m);
    if ConditionHolds(condition) then {
        result = operand1
    } else {
        result = operand2;
        if else_inv then {
            result = not_vec(result)
        } else ();
        if else_inc then {
            result = result + 1
        } else ()
    };
    X_set(datasize, d) = result
}

val decode_csinc_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_csinc_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csinc_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val decode_csel_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_csel_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csel_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val decode_csneg_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_csneg_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csneg_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val decode_csinv_aarch64_instrs_integer_conditional_select : (bits(5), bits(5), bits(1), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_csinv_aarch64_instrs_integer_conditional_select (Rd, Rn, o2, cond, Rm, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let condition : bits(4) = cond;
    let else_inv : bool = op == 0b1;
    let else_inc : bool = o2 == 0b1;
    execute_aarch64_instrs_integer_conditional_select(condition, d, datasize, else_inc, else_inv, m, n)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o2 = Slice(__opcode, 10, 1);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_csinv_aarch64_instrs_integer_conditional_select(Rd, Rn, o2, cond, Rm, op, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('rounding : Bool) ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('rounding), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op) = {
    accum : int = undefined;
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    let operand3 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    let 'rounding_const = if rounding then (1 << (esize - 1)) else 0;
    element1 : int = undefined;
    element3 : int = undefined;
    product : int = undefined;
    sat : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element3 = SInt(Elem_read(operand3, e, esize));
        if sub_op then {
            accum = (element3 << esize) - 2 * (element1 * element2) + rounding_const
        } else {
            accum = (element3 << esize) + 2 * (element1 * element2) + rounding_const
        };
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ((accum >> esize), esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (Rd, Rn, H, S, Rm, M, L, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(Rd, Rn, H, S, Rm, M, L, size)
}

val decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd (Rd, Rn, H, S, Rm, M, L, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd(Rd, Rn, H, S, Rm, M, L, size, Q)
}

val decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (Rd, Rn, H, S, Rm, M, L, size) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(Rd, Rn, H, S, Rm, M, L, size)
}

val decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd (Rd, Rn, H, S, Rm, M, L, size, Q) = {
    if not_bool(HaveQRDMLAHExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : bool = true;
    let sub_op : bool = S == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, rounding, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let S = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd(Rd, Rn, H, S, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    assert(constraint('datasize >= 'esize));
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(Rd, Rn, sz, o1)
}

val decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd(Rd, Rn, sz, o1)
}

val decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(Rd, Rn, sz, o1)
}

val decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;
    execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd(Rd, Rn, sz, o1)
}

val execute_aarch64_instrs_integer_arithmetic_cnt : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('n), CountOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_cnt (d, datasize, n, opcode) = {
    result : int = undefined;
    let operand1 : bits('datasize) = X_read(datasize, n);
    if opcode == CountOp_CLZ then {
        result = CountLeadingZeroBits(operand1)
    } else {
        result = CountLeadingSignBits(operand1)
    };
    let 'result = result;
    X_set(0 + (datasize - 1 - 0 + 1), d) = result[datasize - 1 .. 0]
}

val decode_clz_int_aarch64_instrs_integer_arithmetic_cnt : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_clz_int_aarch64_instrs_integer_arithmetic_cnt (Rd, Rn, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let opcode : CountOp = if op == 0b0 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_integer_arithmetic_cnt(d, datasize, n, opcode)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 10, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_clz_int_aarch64_instrs_integer_arithmetic_cnt(Rd, Rn, op, sf)
}

val decode_cls_int_aarch64_instrs_integer_arithmetic_cnt : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cls_int_aarch64_instrs_integer_arithmetic_cnt (Rd, Rn, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let opcode : CountOp = if op == 0b0 then CountOp_CLZ else CountOp_CLS;
    execute_aarch64_instrs_integer_arithmetic_cnt(d, datasize, n, opcode)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 10, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_cls_int_aarch64_instrs_integer_arithmetic_cnt(Rd, Rn, op, sf)
}

val execute_aarch64_instrs_vector_reduce_add_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_add_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    assert(constraint('datasize >= 'esize));
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd : (bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd (Rd, Rn, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = ReduceOp_ADD;
    execute_aarch64_instrs_vector_reduce_add_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd(Rd, Rn, size)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        sum = element1 + element2;
        let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(sum, esize, is_unsigned) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_memory_literal_general : forall ('is_signed : Bool) 'size 't,
  (0 <= 't & 't <= 31 & 'size in {4, 8}).
  (MemOp, bits(64), bool('is_signed), int('size), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_literal_general (memop, offset, is_signed, size, t) = {
    let base : VirtualAddress = VAFromCapability(PCC);
    let address : bits(64) = VAddress(base) + offset;
    data : bits('size * 8) = undefined;
    match memop {
      MemOp_LOAD => {
          VACheckAddress(base, address, size, CAP_PERM_LOAD, AccType_NORMAL);
          let data : bits('size * 8) = Mem_read(address, size, AccType_NORMAL);
          if is_signed then {
              X_set(64, t) = SignExtend(data, 64)
          } else {
              X_set(size * 8, t) = data
          }
      },
      MemOp_PREFETCH => {
          Prefetch(address, t[4 .. 0])
      },
      _ => ()
    }
}

val decode_prfm_lit_aarch64_instrs_memory_literal_general : (bits(5), bits(19), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_prfm_lit_aarch64_instrs_memory_literal_general (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    is_signed : bool = false;
    size : {|4, 8|} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          is_signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_memory_literal_general(memop, offset, is_signed, size, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_prfm_lit_aarch64_instrs_memory_literal_general(Rt, imm19, opc)
}

val decode_ldrsw_lit_aarch64_instrs_memory_literal_general : (bits(5), bits(19), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsw_lit_aarch64_instrs_memory_literal_general (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    is_signed : bool = false;
    size : {|4, 8|} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          is_signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_memory_literal_general(memop, offset, is_signed, size, t)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_ldrsw_lit_aarch64_instrs_memory_literal_general(Rt, imm19, opc)
}

val decode_ldr_lit_gen_aarch64_instrs_memory_literal_general : (bits(5), bits(19), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_lit_gen_aarch64_instrs_memory_literal_general (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    memop : MemOp = MemOp_LOAD;
    is_signed : bool = false;
    size : {|4, 8|} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 4;
          is_signed = true
      },
      0b11 => {
          memop = MemOp_PREFETCH
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_memory_literal_general(memop, offset, is_signed, size, t)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_ldr_lit_gen_aarch64_instrs_memory_literal_general(Rt, imm19, opc)
}

val execute_aarch64_instrs_vector_shift_conv_float_sisd : forall 'd 'datasize 'elements 'esize 'fracbits ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('fracbits), int('n), FPRounding, bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_conv_float_sisd (d, datasize, elements, esize, fracbits, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPToFixed(esize, element, fracbits, is_unsigned, FPCR, rounding))
    };
    V_set(datasize, d) = result
}

val decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd(Rd, Rn, immb, immh, U)
}

val decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd (Rd, Rn, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd(Rd, Rn, immb, immh, U, Q)
}

val decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd(Rd, Rn, immb, immh, U)
}

val decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd (Rd, Rn, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRounding_ZERO;
    execute_aarch64_instrs_vector_shift_conv_float_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd(Rd, Rn, immb, immh, U, Q)
}

val execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub : forall 'a 'd 'datasize 'destsize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'destsize in {32, 64} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (a, d, datasize, destsize, m, n, sub_op) = {
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = X_read(datasize, m);
    let operand3 : bits('destsize) = X_read(destsize, a);
    result : int = undefined;
    if sub_op then {
        result = UInt(operand3) - UInt(operand1) * UInt(operand2)
    } else {
        result = UInt(operand3) + UInt(operand1) * UInt(operand2)
    };
    let 'result = result;
    X_set(0 + (destsize - 1 - 0 + 1), d) = result[destsize - 1 .. 0]
}

val decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (Rd, Rn, Ra, o0, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = if sf == 0b1 then 64 else 32;
    let 'datasize = destsize;
    let sub_op : bool = o0 == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(a, d, datasize, destsize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(Rd, Rn, Ra, o0, Rm, sf)
}

val decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (Rd, Rn, Ra, o0, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = if sf == 0b1 then 64 else 32;
    let 'datasize = destsize;
    let sub_op : bool = o0 == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(a, d, datasize, destsize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub(Rd, Rn, Ra, o0, Rm, sf)
}

val execute_aarch64_instrs_memory_pair_general_no_alloc : forall 'datasize 'n ('postindex : Bool) 't 't2 ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), int('t2), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_pair_general_no_alloc (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_STORE, acctype);
          if rt_unknown & t == n then {
              data1 = __UNKNOWN_bits(datasize)
          } else {
              data1 = X_read(datasize, t)
          };
          if rt_unknown & t2 == n then {
              data2 = __UNKNOWN_bits(datasize)
          } else {
              data2 = X_read(datasize, t2)
          };
          Mem_set(address + 0, dbytes, acctype) = data1;
          Mem_set(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_LOAD, acctype);
          data1 : bits('datasize) = Mem_read(address + 0, dbytes, acctype);
          data2 : bits('datasize) = Mem_read(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          } else ();
          X_set(datasize, t) = data1;
          X_set(datasize, t2) = data2
      },
      _ => ()
    };
    if wback then {
        let base : VirtualAddress = VAAdd(base, offset);
        BaseReg_set(n) = base
    } else ()
}

val decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_STREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if [opc[0]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_no_alloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_STREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if [opc[0]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt([opc[1]]);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64}));
    execute_aarch64_instrs_memory_pair_general_no_alloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_vector_transfer_integer_insert : forall 'd 'datasize 'esize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64, 128, 256} & 'datasize == 128 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_integer_insert (d, datasize, esize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('esize in {8, 16, 32, 64}));
    let element : bits('esize) = X_read(esize, n);
    result : bits('datasize) = V_read(datasize, d);
    result = Elem_set(result, index, esize, element);
    V_set(datasize, d) = result
}

val decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert (Rd, Rn, imm5) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    } else ();
    assert(constraint(0 <= 'size + 1));
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'esize = (8 << size);
    let 'datasize = 128;
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_integer_insert(d, datasize, esize, index, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert(Rd, Rn, imm5)
}

val execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx : forall 'datasize 'n ('postindex : Bool) 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (acctype, datasize, memop, n, offset, postindex, t, wback) = {
    CheckFPAdvSIMDEnabled64();
    data : bits('datasize) = undefined;
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(datasize, t);
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          assert(constraint((div('datasize, 8) == 1 | div('datasize, 8) == 2 | div('datasize, 8) == 4 | div('datasize, 8) == 8 | div('datasize, 8) == 16)));
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          V_set(datasize, t) = data
      },
      _ => ()
    };
    if wback then {
        let base : VirtualAddress = VAAdd(base, offset);
        BaseReg_set(n) = base
    } else ()
}

val decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_round : forall 'd 'datasize 'elements 'esize ('exact : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), bool('exact), int('n), FPRounding) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_round (d, datasize, elements, esize, exact, n, rounding) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRoundInt(element, FPCR, rounding, exact))
    };
    V_set(datasize, d) = result
}

val decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd, Rn, o1, o2, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round(Rd, Rn, o1, o2, U, Q)
}

val decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round : (bits(5), bits(5), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd, Rn, o1, sz, o2, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    exact : bool = false;
    rounding : FPRounding = undefined;
    match (U @ o1) @ o2 {
      [bitzero, _, _] => {
          rounding = FPDecodeRounding(o1 @ o2)
      },
      0b100 => {
          rounding = FPRounding_TIEAWAY
      },
      0b101 => {
          throw(Error_Undefined())
      },
      0b110 => {
          rounding = FPRoundingMode(FPCR);
          exact = true
      },
      0b111 => {
          rounding = FPRoundingMode(FPCR)
      }
    };
    let rounding = rounding;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_round(d, datasize, elements, esize, exact, n, rounding)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 12, 1);
    let sz = Slice(__opcode, 22, 1);
    let o2 = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round(Rd, Rn, o1, sz, o2, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    let operand3 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if sub_op then {
            element1 = FPNeg(element1)
        } else ();
        result = Elem_set(result, e, esize, FPMulAdd(Elem_read(operand3, e, esize), element1, element2, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (Rd, Rn, Rm, a, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(Rd, Rn, Rm, a, Q)
}

val decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused (Rd, Rn, Rm, sz, op, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let op = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused(Rd, Rn, Rm, sz, op, Q)
}

val decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (Rd, Rn, Rm, a, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = a == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let a = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(Rd, Rn, Rm, a, Q)
}

val decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused (Rd, Rn, Rm, sz, op, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let op = Slice(__opcode, 23, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused(Rd, Rn, Rm, sz, op, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPMulX(element1, element2, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(Rd, Rn, Rm)
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd(Rd, Rn, Rm, sz)
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd(Rd, Rn, Rm, Q)
}

val decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_memory_exclusive_pair : forall 'datasize 'elsize 'n ('pair : Bool) 'regsize 's 't 't2,
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'elsize in {32, 64} & 'datasize in {32, 64, 128}).
  (AccType, int('datasize), int('elsize), MemOp, int('n), bool('pair), int('regsize), int('s), int('t), int('t2)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_exclusive_pair (acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2) = {
    iswrite : bool = undefined;
    secondstage : bool = undefined;
    data : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    rt_unknown : bool = false;
    rn_unknown : bool = false;
    if (memop == MemOp_LOAD & pair) & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if memop == MemOp_STORE then {
        if s == t | pair & s == t2 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rt_unknown = true
              },
              Constraint_NONE => {
                  rt_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        } else ();
        if s == n & n != 31 then {
            let c : Constraint = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
            assert(c == Constraint_UNKNOWN | c == Constraint_NONE | c == Constraint_UNDEF | c == Constraint_NOP);
            match c {
              Constraint_UNKNOWN => {
                  rn_unknown = true
              },
              Constraint_NONE => {
                  rn_unknown = false
              },
              Constraint_UNDEF => {
                  throw(Error_Undefined())
              },
              Constraint_NOP => {
                  EndOfInstruction()
              },
              _ => ()
            }
        } else ()
    } else ();
    base : VirtualAddress = undefined;
    if rn_unknown then {
        base = __UNKNOWN_VirtualAddress()
    } else {
        base = BaseReg_read__1(n)
    };
    let address : bits(64) = VAddress(base);
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else if pair then {
              let el1 : bits(div('datasize, 2)) = X_read(DIV(datasize, 2), t);
              let el2 : bits(div('datasize, 2)) = X_read(DIV(datasize, 2), t2);
              data = if BigEndian() then el1 @ el2 else el2 @ el1
          } else {
              assert(constraint('datasize in {8, 16, 32, 64}));
              data = X_read(datasize, t)
          };
          status : bits(1) = 0b1;
          if AArch64_ExclusiveMonitorsPass(address, dbytes) then {
              Mem_set(address, dbytes, acctype) = data;
              status = ExclusiveMonitorsStatus()
          } else ();
          X_set(32, s) = ZeroExtend(status, 32)
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          AArch64_SetExclusiveMonitors(address, dbytes);
          if pair then {
              if rt_unknown then {
                  assert(constraint('datasize in {32, 64}));
                  X_set(datasize, t) = __UNKNOWN_bits(datasize)
              } else if elsize == 32 then {
                  let data : bits('datasize) = Mem_read(address, dbytes, acctype);
                  if BigEndian() then {
                      assert(constraint('elsize <= 'datasize - 1));
                      assert(constraint((0 + ('datasize - 1 - 'elsize + 1) == 32 | 0 + ('datasize - 1 - 'elsize + 1) == 64)));
                      X_set(0 + (datasize - 1 - elsize + 1), t) = data[datasize - 1 .. elsize];
                      X_set(0 + (elsize - 1 - 0 + 1), t2) = data[elsize - 1 .. 0]
                  } else {
                      X_set(0 + (elsize - 1 - 0 + 1), t) = data[elsize - 1 .. 0];
                      assert(constraint('elsize <= 'datasize - 1));
                      assert(constraint((0 + ('datasize - 1 - 'elsize + 1) == 32 | 0 + ('datasize - 1 - 'elsize + 1) == 64)));
                      X_set(0 + (datasize - 1 - elsize + 1), t2) = data[datasize - 1 .. elsize]
                  }
              } else {
                  if address != Align(address, dbytes) then {
                      let iswrite : bool = false;
                      let secondstage : bool = false;
                      AArch64_Abort(address, AArch64_AlignmentFault(acctype, iswrite, secondstage))
                  } else ();
                  X_set(8 * 8, t) = Mem_read(address + 0, 8, acctype);
                  X_set(8 * 8, t2) = Mem_read(address + 8, 8, acctype)
              }
          } else {
              let data : bits('datasize) = Mem_read(address, dbytes, acctype);
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      _ => ()
    }
}

val decode_stlxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_pair(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    decode_stlxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
}

val decode_stxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_stxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_pair(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    decode_stxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
}

val decode_ldxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_pair(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
    }
}

val decode_ldaxp_aarch64_instrs_memory_exclusive_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaxp_aarch64_instrs_memory_exclusive_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMIC else AccType_ATOMIC;
    let pair : bool = true;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (32 << UInt(sz));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = if pair then elsize * 2 else elsize;
    execute_aarch64_instrs_memory_exclusive_pair(acctype, datasize, elsize, memop, n, pair, regsize, s, t, t2)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaxp_aarch64_instrs_memory_exclusive_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
    }
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPRecipStepFused(element1, element2))
    };
    V_set(datasize, d) = result
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(Rd, Rn, Rm)
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd(Rd, Rn, Rm, sz)
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd(Rd, Rn, Rm, Q)
}

val decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_vector_transfer_vector_permute_transpose : forall 'd 'datasize 'esize 'm 'n 'pairs 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('m), int('n), int('pairs), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_permute_transpose (d, datasize, esize, m, n, pairs, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    foreach (p from 0 to (pairs - 1) by 1 in inc) {
        result = Elem_set(result, 2 * p + 0, esize, Elem_read(operand1, 2 * p + part, esize));
        result = Elem_set(result, 2 * p + 1, esize, Elem_read(operand2, 2 * p + part, esize))
    };
    V_set(datasize, d) = result
}

val decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_transpose(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose(Rd, Rn, op, Rm, size, Q)
}

val decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_transpose(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose(Rd, Rn, op, Rm, size, Q)
}

val execute_aarch64_instrs_integer_ins_ext_insert_movewide : forall 'd 'datasize 'pos,
  (0 <= 'pos & 'pos <= 63 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits(16), MoveWideOp, int('pos)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_ins_ext_insert_movewide (d, datasize, imm, opcode, pos) = {
    result : bits('datasize) = undefined;
    if opcode == MoveWideOp_K then {
        result = X_read(datasize, d)
    } else {
        result = Zeros()
    };
    assert(constraint('pos + 15 < 'datasize));
    result[pos + 15 .. pos] = imm;
    if opcode == MoveWideOp_N then {
        result = not_vec(result)
    } else ();
    let result = result;
    X_set(datasize, d) = result
}

val decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide (Rd, imm16, hw, opc, sf) = {
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm : bits(16) = imm16;
    opcode : MoveWideOp = undefined;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'pos = UInt(hw @ 0b0000);
    execute_aarch64_instrs_integer_ins_ext_insert_movewide(d, datasize, imm, opcode, pos)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let imm16 = Slice(__opcode, 5, 16);
    let hw = Slice(__opcode, 21, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide(Rd, imm16, hw, opc, sf)
}

val decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide (Rd, imm16, hw, opc, sf) = {
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm : bits(16) = imm16;
    opcode : MoveWideOp = undefined;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'pos = UInt(hw @ 0b0000);
    execute_aarch64_instrs_integer_ins_ext_insert_movewide(d, datasize, imm, opcode, pos)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let imm16 = Slice(__opcode, 5, 16);
    let hw = Slice(__opcode, 21, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide(Rd, imm16, hw, opc, sf)
}

val decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide : (bits(5), bits(16), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide (Rd, imm16, hw, opc, sf) = {
    let 'd = UInt(Rd);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let imm : bits(16) = imm16;
    opcode : MoveWideOp = undefined;
    match opc {
      0b00 => {
          opcode = MoveWideOp_N
      },
      0b10 => {
          opcode = MoveWideOp_Z
      },
      0b11 => {
          opcode = MoveWideOp_K
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let opcode = opcode;
    if sf == 0b0 & [hw[1]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'pos = UInt(hw @ 0b0000);
    execute_aarch64_instrs_integer_ins_ext_insert_movewide(d, datasize, imm, opcode, pos)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let imm16 = Slice(__opcode, 5, 16);
    let hw = Slice(__opcode, 21, 2);
    let opc = Slice(__opcode, 29, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide(Rd, imm16, hw, opc, sf)
}

val execute_aarch64_instrs_vector_transfer_vector_permute_unzip : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_permute_unzip (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operandl : bits('datasize) = V_read(datasize, n);
    let operandh : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let zipped : bits('datasize * 2) = operandh @ operandl;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, Elem_read(zipped, 2 * e + part, esize))
    };
    V_set(datasize, d) = result
}

val decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    execute_aarch64_instrs_vector_transfer_vector_permute_unzip(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip(Rd, Rn, op, Rm, size, Q)
}

val decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    execute_aarch64_instrs_vector_transfer_vector_permute_unzip(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip(Rd, Rn, op, Rm, size, Q)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3partw1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3partw1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Vd : bits(128) = V_read(128, d);
    result : bits(128) = undefined;
    result[95 .. 0] = EOR(EOR(Vd, Vn)[95 .. 0], (ROL(Vm[127 .. 96], 15) @ ROL(Vm[95 .. 64], 15)) @ ROL(Vm[63 .. 32], 15));
    foreach (i from 0 to 3 by 1 in inc) {
        if i == 3 then {
            result[127 .. 96] = EOR(EOR(Vd, Vn)[127 .. 96], ROL(result[31 .. 0], 15))
        } else ();
        result[32 * i + 31 .. 32 * i] = EOR(EOR(result[32 * i + 31 .. 32 * i], ROL(result[32 * i + 31 .. 32 * i], 15)), ROL(result[32 * i + 31 .. 32 * i], 23))
    };
    V_set(128, d) = result
}

val decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1 (Rd, Rn, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sm3_sm3partw1(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm ('minimum : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (d, datasize, elements, esize, m, minimum, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : int = undefined;
    element2 : int = undefined;
    maxmin : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(concat, 2 * e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(concat, 2 * e + 1, esize), is_unsigned);
        maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
        result = Elem_set(result, e, esize, maxmin[esize - 1 .. 0])
    };
    V_set(datasize, d) = result
}

val decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand : bits(32) = V_read(32, n);
    V_set(32, d) = ROL(operand, 30)
}

val decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash (Rd, Rn) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash(d, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash(Rd, Rn)
}

val execute_aarch64_instrs_memory_ordered : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_ordered (acctype, datasize, memop, n, regsize, t) = {
    data : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    let base : VirtualAddress = BaseReg_read__1(n);
    let address : bits(64) = VAddress(base);
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          let data : bits('datasize) = X_read(datasize, t);
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          Mem_set(address, dbytes, acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          AArch64_SetLSInstructionSyndrome(dbytes, false, t, regsize == 64, true);
          let data : bits('datasize) = Mem_read(address, dbytes, acctype);
          assert(constraint('regsize >= 'datasize));
          X_set(regsize, t) = ZeroExtend(data, regsize)
      },
      _ => ()
    }
}

val decode_ldarb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldarb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldarb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stllrh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stllrh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stllrh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stllrb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stllrb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stllrb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldlarh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldlarh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldlarh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldarh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldarh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldarh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldlarb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldlarb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldlarb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldar_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldar_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldar_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlrh_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlrh_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlrh_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stllr_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stllr_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stllr_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_ldlar_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldlar_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldlar_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlrb_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlrb_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlrb_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val decode_stlr_aarch64_instrs_memory_ordered : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stlr_aarch64_instrs_memory_ordered (Rt, Rn, Rt2, o0, Rs, L, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let 's = UInt(Rs);
    let acctype : AccType = if o0 == 0b0 then AccType_LIMITEDORDERED else AccType_ORDERED;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered(acctype, datasize, memop, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let size = Slice(__opcode, 30, 2);
    if (((((((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1) | [__opcode[16]] != 0b1) | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_stlr_aarch64_instrs_memory_ordered(Rt, Rn, Rt2, o0, Rs, L, size)
    }
}

val execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : forall 'd 'datasize 'm 'n ('setflags : Bool) 'shift_amount ('sub_op : Bool),
  (0 <= 'shift_amount & 'shift_amount <= 63 & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('setflags), int('shift_amount), ShiftType, bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (d, datasize, m, n, setflags, shift_amount, shift_type, sub_op) = {
    result : bits('datasize) = undefined;
    let operand1 : bits('datasize) = X_read(datasize, n);
    operand2 : bits('datasize) = ShiftReg(datasize, m, shift_type, shift_amount);
    nzcv : bits(4) = undefined;
    carry_in : bits(1) = undefined;
    if sub_op then {
        operand2 = not_vec(operand2);
        carry_in = 0b1
    } else {
        carry_in = 0b0
    };
    (result, nzcv) = AddWithCarry(operand1, operand2, carry_in);
    if setflags then {
        (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = nzcv
    } else ();
    X_set(datasize, d) = result
}

val decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg : (bits(5), bits(5), bits(6), bits(5), bits(2), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd, Rn, imm6, Rm, shift, S, op, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let setflags : bool = S == 0b1;
    if shift == 0b11 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & [imm6[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let shift_type : ShiftType = DecodeShift(shift);
    let 'shift_amount = UInt(imm6);
    execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(d, datasize, m, n, setflags, shift_amount, shift_type, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitone, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let shift = Slice(__opcode, 22, 2);
    let S = Slice(__opcode, 29, 1);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg(Rd, Rn, imm6, Rm, shift, S, op, sf)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), VBitOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (d, datasize, m, n, op) = {
    CheckFPAdvSIMDEnabled64();
    operand1 : bits('datasize) = undefined;
    operand2 : bits('datasize) = undefined;
    operand3 : bits('datasize) = undefined;
    let operand4 : bits('datasize) = V_read(datasize, n);
    match op {
      VBitOp_VEOR => {
          operand1 = V_read(datasize, m);
          operand2 = Zeros();
          operand3 = Ones()
      },
      VBitOp_VBSL => {
          operand1 = V_read(datasize, m);
          operand2 = operand1;
          operand3 = V_read(datasize, d)
      },
      VBitOp_VBIT => {
          operand1 = V_read(datasize, d);
          operand2 = operand1;
          operand3 = V_read(datasize, m)
      },
      VBitOp_VBIF => {
          operand1 = V_read(datasize, d);
          operand2 = operand1;
          operand3 = not_vec(V_read(datasize, m))
      }
    };
    let operand3 = operand3;
    let operand2 = operand2;
    let operand1 = operand1;
    V_set(datasize, d) = EOR(operand1, EOR(operand2, operand4) & operand3)
}

val decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd, Rn, Rm, opc2, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    op : VBitOp = undefined;
    match opc2 {
      0b00 => {
          op = VBitOp_VEOR
      },
      0b01 => {
          op = VBitOp_VBSL
      },
      0b10 => {
          op = VBitOp_VBIT
      },
      0b11 => {
          op = VBitOp_VBIF
      }
    };
    let op = op;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(d, datasize, m, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let opc2 = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor(Rd, Rn, Rm, opc2, Q)
}

val execute_aarch64_instrs_branch_conditional_cond : (bits(4), bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_conditional_cond (condition, offset) = {
    if ConditionHolds(condition) then {
        BranchToOffset(offset, BranchType_DIR)
    } else ()
}

val decode_b_cond_aarch64_instrs_branch_conditional_cond : (bits(4), bits(19)) -> unit effect {escape, rreg, undef, wreg}

function decode_b_cond_aarch64_instrs_branch_conditional_cond (cond, imm19) = {
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    let condition : bits(4) = cond;
    execute_aarch64_instrs_branch_conditional_cond(condition, offset)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) = {
    let cond = Slice(__opcode, 0, 4);
    let imm19 = Slice(__opcode, 5, 19);
    decode_b_cond_aarch64_instrs_branch_conditional_cond(cond, imm19)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm ('minimum : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), bool('minimum), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (d, datasize, elements, esize, m, minimum, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    maxmin : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
        result = Elem_set(result, e, esize, maxmin[esize - 1 .. 0])
    };
    V_set(datasize, d) = result
}

val decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let minimum : bool = o1 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(d, datasize, elements, esize, m, minimum, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (d, datasize, elements, esize, m, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        result = Elem_set(result, e, 2 * esize, (element1 * element2)[2 * esize - 1 .. 0])
    };
    V_set(2 * datasize, d) = result
}

val decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(Rd, Rn, Rm, size, U, Q)
}

val decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(d, datasize, elements, esize, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    diff : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        diff = element1 - element2;
        let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(diff, esize, is_unsigned) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(Rd, Rn, Rm, size, U)
}

val decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx : forall 'datasize ('is_signed : Bool) 'n ('postindex : Bool) 'regsize 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('is_signed), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx (acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback__arg) = {
    wback : bool = wback__arg;
    c : Constraint = undefined;
    data : bits('datasize) = undefined;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read(n, memop == MemOp_PREFETCH);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(datasize, t)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          } else ();
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          } else ();
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          if is_signed then {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = SignExtend(data, regsize)
          } else {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          let address : bits(64) = VAddress(base);
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = true;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt, Rn, imm9, opc, size) = {
    let wback : bool = true;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx(Rt, Rn, imm9, opc, size)
}

val decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            throw(Error_Undefined())
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi : forall 'd 'datasize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, wreg}

function execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (d, datasize, m, n, is_unsigned) = {
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = X_read(datasize, m);
    let 'result = asl_Int(operand1, is_unsigned) * asl_Int(operand2, is_unsigned);
    X_set(0 + (127 - 64 + 1), d) = result[127 .. 64]
}

val decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi : (bits(5), bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, wreg}

function decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (Rd, Rn, Ra, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = destsize;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(Rd, Rn, Ra, Rm, U)
    }
}

val decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi : (bits(5), bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, wreg}

function decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (Rd, Rn, Ra, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = destsize;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(d, datasize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    if ((([__opcode[10]] != 0b1 | [__opcode[11]] != 0b1) | [__opcode[12]] != 0b1) | [__opcode[13]] != 0b1) | [__opcode[14]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi(Rd, Rn, Ra, Rm, U)
    }
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('abs), CompareOp, int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (abs, cmp, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if abs then {
            element1 = FPAbs(element1);
            element2 = FPAbs(element2)
        } else ();
        match cmp {
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element1, element2, FPCR)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element1, element2, FPCR)
          },
          CompareOp_GT => {
              test_passed = FPCompareGT(element1, element2, FPCR)
          },
          _ => ()
        };
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd, Rn, ac, Rm, E, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(Rd, Rn, ac, Rm, E, U)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd, Rn, ac, Rm, sz, E, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd(Rd, Rn, ac, Rm, sz, E, U)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd, Rn, ac, Rm, E, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd(Rd, Rn, ac, Rm, E, U, Q)
}

val decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd : (bits(5), bits(5), bits(1), bits(5), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd, Rn, ac, Rm, sz, E, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    cmp : CompareOp = undefined;
    abs : bool = undefined;
    match (E @ U) @ ac {
      0b000 => {
          cmp = CompareOp_EQ;
          abs = false
      },
      0b010 => {
          cmp = CompareOp_GE;
          abs = false
      },
      0b011 => {
          cmp = CompareOp_GE;
          abs = true
      },
      0b110 => {
          cmp = CompareOp_GT;
          abs = false
      },
      0b111 => {
          cmp = CompareOp_GT;
          abs = true
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let abs = abs;
    let cmp = cmp;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd(abs, cmp, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let ac = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let E = Slice(__opcode, 23, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd(Rd, Rn, ac, Rm, sz, E, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : forall 'd 'datasize 'elements 'esize 'idxdsize 'index ('is_unsigned : Bool) 'm 'n 'part ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('sub_op), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    let operand3 : bits(2 * 'datasize) = V_read(2 * datasize, d);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    let 'element2 = asl_Int(Elem_read(operand2, index, esize), is_unsigned);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        product = (element1 * element2)[2 * esize - 1 .. 0];
        if sub_op then {
            result = Elem_set(result, e, 2 * esize, Elem_read(operand3, e, 2 * esize) - product)
        } else {
            result = Elem_set(result, e, 2 * esize, Elem_read(operand3, e, 2 * esize) + product)
        }
    };
    V_set(2 * datasize, d) = result
}

val decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd, Rn, H, o2, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(d, datasize, elements, esize, idxdsize, index, m, n, part, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long(Rd, Rn, H, o2, Rm, M, L, size, U, Q)
}

val execute_aarch64_instrs_branch_unconditional_register : forall ('n : Int), (0 <= 'n & 'n <= 31).
  (BranchType, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_unconditional_register (branch_type, n) = {
    target : bits(129) = undefined;
    if [CCTLR_read__1()[3]] == 0b1 then {
        target = CapSetOffset(PCC_read(), X_read(63 - 0 + 1, n))
    } else {
        target = CapSetValue(PCC_read(), X_read(63 - 0 + 1, n))
    };
    if branch_type == BranchType_INDCALL then {
        if IsInC64() then {
            if [CCTLR_read__1()[7]] == 0b1 then {
                C_set(30) = CapSetObjectType(CapAdd__1(PCC_read(), 5), CAP_SEAL_TYPE_RB)
            } else {
                C_set(30) = CapAdd__1(PCC_read(), 5)
            }
        } else if [CCTLR_read__1()[3]] == 0b1 then {
            X_set(64, 30) = PC_read() + 4 - CapGetBase(PCC_read())
        } else {
            X_set(64, 30) = PC_read() + 4
        }
    } else ();
    BranchToCapability(target, branch_type)
}

val decode_bra_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bra_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    let 'n = UInt(Rn);
    branch_type : BranchType = undefined;
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_bra_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_reta_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_reta_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    let 'n = UInt(Rn);
    branch_type : BranchType = undefined;
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_reta_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_br_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_br_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    let 'n = UInt(Rn);
    branch_type : BranchType = undefined;
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_br_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_ret_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ret_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    let 'n = UInt(Rn);
    branch_type : BranchType = undefined;
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_ret_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_blra_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_blra_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    let 'n = UInt(Rn);
    branch_type : BranchType = undefined;
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_blra_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val decode_blr_aarch64_instrs_branch_unconditional_register : (bits(5), bits(5), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_blr_aarch64_instrs_branch_unconditional_register (Rm, Rn, M, A, op, Z) = {
    let 'n = UInt(Rn);
    branch_type : BranchType = undefined;
    match op {
      0b00 => {
          branch_type = BranchType_INDIR
      },
      0b01 => {
          branch_type = BranchType_INDCALL
      },
      0b10 => {
          branch_type = BranchType_RET
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let branch_type = branch_type;
    execute_aarch64_instrs_branch_unconditional_register(branch_type, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let Rm = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let M = Slice(__opcode, 10, 1);
    let A = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 21, 2);
    let Z = Slice(__opcode, 24, 1);
    decode_blr_aarch64_instrs_branch_unconditional_register(Rm, Rn, M, A, op, Z)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Vd : bits(128) = V_read(128, d);
    result : bits(128) = undefined;
    let WjPrime : bits(32) = Elem_read(Vm, i, 32);
    let SS2 : bits(32) = EOR(Vn[127 .. 96], ROL(Vd[127 .. 96], 12));
    TT1 : bits(32) = EOR(Vd[63 .. 32], EOR(Vd[127 .. 96], Vd[95 .. 64]));
    let TT1 : bits(32) = (TT1 + Vd[31 .. 0] + SS2 + WjPrime)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 9);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = TT1;
    V_set(128, d) = result
}

val decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a(d, i, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : int = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        match comparison {
          CompareOp_GT => {
              test_passed = element > 0
          },
          CompareOp_GE => {
              test_passed = element >= 0
          },
          CompareOp_EQ => {
              test_passed = element == 0
          },
          CompareOp_LE => {
              test_passed = element <= 0
          },
          CompareOp_LT => {
              test_passed = element < 0
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd : (bits(5), bits(5), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd, Rn, op, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(Rd, Rn, op, size, U)
}

val decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    comparison : CompareOp = undefined;
    match op @ U {
      0b00 => {
          comparison = CompareOp_GT
      },
      0b01 => {
          comparison = CompareOp_GE
      },
      0b10 => {
          comparison = CompareOp_EQ
      },
      0b11 => {
          comparison = CompareOp_LE
      }
    };
    let comparison = comparison;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd(Rd, Rn, op, size, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    X : bits(128) = V_read(128, d);
    Y : bits(32) = V_read(32, n);
    let W : bits(128) = V_read(128, m);
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAchoose(X[63 .. 32], X[95 .. 64], X[127 .. 96]);
        Y = Y + ROL(X[31 .. 0], 5) + t + Elem_read(W, e, 32);
        X[63 .. 32] = ROL(X[63 .. 32], 30);
        (Y @ X) = ROL(Y @ X, 32)
    };
    V_set(128, d) = X
}

val decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose(d, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_transfer_vector_table : forall 'd 'datasize 'elements ('is_tbl : Bool) 'm 'n 'regs,
  ('regs in {1, 2, 3, 4} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), bool('is_tbl), int('m), int('n), int('regs)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_table (d, datasize, elements, is_tbl, m, n__arg, regs) = {
    n : int = n__arg;
    CheckFPAdvSIMDEnabled64();
    let indices : bits('datasize) = V_read(datasize, m);
    table : bits(128 * 'regs) = Zeros();
    index : int = undefined;
    foreach (i from 0 to (regs - 1) by 1 in inc) {
        table[128 * i + 127 .. 128 * i] = V_read(0 + (128 * i + 127 - 128 * i + 1), n);
        n = MOD(n + 1, 32)
    };
    result : bits('datasize) = if is_tbl then Zeros() else V_read(datasize, d);
    foreach (i from 0 to (elements - 1) by 1 in inc) {
        index = UInt(Elem_read(indices, i, 8));
        let 'index = index in
          {
              if index < 16 * regs then {
                  result = Elem_set(result, i, 8, Elem_read(table, index, 8))
              } else ()
          };
        ()
    };
    V_set(datasize, d) = result
}

val decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table : (bits(5), bits(5), bits(1), bits(2), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table (Rd, Rn, op, len, Rm, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    let 'regs = UInt(len) + 1;
    let is_tbl : bool = op == 0b0;
    execute_aarch64_instrs_vector_transfer_vector_table(d, datasize, elements, is_tbl, m, n, regs)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let len = Slice(__opcode, 13, 2);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table(Rd, Rn, op, len, Rm, Q)
}

val decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table : (bits(5), bits(5), bits(1), bits(2), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table (Rd, Rn, op, len, Rm, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    let 'regs = UInt(len) + 1;
    let is_tbl : bool = op == 0b0;
    execute_aarch64_instrs_vector_transfer_vector_table(d, datasize, elements, is_tbl, m, n, regs)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 12, 1);
    let len = Slice(__opcode, 13, 2);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table(Rd, Rn, op, len, Rm, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(concat, 2 * e, esize);
        element2 = Elem_read(concat, 2 * e + 1, esize);
        result = Elem_set(result, e, esize, element1 + element2)
    };
    V_set(datasize, d) = result
}

val decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_widen : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {16, 32} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_float_widen (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart_read(datasize, n, part);
    result : bits(2 * 'datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, 2 * esize, FPConvert__1(2 * esize, Elem_read(operand, e, esize), FPCR))
    };
    V_set(2 * datasize, d) = result
}

val decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (16 << UInt(sz));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {16, 32}));
    execute_aarch64_instrs_vector_arithmetic_unary_float_widen(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        if neg then {
            element = negate(element)
        } else {
            element = Abs(element)
        };
        result = Elem_set(result, e, esize, element[esize - 1 .. 0])
    };
    V_set(datasize, d) = result
}

val decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(Rd, Rn, size, U)
}

val decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd(Rd, Rn, size, U, Q)
}

val decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(Rd, Rn, size, U)
}

val decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_system_exceptions_runtime_smc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_exceptions_runtime_smc imm = {
    AArch64_CheckForSMCUndefOrTrap(imm);
    if Slice(SCR_EL3, 7, 1) == 0b1 then {
        throw(Error_Undefined())
    } else {
        AArch64_CallSecureMonitor(imm)
    }
}

val decode_smc_aarch64_instrs_system_exceptions_runtime_smc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function decode_smc_aarch64_instrs_system_exceptions_runtime_smc imm16 = {
    let imm : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_runtime_smc(imm)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone] as __opcode)) = {
    let imm16 = Slice(__opcode, 5, 16);
    decode_smc_aarch64_instrs_system_exceptions_runtime_smc(imm16)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long : forall 'd 'datasize 'elements 'esize 'idxdsize 'index ('is_unsigned : Bool) 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long (d, datasize, elements, esize, idxdsize, index, m, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    let 'element2 = asl_Int(Elem_read(operand2, index, esize), is_unsigned);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        product = (element1 * element2)[2 * esize - 1 .. 0];
        result = Elem_set(result, e, 2 * esize, product)
    };
    V_set(2 * datasize, d) = result
}

val decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long(d, datasize, elements, esize, idxdsize, index, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long (Rd, Rn, H, Rm, M, L, size, U, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long(d, datasize, elements, esize, idxdsize, index, m, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long(Rd, Rn, H, Rm, M, L, size, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(128, d);
    let operand2 : bits(128) = V_read(128, n);
    let operand3 : bits(128) = V_read(128, m);
    result : bits(128) = operand2[63 .. 0] @ operand1[127 .. 64];
    let result : bits(128) = EOR(EOR(result, operand1), operand3);
    V_set(128, d) = result
}

val decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0(d, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_aes_round : forall 'd ('decrypt : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bool('decrypt), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_aes_round (d, decrypt, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(128, d);
    let operand2 : bits(128) = V_read(128, n);
    result : bits(128) = EOR(operand1, operand2);
    if decrypt then {
        result = AESInvSubBytes(AESInvShiftRows(result))
    } else {
        result = AESSubBytes(AESShiftRows(result))
    };
    V_set(128, d) = result
}

val decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    } else ();
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_round(d, decrypt, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round(Rd, Rn, D)
}

val decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    } else ();
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_round(d, decrypt, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round(Rd, Rn, D)
}

val execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise : forall ('acc : Bool) 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (bool('acc), int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise (acc, d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    sum : bits(2 * 'esize) = undefined;
    op1 : int = undefined;
    op2 : int = undefined;
    result : bits('datasize) = if acc then V_read(datasize, d) else Zeros();
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        op1 = asl_Int(Elem_read(operand, 2 * e + 0, esize), is_unsigned);
        op2 = asl_Int(Elem_read(operand, 2 * e + 1, esize), is_unsigned);
        sum = (op1 + op2)[2 * esize - 1 .. 0];
        result = Elem_set(result, e, 2 * esize, Elem_read(result, e, 2 * esize) + sum)
    };
    V_set(datasize, d) = result
}

val decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise : (bits(5), bits(5), bits(1), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd, Rn, op, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 2 * esize);
    let acc : bool = op == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise(acc, d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise(Rd, Rn, op, size, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3_xar : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bits(6), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3_xar (d, imm6, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let tmp : bits(128) = EOR(Vn, Vm);
    V_set(0 + (127 - 64 + 1) + (0 + (63 - 0 + 1)), d) = ROR(tmp[127 .. 64], UInt(imm6)) @ ROR(tmp[63 .. 0], UInt(imm6))
}

val decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar : (bits(5), bits(5), bits(6), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar (Rd, Rn, imm6, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha3_xar(d, imm6, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm6 = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar(Rd, Rn, imm6, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 : forall 'd 'datasize 'elements 'esize 'n ('neg : Bool),
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('neg)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (d, datasize, elements, esize, n, neg) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        if neg then {
            element = FPNeg(element)
        } else {
            element = FPAbs(element)
        };
        result = Elem_set(result, e, esize, element)
    };
    V_set(datasize, d) = result
}

val decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(Rd, Rn, U, Q)
}

val decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float(Rd, Rn, sz, U, Q)
}

val decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(Rd, Rn, U, Q)
}

val decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let neg : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16(d, datasize, elements, esize, n, neg)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float(Rd, Rn, sz, U, Q)
}

val execute_aarch64_instrs_vector_shift_left_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_left_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((0 <= 'loop_e * 'esize & 'loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('datasize in {8, 16, 32, 64, 128}))));
        result = Elem_set(result, e, esize, LSL(Elem_read(operand, e, esize), shift))
    };
    V_set(datasize, d) = result
}

val decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd : (bits(5), bits(5), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd (Rd, Rn, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd(Rd, Rn, immb, immh)
}

val decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd (Rd, Rn, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = UInt(immh @ immb) - esize;
    execute_aarch64_instrs_vector_shift_left_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd(Rd, Rn, immb, immh, Q)
}

val execute_aarch64_instrs_system_register_system : forall ('read : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  (0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 in {2, 3} & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (bool('read), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_register_system (read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if read then {
        X_set(64, t) = AArch64_SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
    } else {
        AArch64_SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X_read(64, t))
    }
}

val decode_mrs_aarch64_instrs_system_register_system : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mrs_aarch64_instrs_system_register_system (Rt, op2, CRm, CRn, op1, o0, L) = {
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    execute_aarch64_instrs_system_register_system(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let o0 = Slice(__opcode, 19, 1);
    let L = Slice(__opcode, 21, 1);
    decode_mrs_aarch64_instrs_system_register_system(Rt, op2, CRm, CRn, op1, o0, L)
}

val decode_msr_reg_aarch64_instrs_system_register_system : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_msr_reg_aarch64_instrs_system_register_system (Rt, op2, CRm, CRn, op1, o0, L) = {
    AArch64_CheckSystemAccess(0b1 @ o0, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 2 + UInt(o0);
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let read : bool = L == 0b1;
    execute_aarch64_instrs_system_register_system(read, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let o0 = Slice(__opcode, 19, 1);
    let L = Slice(__opcode, 21, 1);
    decode_msr_reg_aarch64_instrs_system_register_system(Rt, op2, CRm, CRn, op1, o0, L)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPMul(element1, element2, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product(Rd, Rn, Rm, Q)
}

val decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_memory_single_general_immediate_unsigned : forall 'datasize ('is_signed : Bool) 'n ('postindex : Bool) 'regsize 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('regsize), bool('is_signed), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_general_immediate_unsigned (acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback__arg) = {
    wback : bool = wback__arg;
    c : Constraint = undefined;
    data : bits('datasize) = undefined;
    wb_unknown : bool = false;
    rt_unknown : bool = false;
    if ((memop == MemOp_LOAD & wback) & n == t) & n != 31 then {
        c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
        assert(c == Constraint_WBSUPPRESS | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_WBSUPPRESS => {
              wback = false
          },
          Constraint_UNKNOWN => {
              wb_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    if ((memop == MemOp_STORE & wback) & n == t) & n != 31 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
        assert(c == Constraint_NONE | c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_NONE => {
              rt_unknown = false
          },
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read(n, memop == MemOp_PREFETCH);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          if rt_unknown then {
              data = __UNKNOWN_bits(datasize)
          } else {
              data = X_read(datasize, t)
          };
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), false, t, regsize == 64, false)
          } else ();
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          if not_bool(wback) then {
              AArch64_SetLSInstructionSyndrome(DIV(datasize, 8), is_signed, t, regsize == 64, false)
          } else ();
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          if is_signed then {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = SignExtend(data, regsize)
          } else {
              assert(constraint('regsize >= 'datasize));
              X_set(regsize, t) = ZeroExtend(data, regsize)
          }
      },
      MemOp_PREFETCH => {
          let address : bits(64) = VAddress(base);
          Prefetch(address, t[4 .. 0])
      }
    };
    if wback then {
        if wb_unknown then {
            base = __UNKNOWN_VirtualAddress()
        } else {
            base = VAAdd(base, offset)
        };
        BaseReg_set(n) = base
    } else ()
}

val decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned : (bits(5), bits(5), bits(12), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt, Rn, imm12, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt(size);
    let offset : bits(64) = LSL(ZeroExtend(imm12, 64), scale);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_NORMAL;
    memop : MemOp = undefined;
    is_signed : bool = undefined;
    regsize : {|32, 64|} = 32;
    if [opc[1]] == 0b0 then {
        memop = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
        regsize = if size == 0b11 then 64 else 32;
        is_signed = false
    } else {
        if size == 0b11 then {
            memop = MemOp_PREFETCH;
            if [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ()
        } else {
            memop = MemOp_LOAD;
            if size == 0b10 & [opc[0]] == 0b1 then {
                throw(Error_Undefined())
            } else ();
            regsize = if [opc[0]] == 0b1 then 32 else 64;
            is_signed = true
        }
    };
    let 'regsize = regsize;
    let 'datasize = (8 << scale);
    execute_aarch64_instrs_memory_single_general_immediate_unsigned(acctype, datasize, memop, n, offset, postindex, regsize, is_signed, t, wback)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm12 = Slice(__opcode, 10, 12);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned(Rt, Rn, imm12, opc, size)
}

val execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : forall 'a 'd 'datasize 'destsize ('is_unsigned : Bool) 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'destsize == 64 & 'datasize == 32 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('datasize), int('destsize), int('m), int('n), bool('sub_op), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (a, d, datasize, destsize, m, n, sub_op, is_unsigned) = {
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = X_read(datasize, m);
    let operand3 : bits('destsize) = X_read(destsize, a);
    result : int = undefined;
    if sub_op then {
        result = asl_Int(operand3, is_unsigned) - asl_Int(operand1, is_unsigned) * asl_Int(operand2, is_unsigned)
    } else {
        result = asl_Int(operand3, is_unsigned) + asl_Int(operand1, is_unsigned) * asl_Int(operand2, is_unsigned)
    };
    let 'result = result;
    X_set(0 + (63 - 0 + 1), d) = result[63 .. 0]
}

val decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd, Rn, Ra, o0, Rm, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    let 'destsize = 64;
    let 'datasize = 32;
    let sub_op : bool = o0 == 0b1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64(a, d, datasize, destsize, m, n, sub_op, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 23, 1);
    decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64(Rd, Rn, Ra, o0, Rm, U)
}

val execute_aarch64_instrs_memory_single_simdfp_register : forall 'datasize 'm 'n ('postindex : Bool) 'shift 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 'shift in {0, 1, 2, 3, 4, 5, 6, 7} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (AccType, int('datasize), ExtendType, int('m), MemOp, int('n), bool('postindex), int('shift), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_simdfp_register (acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback) = {
    let offset : bits(64) = ExtendReg(64, m, extend_type, shift);
    CheckFPAdvSIMDEnabled64();
    data : bits('datasize) = undefined;
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(datasize, t);
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          assert(constraint((div('datasize, 8) == 1 | div('datasize, 8) == 2 | div('datasize, 8) == 4 | div('datasize, 8) == 8 | div('datasize, 8) == 16)));
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          V_set(datasize, t) = data
      },
      _ => ()
    };
    if wback then {
        let base : VirtualAddress = VAAdd(base, offset);
        BaseReg_set(n) = base
    } else ()
}

val decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_register(acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register : (bits(5), bits(5), bits(1), bits(3), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register (Rt, Rn, S, option_name, Rm, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    if [option_name[1]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let extend_type : ExtendType = DecodeRegExtend(option_name);
    let 'shift = if S == 0b1 then scale else 0;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 'm = UInt(Rm);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_register(acctype, datasize, extend_type, m, memop, n, postindex, shift, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let S = Slice(__opcode, 12, 1);
    let option_name = Slice(__opcode, 13, 3);
    let Rm = Slice(__opcode, 16, 5);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register(Rt, Rn, S, option_name, Rm, opc, size)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512su1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha512_sha512su1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let X : bits(128) = V_read(128, n);
    let Y : bits(128) = V_read(128, m);
    let W : bits(128) = V_read(128, d);
    sig1 : bits(64) = EOR(EOR(ROR(X[127 .. 64], 19), ROR(X[127 .. 64], 61)), 0b000000 @ X[127 .. 70]);
    Vtmp[127 .. 64] = W[127 .. 64] + sig1 + Y[127 .. 64];
    let sig1 : bits(64) = EOR(EOR(ROR(X[63 .. 0], 19), ROR(X[63 .. 0], 61)), 0b000000 @ X[63 .. 6]);
    Vtmp[63 .. 0] = W[63 .. 0] + sig1 + Y[63 .. 0];
    V_set(128, d) = Vtmp
}

val decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1 (Rd, Rn, Rm) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha512_sha512su1(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp : forall 'd 'datasize 'elements 'esize ('is_signed : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_signed)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (d, datasize, elements, esize, m, n, is_signed) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = V_read(datasize, d);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        res : int = 0;
        element1 : int = undefined;
        element2 : int = undefined;
        foreach (i from 0 to 3 by 1 in inc) {
            if is_signed then {
                element1 = SInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = SInt(Elem_read(operand2, 4 * e + i, DIV(esize, 4)))
            } else {
                element1 = UInt(Elem_read(operand1, 4 * e + i, DIV(esize, 4)));
                element2 = UInt(Elem_read(operand2, 4 * e + i, DIV(esize, 4)))
            };
            res = res + element1 * element2
        };
        let 'res = res;
        result = Elem_set(result, e, esize, Elem_read(result, e, esize) + res)
    };
    V_set(datasize, d) = result
}

val decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (Rd, Rn, Rm, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    } else ();
    if size != 0b10 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(d, datasize, elements, esize, m, n, is_signed)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(Rd, Rn, Rm, size, U, Q)
}

val decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (Rd, Rn, Rm, size, U, Q) = {
    if not_bool(HaveDOTPExt()) then {
        throw(Error_Undefined())
    } else ();
    if size != 0b10 then {
        throw(Error_Undefined())
    } else ();
    let is_signed : bool = U == 0b0;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(d, datasize, elements, esize, m, n, is_signed)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    sum : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        sum = element1 + element2;
        result = Elem_set(result, e, esize, sum[esize .. 1])
    };
    V_set(datasize, d) = result
}

val decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(Rd, Rn, Rm, size, U, Q)
}

val decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_shift_conv_int_sisd : forall 'd 'datasize 'elements 'esize 'fracbits ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('fracbits), int('n), FPRounding, bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_conv_int_sisd (d, datasize, elements, esize, fracbits, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FixedToFP(esize, element, fracbits, is_unsigned, FPCR, rounding))
    };
    V_set(datasize, d) = result
}

val decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd(Rd, Rn, immb, immh, U)
}

val decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd (Rd, Rn, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd(Rd, Rn, immb, immh, U, Q)
}

val decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd (Rd, Rn, immb, immh, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = esize;
    let 'elements = 1;
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd(Rd, Rn, immb, immh, U)
}

val decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd : (bits(5), bits(5), bits(3), bits(4), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd (Rd, Rn, immb, immh, U, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if (match immh {
      [bitzero, bitzero, bitzero, _] => true,
      _ => false
    }) : bool | (match immh {
      [bitzero, bitzero, bitone, _] => true,
      _ => false
    }) : bool & not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = if (match immh {
      [bitone, _, _, _] => true,
      _ => false
    }) : bool then 64 else if (match immh {
      [bitzero, bitone, _, _] => true,
      _ => false
    }) : bool then 32 else 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'fracbits = esize * 2 - UInt(immh @ immb);
    let is_unsigned : bool = U == 0b1;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    execute_aarch64_instrs_vector_shift_conv_int_sisd(d, datasize, elements, esize, fracbits, n, rounding, is_unsigned)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd(Rd, Rn, immb, immh, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 : forall 'd 'datasize 'elements 'esize 'm 'n ('pair : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('pair)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (d, datasize, elements, esize, m, n, pair) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let concat : bits(2 * 'datasize) = operand2 @ operand1;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        if pair then {
            element1 = Elem_read(concat, 2 * e, esize);
            element2 = Elem_read(concat, 2 * e + 1, esize)
        } else {
            element1 = Elem_read(operand1, e, esize);
            element2 = Elem_read(operand2, e, esize)
        };
        result = Elem_set(result, e, esize, FPAdd(element1, element2, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(Rd, Rn, Rm, U, Q)
}

val decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp(Rd, Rn, Rm, sz, U, Q)
}

val decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(Rd, Rn, Rm, U, Q)
}

val decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let pair : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16(d, datasize, elements, esize, m, n, pair)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp(Rd, Rn, Rm, sz, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512su0 : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha512_sha512su0 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let X : bits(128) = V_read(128, n);
    let W : bits(128) = V_read(128, d);
    sig0 : bits(64) = EOR(EOR(ROR(W[127 .. 64], 1), ROR(W[127 .. 64], 8)), 0b0000000 @ W[127 .. 71]);
    Vtmp[63 .. 0] = W[63 .. 0] + sig0;
    let sig0 : bits(64) = EOR(EOR(ROR(X[63 .. 0], 1), ROR(X[63 .. 0], 8)), 0b0000000 @ X[63 .. 7]);
    Vtmp[127 .. 64] = W[127 .. 64] + sig0;
    V_set(128, d) = Vtmp
}

val decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0 : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0 (Rd, Rn) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    execute_aarch64_instrs_vector_crypto_sha512_sha512su0(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0(Rd, Rn)
}

val execute_aarch64_instrs_vector_crypto_aes_mix : forall 'd ('decrypt : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), bool('decrypt), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_aes_mix (d, decrypt, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand : bits(128) = V_read(128, n);
    result : bits(128) = undefined;
    if decrypt then {
        result = AESInvMixColumns(operand)
    } else {
        result = AESMixColumns(operand)
    };
    V_set(128, d) = result
}

val decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    } else ();
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_mix(d, decrypt, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix(Rd, Rn, D)
}

val decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix (Rd, Rn, D) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveAESExt()) then {
        throw(Error_Undefined())
    } else ();
    let decrypt : bool = D == 0b1;
    execute_aarch64_instrs_vector_crypto_aes_mix(d, decrypt, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let D = Slice(__opcode, 12, 1);
    decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix(Rd, Rn, D)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (bool('abs), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd (abs, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    diff : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        diff = FPSub(element1, element2, FPCR);
        result = Elem_set(result, e, esize, if abs then FPAbs(diff) else diff)
    };
    V_set(datasize, d) = result
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let abs : bool = true;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(Rd, Rn, Rm)
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let abs : bool = true;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd(Rd, Rn, Rm, sz)
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(Rd, Rn, Rm, U, Q)
}

val decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd(Rd, Rn, Rm, sz, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), FPRounding, bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (d, datasize, elements, esize, n, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPToFixed(esize, element, 0, is_unsigned, FPCR, rounding))
    };
    V_set(datasize, d) = result
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(Rd, Rn, U)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd(Rd, Rn, sz, U)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd(Rd, Rn, U, Q)
}

val decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd(Rd, Rn, sz, U, Q)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(Rd, Rn, U)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd(Rd, Rn, sz, U)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd(Rd, Rn, U, Q)
}

val decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let rounding : FPRounding = FPRounding_TIEAWAY;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd(d, datasize, elements, esize, n, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd(Rd, Rn, sz, U, Q)
}

val execute_aarch64_instrs_vector_reduce_add_long : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_add_long (d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    sum : int = asl_Int(Elem_read(operand, 0, esize), is_unsigned);
    foreach (e from 1 to (elements - 1) by 1 in inc) {
        sum = sum + asl_Int(Elem_read(operand, e, esize), is_unsigned)
    };
    let 'sum = sum;
    V_set(0 + (2 * esize - 1 - 0 + 1), d) = sum[2 * esize - 1 .. 0]
}

val decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_reduce_add_long(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long(Rd, Rn, size, U, Q)
}

val decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b100 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_reduce_add_long(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRecipEstimate(element, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(Rd, Rn)
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd(Rd, Rn, sz)
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd(Rd, Rn, Q)
}

val decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_float_convert_fix : forall 'd 'fltsize 'fracbits 'intsize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'intsize in {32, 64} & 1 <= 'fracbits & 'fracbits <= 64 & 'fltsize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('fltsize), int('fracbits), int('intsize), int('n), FPConvOp, FPRounding, bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_convert_fix (d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    fltval : bits('fltsize) = undefined;
    intval : bits('intsize) = undefined;
    match op {
      FPConvOp_CVT_FtoI => {
          let fltval : bits('fltsize) = V_read(fltsize, n);
          let intval : bits('intsize) = FPToFixed(intsize, fltval, fracbits, is_unsigned, FPCR, rounding);
          X_set(intsize, d) = intval
      },
      FPConvOp_CVT_ItoF => {
          let intval : bits('intsize) = X_read(intsize, n);
          let fltval : bits('fltsize) = FixedToFP(fltsize, intval, fracbits, is_unsigned, FPCR, rounding);
          V_set(fltsize, d) = fltval
      },
      _ => ()
    }
}

val decode_scvtf_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_scvtf_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix : (bits(5), bits(5), bits(6), bits(3), bits(2), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix (Rd, Rn, scale, opcode, rmode, ftype, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'intsize = if sf == 0b1 then 64 else 32;
    fltsize : {|16, 32, 64|} = 16;
    op : FPConvOp = undefined;
    rounding : FPRounding = undefined;
    is_unsigned : bool = undefined;
    match ftype {
      0b00 => {
          fltsize = 32
      },
      0b01 => {
          fltsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              fltsize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'fltsize = fltsize;
    if sf == 0b0 & [scale[5]] == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'fracbits = 64 - UInt(scale);
    match opcode[2 .. 1] @ rmode {
      0b0011 => {
          rounding = FPRounding_ZERO;
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_FtoI
      },
      0b0100 => {
          rounding = FPRoundingMode(FPCR);
          is_unsigned = [opcode[0]] == 0b1;
          op = FPConvOp_CVT_ItoF
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    execute_aarch64_instrs_float_convert_fix(d, fltsize, fracbits, intsize, n, op, rounding, is_unsigned)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let scale = Slice(__opcode, 10, 6);
    let opcode = Slice(__opcode, 16, 3);
    let rmode = Slice(__opcode, 19, 2);
    let ftype = Slice(__opcode, 22, 2);
    let sf = Slice(__opcode, 31, 1);
    decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix(Rd, Rn, scale, opcode, rmode, ftype, sf)
}

val execute_aarch64_instrs_float_arithmetic_unary : forall 'd 'datasize 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), FPUnaryOp, int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_unary (d, datasize, fpop, n) = {
    CheckFPAdvSIMDEnabled64();
    result : bits('datasize) = undefined;
    let operand : bits('datasize) = V_read(datasize, n);
    match fpop {
      FPUnaryOp_MOV => {
          result = operand
      },
      FPUnaryOp_ABS => {
          result = FPAbs(operand)
      },
      FPUnaryOp_NEG => {
          result = FPNeg(operand)
      },
      FPUnaryOp_SQRT => {
          result = FPSqrt(operand, FPCR)
      }
    };
    let result = result;
    V_set(datasize, d) = result
}

val decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, datasize, fpop, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val decode_fmov_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmov_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, datasize, fpop, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmov_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val decode_fneg_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fneg_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, datasize, fpop, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fneg_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val decode_fabs_float_aarch64_instrs_float_arithmetic_unary : (bits(5), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fabs_float_aarch64_instrs_float_arithmetic_unary (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    fpop : FPUnaryOp = undefined;
    match opc {
      0b00 => {
          fpop = FPUnaryOp_MOV
      },
      0b01 => {
          fpop = FPUnaryOp_ABS
      },
      0b10 => {
          fpop = FPUnaryOp_NEG
      },
      0b11 => {
          fpop = FPUnaryOp_SQRT
      }
    };
    let fpop = fpop;
    execute_aarch64_instrs_float_arithmetic_unary(d, datasize, fpop, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fabs_float_aarch64_instrs_float_arithmetic_unary(Rd, Rn, opc, ftype)
}

val execute_aarch64_instrs_memory_ordered_rcpc : forall 'datasize 'n 'regsize 't,
  (0 <= 't & 't <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64}).
  (AccType, int('datasize), int('n), int('regsize), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_ordered_rcpc (acctype, datasize, n, regsize, t) = {
    let 'dbytes = DIV(datasize, 8);
    let base : VirtualAddress = BaseReg_read__1(n);
    let address : bits(64) = VAddress(base);
    VACheckAddress(base, address, dbytes, CAP_PERM_LOAD, acctype);
    let data : bits('datasize) = Mem_read(address, dbytes, acctype);
    assert(constraint('regsize >= 'datasize));
    X_set(regsize, t) = ZeroExtend(data, regsize)
}

val decode_ldapr_aarch64_instrs_memory_ordered_rcpc : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldapr_aarch64_instrs_memory_ordered_rcpc (Rt, Rn, Rs, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ORDERED;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered_rcpc(acctype, datasize, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitone, _, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldapr_aarch64_instrs_memory_ordered_rcpc(Rt, Rn, Rs, size)
    }
}

val decode_ldaprb_aarch64_instrs_memory_ordered_rcpc : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaprb_aarch64_instrs_memory_ordered_rcpc (Rt, Rn, Rs, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ORDERED;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered_rcpc(acctype, datasize, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaprb_aarch64_instrs_memory_ordered_rcpc(Rt, Rn, Rs, size)
    }
}

val decode_ldaprh_aarch64_instrs_memory_ordered_rcpc : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldaprh_aarch64_instrs_memory_ordered_rcpc (Rt, Rn, Rs, size) = {
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let acctype : AccType = AccType_ORDERED;
    let 'elsize = (8 << UInt(size));
    let 'regsize = if elsize == 64 then 64 else 32;
    let 'datasize = elsize;
    execute_aarch64_instrs_memory_ordered_rcpc(acctype, datasize, n, regsize, t)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rs = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 30, 2);
    if ((([__opcode[16]] != 0b1 | [__opcode[17]] != 0b1) | [__opcode[18]] != 0b1) | [__opcode[19]] != 0b1) | [__opcode[20]] != 0b1 then {
        throw(Error_ConstrainedUnpredictable())
    } else {
        decode_ldaprh_aarch64_instrs_memory_ordered_rcpc(Rt, Rn, Rs, size)
    }
}

val execute_aarch64_instrs_system_sysops : forall ('has_result : Bool) 'sys_crm 'sys_crn 'sys_op0 'sys_op1 'sys_op2 't,
  (0 <= 't & 't <= 31 & 'sys_op2 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op1 in {0, 1, 2, 3, 4, 5, 6, 7} & 'sys_op0 == 1 & 0 <= 'sys_crn & 'sys_crn <= 15 & 0 <= 'sys_crm & 'sys_crm <= 15).
  (bool('has_result), int('sys_crm), int('sys_crn), int('sys_op0), int('sys_op1), int('sys_op2), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_sysops (has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t) = {
    if has_result then {
        X_set(64, t) = AArch64_SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2)
    } else {
        if AArch64_SysInstrInputIsCapability(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2) then {
            AArch64_SysInstrWithCapability(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, C_read(t))
        } else {
            AArch64_SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X_read(64, t))
        }
    }
}

val decode_sys_aarch64_instrs_system_sysops : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sys_aarch64_instrs_system_sysops (Rt, op2, CRm, CRn, op1, L) = {
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let has_result : bool = L == 0b1;
    execute_aarch64_instrs_system_sysops(has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let L = Slice(__opcode, 21, 1);
    decode_sys_aarch64_instrs_system_sysops(Rt, op2, CRm, CRn, op1, L)
}

val decode_sysl_aarch64_instrs_system_sysops : (bits(5), bits(3), bits(4), bits(4), bits(3), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sysl_aarch64_instrs_system_sysops (Rt, op2, CRm, CRn, op1, L) = {
    AArch64_CheckSystemAccess(0b01, op1, CRn, CRm, op2, Rt, L);
    let 't = UInt(Rt);
    let 'sys_op0 = 1;
    let 'sys_op1 = UInt(op1);
    let 'sys_op2 = UInt(op2);
    let 'sys_crn = UInt(CRn);
    let 'sys_crm = UInt(CRm);
    let has_result : bool = L == 0b1;
    execute_aarch64_instrs_system_sysops(has_result, sys_crm, sys_crn, sys_op0, sys_op1, sys_op2, t)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let CRn = Slice(__opcode, 12, 4);
    let op1 = Slice(__opcode, 16, 3);
    let L = Slice(__opcode, 21, 1);
    decode_sysl_aarch64_instrs_system_sysops(Rt, op2, CRm, CRn, op1, L)
}

val execute_aarch64_instrs_integer_crc : forall ('crc32c : Bool) 'd 'm 'n 'size,
  ('size in {8, 16, 32, 64} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (bool('crc32c), int('d), int('m), int('n), int('size)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_crc (crc32c, d, m, n, size) = {
    let acc : bits(32) = X_read(32, n);
    let val_name : bits('size) = X_read(size, m);
    let poly : bits(32) = (if crc32c then UInt(0x1EDC6F41) else UInt(0x04C11DB7))[31 .. 0];
    let tempacc : bits(32 + 'size) = BitReverse(acc) @ Zeros(size);
    let tempval : bits('size + 32) = BitReverse(val_name) @ Zeros(32);
    X_set(32, d) = BitReverse(Poly32Mod2(EOR(tempacc, tempval), poly))
}

val decode_crc32c_aarch64_instrs_integer_crc : (bits(5), bits(5), bits(2), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_crc32c_aarch64_instrs_integer_crc (Rd, Rn, sz, C, Rm, sf) = {
    if not_bool(HaveCRCExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sf == 0b1 & sz != 0b11 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & sz == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'size = (8 << UInt(sz));
    let crc32c : bool = C == 0b1;
    execute_aarch64_instrs_integer_crc(crc32c, d, m, n, size)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 10, 2);
    let C = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_crc32c_aarch64_instrs_integer_crc(Rd, Rn, sz, C, Rm, sf)
}

val decode_crc32_aarch64_instrs_integer_crc : (bits(5), bits(5), bits(2), bits(1), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_crc32_aarch64_instrs_integer_crc (Rd, Rn, sz, C, Rm, sf) = {
    if not_bool(HaveCRCExt()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if sf == 0b1 & sz != 0b11 then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & sz == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'size = (8 << UInt(sz));
    let crc32c : bool = C == 0b1;
    execute_aarch64_instrs_integer_crc(crc32c, d, m, n, size)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 10, 2);
    let C = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_crc32_aarch64_instrs_integer_crc(Rd, Rn, sz, C, Rm, sf)
}

val execute_aarch64_instrs_system_exceptions_debug_breakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_exceptions_debug_breakpoint comment = {
    AArch64_SoftwareBreakpoint(comment)
}

val decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint : bits(16) -> unit effect {escape, rreg, undef, wreg}

function decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint imm16 = {
    let comment : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_debug_breakpoint(comment)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let imm16 = Slice(__opcode, 5, 16);
    decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint(imm16)
}

val execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    let operand2 : bits('datasize) = V_read(datasize, d);
    op1 : int = undefined;
    op2 : int = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        op1 = asl_Int(Elem_read(operand, e, esize), not_bool(is_unsigned));
        op2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(op1 + op2, esize, is_unsigned) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(Rd, Rn, size, U)
}

val decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd(Rd, Rn, size, U, Q)
}

val decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(Rd, Rn, size, U)
}

val decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd (d, datasize, elements, esize, idxdsize, index, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
        result = Elem_set(result, e, 2 * esize, product);
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(2 * datasize, d) = result
}

val decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd (Rd, Rn, H, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd(Rd, Rn, H, Rm, M, L, size)
}

val decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd (Rd, Rn, H, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd(d, datasize, elements, esize, idxdsize, index, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd(Rd, Rn, H, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (d, datasize, elements, esize, n, part, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(2 * datasize, n);
    result : bits('datasize) = undefined;
    element : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 2 * esize);
        let (__tup_0 : bits('esize), __tup_1 : bool) = SatQ(asl_Int(element, is_unsigned), esize, is_unsigned) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    Vpart_set(datasize, d, part) = result
}

val decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'part = 0;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(Rd, Rn, size, U)
}

val decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd(Rd, Rn, size, U, Q)
}

val decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (Rd, Rn, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'part = 0;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(Rd, Rn, size, U)
}

val decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd : (bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd (Rd, Rn, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd(d, datasize, elements, esize, n, part, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd(Rd, Rn, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (d, datasize, elements, esize, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    let rounding : FPRounding = FPRoundingMode(FPCR);
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FixedToFP(esize, element, 0, is_unsigned, FPCR, rounding))
    };
    V_set(datasize, d) = result
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(Rd, Rn, U)
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd(Rd, Rn, sz, U)
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd(Rd, Rn, U, Q)
}

val decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd(Rd, Rn, sz, U, Q)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (Rd, Rn, U) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(Rd, Rn, U)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd (Rd, Rn, sz, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd(Rd, Rn, sz, U)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd (Rd, Rn, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd(Rd, Rn, U, Q)
}

val decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd : (bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd (Rd, Rn, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd(d, datasize, elements, esize, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd(Rd, Rn, sz, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(128, d);
    let operand2 : bits(128) = V_read(128, n);
    result : bits(128) = undefined;
    let T : bits(128) = operand2[31 .. 0] @ operand1[127 .. 32];
    elt : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        elt = Elem_read(T, e, 32);
        elt = EOR(EOR(ROR(elt, 7), ROR(elt, 18)), LSR(elt, 3));
        result = Elem_set(result, e, 32, elt + Elem_read(operand1, e, 32))
    };
    V_set(128, d) = result
}

val decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 (Rd, Rn) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0(d, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0(Rd, Rn)
}

val execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'n,
  (0 <= 'n & 'n <= 31 & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64, 128, 256} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd (d, datasize, elements, esize, idxdsize, index, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('idxdsize) = V_read(idxdsize, n);
    result : bits('datasize) = undefined;
    let element : bits('esize) = Elem_read(operand, index, esize);
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, element)
    };
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    V_set(datasize, d) = result
}

val decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd (Rd, Rn, imm5) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    } else ();
    assert(constraint(0 <= 'size + 1));
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    let 'esize = (8 << size);
    let 'datasize = esize;
    let 'elements = 1;
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd(d, datasize, elements, esize, idxdsize, index, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd(Rd, Rn, imm5)
}

val decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    } else ();
    assert(constraint(0 <= 'size + 1));
    let 'index = UInt(imm5[4 .. size + 1]);
    let 'idxdsize = if [imm5[4]] == 0b1 then 128 else 64;
    if size == 3 & Q == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd(d, datasize, elements, esize, idxdsize, index, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_vector_transfer_vector_permute_zip : forall 'd 'datasize 'esize 'm 'n 'pairs 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('m), int('n), int('pairs), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_permute_zip (d, datasize, esize, m, n, pairs, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    let 'base = part * pairs;
    foreach (p from 0 to (pairs - 1) by 1 in inc) {
        result = Elem_set(result, 2 * p + 0, esize, Elem_read(operand1, base + p, esize));
        result = Elem_set(result, 2 * p + 1, esize, Elem_read(operand2, base + p, esize))
    };
    V_set(datasize, d) = result
}

val decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_zip(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip(Rd, Rn, op, Rm, size, Q)
}

val decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip (Rd, Rn, op, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'part = UInt(op);
    let 'pairs = DIV(elements, 2);
    execute_aarch64_instrs_vector_transfer_vector_permute_zip(d, datasize, esize, m, n, pairs, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip(Rd, Rn, op, Rm, size, Q)
}

val execute_aarch64_instrs_vector_crypto_sm4_sm4enc : forall 'd 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm4_sm4enc (d, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vn : bits(128) = V_read(128, n);
    intval : bits(32) = undefined;
    sboxout : bits(8) = undefined;
    roundkey : bits(32) = undefined;
    roundresult : bits(128) = V_read(128, d);
    foreach (index from 0 to 3 by 1 in inc) {
        roundkey = Elem_read(Vn, index, 32);
        intval = EOR(EOR(EOR(roundresult[127 .. 96], roundresult[95 .. 64]), roundresult[63 .. 32]), roundkey);
        foreach (i from 0 to 3 by 1 in inc) {
            intval = Elem_set(intval, i, 8, Sbox(Elem_read(intval, i, 8)))
        };
        intval = EOR(EOR(EOR(EOR(intval, ROL(intval, 2)), ROL(intval, 10)), ROL(intval, 18)), ROL(intval, 24));
        intval = EOR(intval, roundresult[31 .. 0]);
        roundresult[31 .. 0] = roundresult[63 .. 32];
        roundresult[63 .. 32] = roundresult[95 .. 64];
        roundresult[95 .. 64] = roundresult[127 .. 96];
        roundresult[127 .. 96] = intval
    };
    V_set(128, d) = roundresult
}

val decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc (Rd, Rn) = {
    if not_bool(HaveSM4Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    execute_aarch64_instrs_vector_crypto_sm4_sm4enc(d, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc(Rd, Rn)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int (d, datasize, elements, esize, idxdsize, index, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    product : bits('esize) = undefined;
    let 'element2 = UInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = UInt(Elem_read(operand1, e, esize));
        product = (element1 * element2)[esize - 1 .. 0];
        result = Elem_set(result, e, esize, product)
    };
    V_set(datasize, d) = result
}

val decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int : (bits(5), bits(5), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int (Rd, Rn, H, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int(d, datasize, elements, esize, idxdsize, index, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int(Rd, Rn, H, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd : forall 'd 'datasize 'elements 'esize 'm 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd (d, datasize, elements, esize, m, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = Vpart_read(datasize, n, part);
    let operand2 : bits('datasize) = Vpart_read(datasize, m, part);
    result : bits(2 * 'datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    product : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        element2 = SInt(Elem_read(operand2, e, esize));
        (product, sat) = SignedSatQ(2 * element1 * element2, 2 * esize);
        result = Elem_set(result, e, 2 * esize, product);
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(2 * datasize, d) = result
}

val decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd (Rd, Rn, Rm, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd(Rd, Rn, Rm, size)
}

val decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd (Rd, Rn, Rm, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b00 | size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd(d, datasize, elements, esize, m, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd(Rd, Rn, Rm, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPSqrt(element, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16(Rd, Rn, Q)
}

val decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_float_move_fp_imm : forall 'd 'datasize,
  ('datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), bits('datasize)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_move_fp_imm (d, datasize, imm) = {
    CheckFPAdvSIMDEnabled64();
    V_set(datasize, d) = imm
}

val decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm : (bits(5), bits(8), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm (Rd, imm8, ftype) = {
    let 'd = UInt(Rd);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let imm : bits('datasize) = VFPExpandImm(datasize, imm8);
    execute_aarch64_instrs_float_move_fp_imm(d, datasize, imm)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let imm8 = Slice(__opcode, 13, 8);
    let ftype = Slice(__opcode, 22, 2);
    decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm(Rd, imm8, ftype)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Vd : bits(128) = V_read(128, d);
    result : bits(128) = undefined;
    let Wj : bits(32) = Elem_read(Vm, i, 32);
    TT2 : bits(32) = Vd[127 .. 96] & Vd[95 .. 64] | not_vec(Vd[127 .. 96]) & Vd[63 .. 32];
    let TT2 : bits(32) = (TT2 + Vd[31 .. 0] + Vn[127 .. 96] + Wj)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 19);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = EOR(EOR(TT2, ROL(TT2, 9)), ROL(TT2, 17));
    V_set(128, d) = result
}

val decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b(d, i, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (d, datasize, elements, esize, idxdsize, index, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    let operand3 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    product : bits('esize) = undefined;
    let 'element2 = UInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = UInt(Elem_read(operand1, e, esize));
        product = (element1 * element2)[esize - 1 .. 0];
        if sub_op then {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) - product)
        } else {
            result = Elem_set(result, e, esize, Elem_read(operand3, e, esize) + product)
        }
    };
    V_set(datasize, d) = result
}

val decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (Rd, Rn, H, o2, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o2 == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(d, datasize, elements, esize, idxdsize, index, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let o2 = Slice(__opcode, 14, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int(Rd, Rn, H, o2, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Vd : bits(128) = V_read(128, d);
    result : bits(128) = undefined;
    let WjPrime : bits(32) = Elem_read(Vm, i, 32);
    let SS2 : bits(32) = EOR(Vn[127 .. 96], ROL(Vd[127 .. 96], 12));
    TT1 : bits(32) = (Vd[127 .. 96] & Vd[63 .. 32] | Vd[127 .. 96] & Vd[95 .. 64]) | Vd[63 .. 32] & Vd[95 .. 64];
    let TT1 : bits(32) = (TT1 + Vd[31 .. 0] + SS2 + WjPrime)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 9);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = TT1;
    V_set(128, d) = result
}

val decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b(d, i, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    let zero : bits('esize) = FPZero(esize, 0b0);
    element : bits('esize) = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        match comparison {
          CompareOp_GT => {
              test_passed = FPCompareGT(element, zero, FPCR)
          },
          CompareOp_GE => {
              test_passed = FPCompareGE(element, zero, FPCR)
          },
          CompareOp_EQ => {
              test_passed = FPCompareEQ(element, zero, FPCR)
          },
          CompareOp_LE => {
              test_passed = FPCompareGE(zero, element, FPCR)
          },
          CompareOp_LT => {
              test_passed = FPCompareGT(zero, element, FPCR)
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(Rd, Rn)
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd(Rd, Rn, sz)
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd(Rd, Rn, Q)
}

val decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product : forall 'd 'datasize 'elements 'esize 'm 'n ('poly : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('poly)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (d, datasize, elements, esize, m, n, poly) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    product : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if poly then {
            product = PolynomialMult(element1, element2)[esize - 1 .. 0]
        } else {
            product = (UInt(element1) * UInt(element2))[esize - 1 .. 0]
        };
        result = Elem_set(result, e, esize, product)
    };
    V_set(datasize, d) = result
}

val decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if U == 0b1 & size != 0b00 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let poly : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(d, datasize, elements, esize, m, n, poly)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(Rd, Rn, Rm, size, U, Q)
}

val decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if U == 0b1 & size != 0b00 then {
        throw(Error_Undefined())
    } else ();
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let poly : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(d, datasize, elements, esize, m, n, poly)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a : forall 'd 'i 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'i in {0, 1, 2, 3} & 0 <= 'd & 'd <= 31).
  (int('d), int('i), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a (d, i, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Vd : bits(128) = V_read(128, d);
    result : bits(128) = undefined;
    let Wj : bits(32) = Elem_read(Vm, i, 32);
    TT2 : bits(32) = EOR(Vd[63 .. 32], EOR(Vd[127 .. 96], Vd[95 .. 64]));
    let TT2 : bits(32) = (TT2 + Vd[31 .. 0] + Vn[127 .. 96] + Wj)[31 .. 0];
    result[31 .. 0] = Vd[63 .. 32];
    result[63 .. 32] = ROL(Vd[95 .. 64], 19);
    result[95 .. 64] = Vd[127 .. 96];
    result[127 .. 96] = EOR(EOR(TT2, ROL(TT2, 9)), ROL(TT2, 17));
    V_set(128, d) = result
}

val decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a : (bits(5), bits(5), bits(2), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a (Rd, Rn, imm2, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'i = UInt(imm2);
    execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a(d, i, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitone, bitzero, _, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm2 = Slice(__opcode, 12, 2);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a(Rd, Rn, imm2, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd : forall 'd 'datasize 'elements 'esize 'idxdsize 'index 'm 'n ('round : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'index in {0, 1, 2, 3, 4, 5, 6, 7} & 'idxdsize in {64, 128} & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('idxdsize), int('index), int('m), int('n), bool('round)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (d, datasize, elements, esize, idxdsize, index, m, n, round) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('idxdsize) = V_read(idxdsize, m);
    result : bits('datasize) = undefined;
    let 'round_const = if round then (1 << (esize - 1)) else 0;
    element1 : int = undefined;
    product : int = undefined;
    sat : bool = undefined;
    let 'element2 = SInt(Elem_read(operand2, index, esize));
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = SInt(Elem_read(operand1, e, esize));
        product = 2 * element1 * element2 + round_const;
        let (__tup_0 : bits('esize), __tup_1 : bool) = SignedSatQ((product >> esize), esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    V_set(datasize, d) = result
}

val decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (Rd, Rn, H, op, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(Rd, Rn, H, op, Rm, M, L, size)
}

val decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd (Rd, Rn, H, op, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitzero, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd(Rd, Rn, H, op, Rm, M, L, size, Q)
}

val decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (Rd, Rn, H, op, Rm, M, L, size) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(Rd, Rn, H, op, Rm, M, L, size)
}

val decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd : (bits(5), bits(5), bits(1), bits(1), bits(4), bits(1), bits(1), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd (Rd, Rn, H, op, Rm, M, L, size, Q) = {
    let 'idxdsize = if H == 0b1 then 128 else 64;
    index : range(0, 7) = undefined;
    Rmhi : bits(1) = undefined;
    match size {
      0b01 => {
          index = UInt((H @ L) @ M);
          Rmhi = 0b0
      },
      0b10 => {
          index = UInt(H @ L);
          Rmhi = M
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let Rmhi = Rmhi;
    let 'index = index;
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rmhi @ Rm);
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let round : bool = op == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd(d, datasize, elements, esize, idxdsize, index, m, n, round)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, bitone, bitone, bitzero, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let H = Slice(__opcode, 11, 1);
    let op = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 4);
    let M = Slice(__opcode, 20, 1);
    let L = Slice(__opcode, 21, 1);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd(Rd, Rn, H, op, Rm, M, L, size, Q)
}

val execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal : forall 'datasize 'n ('postindex : Bool) 't ('wback : Bool),
  (0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {8, 16, 32, 64, 128, 256, 512, 1024}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (acctype, datasize, memop, n, offset, postindex, t, wback) = {
    CheckFPAdvSIMDEnabled64();
    data : bits('datasize) = undefined;
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_STORE, acctype);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data : bits('datasize) = V_read(datasize, t);
          Mem_set(address, DIV(datasize, 8), acctype) = data
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, DIV(datasize, 8), CAP_PERM_LOAD, acctype);
          assert(constraint((div('datasize, 8) == 1 | div('datasize, 8) == 2 | div('datasize, 8) == 4 | div('datasize, 8) == 8 | div('datasize, 8) == 16)));
          let data : bits('datasize) = Mem_read(address, DIV(datasize, 8), acctype);
          V_set(datasize, t) = data
      },
      _ => ()
    };
    if wback then {
        let base : VirtualAddress = VAAdd(base, offset);
        BaseReg_set(n) = base
    } else ()
}

val decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal : (bits(5), bits(5), bits(9), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (Rt, Rn, imm9, opc, size) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'scale = UInt([opc[1]] @ size);
    if scale > 4 then {
        throw(Error_Undefined())
    } else ();
    let offset : bits(64) = SignExtend(imm9, 64);
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let acctype : AccType = AccType_VEC;
    let memop : MemOp = if [opc[0]] == 0b1 then MemOp_LOAD else MemOp_STORE;
    let 'datasize = (8 << scale);
    assert(constraint('datasize in {8, 16, 32, 64, 128, 256, 512, 1024}));
    execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(acctype, datasize, memop, n, offset, postindex, t, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm9 = Slice(__opcode, 12, 9);
    let opc = Slice(__opcode, 22, 2);
    let size = Slice(__opcode, 30, 2);
    decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal(Rt, Rn, imm9, opc, size)
}

val execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize == 32 & 'elements in {1, 2} & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(2 * datasize, n);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, FPConvert(esize, Elem_read(operand, e, 2 * esize), FPCR, FPRounding_ODD))
    };
    Vpart_set(datasize, d, part) = result
}

val decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = 32;
    let 'datasize = esize;
    let 'elements = 1;
    let 'part = 0;
    execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd(Rd, Rn, sz)
}

val decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = 32;
    let 'datasize = 64;
    let 'elements = 2;
    let 'part = UInt(Q);
    execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd : forall 'd 'datasize 'elements 'esize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (d, datasize, elements, esize, m, n, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        if sub_op then {
            result = Elem_set(result, e, esize, element1 - element2)
        } else {
            result = Elem_set(result, e, esize, element1 + element2)
        }
    };
    V_set(datasize, d) = result
}

val decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(Rd, Rn, Rm, size, U)
}

val decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd(Rd, Rn, Rm, size, U, Q)
}

val decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd : (bits(5), bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (Rd, Rn, Rm, size, U) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(Rd, Rn, Rm, size, U)
}

val decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd(d, datasize, elements, esize, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_shift : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'n 'part 'shift,
  ('shift in {8, 16, 32, 64} & 'part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part), int('shift), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_shift (d, datasize, elements, esize, n, part, shift, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = Vpart_read(datasize, n, part);
    result : bits(2 * 'datasize) = undefined;
    element : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = (asl_Int(Elem_read(operand, e, esize), is_unsigned) << shift);
        result = Elem_set(result, e, 2 * esize, element[2 * esize - 1 .. 0])
    };
    V_set(2 * datasize, d) = result
}

val decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let 'shift = esize;
    let is_unsigned : bool = false;
    execute_aarch64_instrs_vector_arithmetic_unary_shift(d, datasize, elements, esize, n, part, shift, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_system_exceptions_runtime_hvc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_exceptions_runtime_hvc imm = {
    if (not_bool(HaveEL(EL2)) | PSTATE.EL == EL0) | PSTATE.EL == EL1 & IsSecure() then {
        throw(Error_Undefined())
    } else ();
    let hvc_enable : bits(1) = if HaveEL(EL3) then Slice(SCR_EL3, 8, 1) else not_vec(Slice(HCR_EL2, 29, 1));
    if hvc_enable == 0b0 then {
        throw(Error_Undefined())
    } else {
        AArch64_CallHypervisor(imm)
    }
}

val decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc imm16 = {
    let imm : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_runtime_hvc(imm)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero] as __opcode)) = {
    let imm16 = Slice(__opcode, 5, 16);
    decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc(imm16)
}

val execute_aarch64_instrs_branch_conditional_test : forall 'bit_pos 'datasize 't,
  (0 <= 't & 't <= 31 & 'datasize in {32, 64} & 0 <= 'bit_pos & 'bit_pos <= 63).
  (int('bit_pos), bits(1), int('datasize), bits(64), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_conditional_test (bit_pos, bit_val, datasize, offset, t) = {
    let operand : bits('datasize) = X_read(datasize, t);
    assert(constraint('bit_pos < 'datasize));
    if [operand[bit_pos]] == bit_val then {
        BranchToOffset(offset, BranchType_DIR)
    } else ()
}

val decode_tbnz_aarch64_instrs_branch_conditional_test : (bits(5), bits(14), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_tbnz_aarch64_instrs_branch_conditional_test (Rt, imm14, b40, op, b5) = {
    let 't = UInt(Rt);
    let 'datasize = if b5 == 0b1 then 64 else 32;
    let 'bit_pos = UInt(b5 @ b40);
    let bit_val : bits(1) = op;
    let offset : bits(64) = SignExtend(imm14 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_test(bit_pos, bit_val, datasize, offset, t)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm14 = Slice(__opcode, 5, 14);
    let b40 = Slice(__opcode, 19, 5);
    let op = Slice(__opcode, 24, 1);
    let b5 = Slice(__opcode, 31, 1);
    decode_tbnz_aarch64_instrs_branch_conditional_test(Rt, imm14, b40, op, b5)
}

val decode_tbz_aarch64_instrs_branch_conditional_test : (bits(5), bits(14), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_tbz_aarch64_instrs_branch_conditional_test (Rt, imm14, b40, op, b5) = {
    let 't = UInt(Rt);
    let 'datasize = if b5 == 0b1 then 64 else 32;
    let 'bit_pos = UInt(b5 @ b40);
    let bit_val : bits(1) = op;
    let offset : bits(64) = SignExtend(imm14 @ 0b00, 64);
    execute_aarch64_instrs_branch_conditional_test(bit_pos, bit_val, datasize, offset, t)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm14 = Slice(__opcode, 5, 14);
    let b40 = Slice(__opcode, 19, 5);
    let op = Slice(__opcode, 24, 1);
    let b5 = Slice(__opcode, 31, 1);
    decode_tbz_aarch64_instrs_branch_conditional_test(Rt, imm14, b40, op, b5)
}

val execute_aarch64_instrs_integer_shift_variable : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), ShiftType) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_shift_variable (d, datasize, m, n, shift_type) = {
    let operand2 : bits('datasize) = X_read(datasize, m);
    let result : bits('datasize) = ShiftReg(datasize, n, shift_type, MOD(UInt(operand2), datasize));
    X_set(datasize, d) = result
}

val decode_asrv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_asrv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_asrv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val decode_lslv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_lslv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_lslv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val decode_lsrv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_lsrv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_lsrv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val decode_rorv_aarch64_instrs_integer_shift_variable : (bits(5), bits(5), bits(2), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rorv_aarch64_instrs_integer_shift_variable (Rd, Rn, op2, Rm, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let shift_type : ShiftType = DecodeShift(op2);
    execute_aarch64_instrs_integer_shift_variable(d, datasize, m, n, shift_type)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let op2 = Slice(__opcode, 10, 2);
    let Rm = Slice(__opcode, 16, 5);
    let sf = Slice(__opcode, 31, 1);
    decode_rorv_aarch64_instrs_integer_shift_variable(Rd, Rn, op2, Rm, sf)
}

val execute_aarch64_instrs_float_move_fp_select : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (bits(4), int('d), int('datasize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_move_fp_select (condition, d, datasize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let result : bits('datasize) = if ConditionHolds(condition) then V_read(datasize, n) else V_read(datasize, m);
    V_set(datasize, d) = result
}

val decode_fcsel_float_aarch64_instrs_float_move_fp_select : (bits(5), bits(5), bits(4), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcsel_float_aarch64_instrs_float_move_fp_select (Rd, Rn, cond, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    let condition : bits(4) = cond;
    execute_aarch64_instrs_float_move_fp_select(condition, d, datasize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, _, _, _, _, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcsel_float_aarch64_instrs_float_move_fp_select(Rd, Rn, cond, Rm, ftype)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (CompareOp, int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd (comparison, d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : int = undefined;
    test_passed : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = SInt(Elem_read(operand, e, esize));
        match comparison {
          CompareOp_GT => {
              test_passed = element > 0
          },
          CompareOp_GE => {
              test_passed = element >= 0
          },
          CompareOp_EQ => {
              test_passed = element == 0
          },
          CompareOp_LE => {
              test_passed = element <= 0
          },
          CompareOp_LT => {
              test_passed = element < 0
          }
        };
        result = Elem_set(result, e, esize, if test_passed then Ones() else Zeros())
    };
    V_set(datasize, d) = result
}

val decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd : (bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd (Rd, Rn, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'elements = 1;
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd(Rd, Rn, size)
}

val decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (size @ Q) == 0b110 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let comparison : CompareOp = CompareOp_LT;
    execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd(comparison, d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_transfer_vector_extract : forall 'd 'datasize 'm 'n 'position,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n), int('position)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_vector_extract (d, datasize, m, n, position) = {
    CheckFPAdvSIMDEnabled64();
    let hi : bits('datasize) = V_read(datasize, m);
    let lo : bits('datasize) = V_read(datasize, n);
    let concat : bits('datasize * 2) = hi @ lo;
    assert(constraint((0 <= 'position & 'position + 'datasize - 1 < 'datasize * 2)));
    V_set(0 + (position + datasize - 1 - position + 1), d) = concat[position + datasize - 1 .. position]
}

val decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract : (bits(5), bits(5), bits(4), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract (Rd, Rn, imm4, Rm, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if Q == 0b0 & [imm4[3]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'position = (UInt(imm4) << 3);
    execute_aarch64_instrs_vector_transfer_vector_extract(d, datasize, m, n, position)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm4 = Slice(__opcode, 11, 4);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract(Rd, Rn, imm4, Rm, Q)
}

val execute_aarch64_instrs_float_arithmetic_div : forall 'd 'datasize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_arithmetic_div (d, datasize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    let result : bits('datasize) = FPDiv(operand1, operand2, FPCR);
    V_set(datasize, d) = result
}

val decode_fdiv_float_aarch64_instrs_float_arithmetic_div : (bits(5), bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fdiv_float_aarch64_instrs_float_arithmetic_div (Rd, Rn, Rm, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    datasize : {|16, 32, 64|} = 16;
    match ftype {
      0b00 => {
          datasize = 32
      },
      0b01 => {
          datasize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          if HaveFP16Ext() then {
              datasize = 16
          } else {
              throw(Error_Undefined())
          }
      }
    };
    let 'datasize = datasize;
    execute_aarch64_instrs_float_arithmetic_div(d, datasize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let ftype = Slice(__opcode, 22, 2);
    decode_fdiv_float_aarch64_instrs_float_arithmetic_div(Rd, Rn, Rm, ftype)
}

val execute_aarch64_instrs_system_exceptions_runtime_svc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_exceptions_runtime_svc imm = {
    AArch64_CallSupervisor(imm)
}

val decode_svc_aarch64_instrs_system_exceptions_runtime_svc : bits(16) -> unit effect {escape, rreg, undef, wreg}

function decode_svc_aarch64_instrs_system_exceptions_runtime_svc imm16 = {
    let imm : bits(16) = imm16;
    execute_aarch64_instrs_system_exceptions_runtime_svc(imm)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone] as __opcode)) = {
    let imm16 = Slice(__opcode, 5, 16);
    decode_svc_aarch64_instrs_system_exceptions_runtime_svc(imm16)
}

val execute_aarch64_instrs_system_monitors : unit -> unit

function execute_aarch64_instrs_system_monitors () = {
    ClearExclusiveLocal(ProcessorID())
}

val decode_clrex_aarch64_instrs_system_monitors : bits(4) -> unit

function decode_clrex_aarch64_instrs_system_monitors CRm = {
    execute_aarch64_instrs_system_monitors()
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let CRm = Slice(__opcode, 8, 4);
    decode_clrex_aarch64_instrs_system_monitors(CRm)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3ss1 : forall 'a 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3ss1 (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    Vd : bits(128) = V_read(128, d);
    let Va : bits(128) = V_read(128, a);
    Vd[127 .. 96] = ROL(ROL(Vn[127 .. 96], 12) + Vm[127 .. 96] + Va[127 .. 96], 7);
    Vd[95 .. 0] = Zeros();
    V_set(128, d) = Vd
}

val decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1 : (bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1 (Rd, Rn, Ra, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    execute_aarch64_instrs_vector_crypto_sm3_sm3ss1(a, d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1(Rd, Rn, Ra, Rm)
}

val execute_aarch64_instrs_integer_conditional_compare_register : forall 'datasize 'm 'n ('sub_op : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'datasize in {32, 64}).
  (bits(4), int('datasize), bits(4), int('m), int('n), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_integer_conditional_compare_register (condition, datasize, flags__arg, m, n, sub_op) = {
    flags : bits(4) = flags__arg;
    let operand1 : bits('datasize) = X_read(datasize, n);
    operand2 : bits('datasize) = X_read(datasize, m);
    carry_in : bits(1) = 0b0;
    if ConditionHolds(condition) then {
        if sub_op then {
            operand2 = not_vec(operand2);
            carry_in = 0b1
        } else ();
        let (_, __tup_1 : bits(4)) = AddWithCarry(operand1, operand2, carry_in);
        flags = __tup_1
    } else ();
    (PSTATE.N @ PSTATE.Z @ PSTATE.C @ PSTATE.V) = flags
}

val decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register (nzcv, Rn, cond, Rm, op, sf) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_integer_conditional_compare_register(condition, datasize, flags, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) = {
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register(nzcv, Rn, cond, Rm, op, sf)
}

val decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register : (bits(4), bits(5), bits(4), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register (nzcv, Rn, cond, Rm, op, sf) = {
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    let sub_op : bool = op == 0b1;
    let condition : bits(4) = cond;
    let flags : bits(4) = nzcv;
    execute_aarch64_instrs_integer_conditional_compare_register(condition, datasize, flags, m, n, sub_op)
}

function clause __DecodeA64 (pc, ([_, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _] as __opcode)) = {
    let nzcv = Slice(__opcode, 0, 4);
    let Rn = Slice(__opcode, 5, 5);
    let cond = Slice(__opcode, 12, 4);
    let Rm = Slice(__opcode, 16, 5);
    let op = Slice(__opcode, 30, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register(nzcv, Rn, cond, Rm, op, sf)
}

val execute_aarch64_instrs_branch_unconditional_immediate : (BranchType, bits(64)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_unconditional_immediate (branch_type, offset) = {
    if branch_type == BranchType_DIRCALL then {
        if IsInC64() then {
            if [CCTLR_read__1()[7]] == 0b1 then {
                C_set(30) = CapSetObjectType(CapAdd__1(PCC_read(), 5), CAP_SEAL_TYPE_RB)
            } else {
                C_set(30) = CapAdd__1(PCC_read(), 5)
            }
        } else if [CCTLR_read__1()[3]] == 0b1 then {
            X_set(64, 30) = PC_read() + 4 - CapGetBase(PCC_read())
        } else {
            X_set(64, 30) = PC_read() + 4
        }
    } else ();
    BranchToOffset(offset, branch_type)
}

val decode_b_uncond_aarch64_instrs_branch_unconditional_immediate : (bits(26), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_b_uncond_aarch64_instrs_branch_unconditional_immediate (imm26, op) = {
    let branch_type : BranchType = if op == 0b1 then BranchType_DIRCALL else BranchType_DIR;
    let offset : bits(64) = SignExtend(imm26 @ 0b00, 64);
    execute_aarch64_instrs_branch_unconditional_immediate(branch_type, offset)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm26 = Slice(__opcode, 0, 26);
    let op = Slice(__opcode, 31, 1);
    decode_b_uncond_aarch64_instrs_branch_unconditional_immediate(imm26, op)
}

val decode_bl_aarch64_instrs_branch_unconditional_immediate : (bits(26), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_bl_aarch64_instrs_branch_unconditional_immediate (imm26, op) = {
    let branch_type : BranchType = if op == 0b1 then BranchType_DIRCALL else BranchType_DIR;
    let offset : bits(64) = SignExtend(imm26 @ 0b00, 64);
    execute_aarch64_instrs_branch_unconditional_immediate(branch_type, offset)
}

function clause __DecodeA64 (pc, ([bitone, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let imm26 = Slice(__opcode, 0, 26);
    let op = Slice(__opcode, 31, 1);
    decode_bl_aarch64_instrs_branch_unconditional_immediate(imm26, op)
}

val execute_aarch64_instrs_vector_fp16_movi : forall 'datasize 'rd,
  (0 <= 'rd & 'rd <= 31 & 'datasize in {64, 128}).
  (int('datasize), bits('datasize), int('rd)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_fp16_movi (datasize, imm, rd) = {
    CheckFPAdvSIMDEnabled64();
    V_set(datasize, rd) = imm
}

val decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi (Rd, h, g, f, e, d, c, b, a, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let imm8 : bits(8) = ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h;
    let imm16 : bits(16) = ((([imm8[7]] @ not_vec([imm8[6]])) @ Replicate([imm8[6]], 2)) @ imm8[5 .. 0]) @ Zeros(6);
    let imm : bits('datasize) = Replicate(imm16, DIV(datasize, 16));
    execute_aarch64_instrs_vector_fp16_movi(datasize, imm, rd)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi(Rd, h, g, f, e, d, c, b, a, Q)
}

val decode_fmov_advsimd_aarch64_instrs_vector_logical : (bits(5), bits(1), bits(1), bits(1), bits(1), bits(1), bits(4), bits(1), bits(1), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmov_advsimd_aarch64_instrs_vector_logical (Rd, h, g, f, e, d, cmode, c, b, a, op, Q) = {
    let 'rd = UInt(Rd);
    let 'datasize = if Q == 0b1 then 128 else 64;
    operation : ImmediateOp = undefined;
    match cmode @ op {
      [bitzero, _, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitzero, _, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitzero, _, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitzero, _, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitzero, _, bitzero, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitzero, _, bitzero, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitzero, _, bitone, bitzero] => {
          operation = ImmediateOp_ORR
      },
      [bitone, bitzero, _, bitone, bitone] => {
          operation = ImmediateOp_BIC
      },
      [bitone, bitone, bitzero, _, bitzero] => {
          operation = ImmediateOp_MOVI
      },
      [bitone, bitone, bitzero, _, bitone] => {
          operation = ImmediateOp_MVNI
      },
      [bitone, bitone, bitone, bitzero, _] => {
          operation = ImmediateOp_MOVI
      },
      0b11110 => {
          operation = ImmediateOp_MOVI
      },
      0b11111 => {
          if Q == 0b0 then {
              throw(Error_Undefined())
          } else ();
          operation = ImmediateOp_MOVI
      }
    };
    let operation = operation;
    let imm64 : bits(64) = AdvSIMDExpandImm(op, cmode, ((((((a @ b) @ c) @ d) @ e) @ f) @ g) @ h);
    let imm : bits('datasize) = Replicate(imm64, DIV(datasize, 64));
    execute_aarch64_instrs_vector_fp16_movi(datasize, imm, rd)
}

function clause __DecodeA64 (pc, ([bitzero, _, _, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, bitone, bitone, bitone, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let h = Slice(__opcode, 5, 1);
    let g = Slice(__opcode, 6, 1);
    let f = Slice(__opcode, 7, 1);
    let e = Slice(__opcode, 8, 1);
    let d = Slice(__opcode, 9, 1);
    let cmode = Slice(__opcode, 12, 4);
    let c = Slice(__opcode, 16, 1);
    let b = Slice(__opcode, 17, 1);
    let a = Slice(__opcode, 18, 1);
    let op = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fmov_advsimd_aarch64_instrs_vector_logical(Rd, h, g, f, e, d, cmode, c, b, a, op, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd : forall ('abs : Bool) 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (bool('abs), int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (abs, d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    diff : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        diff = FPSub(element1, element2, FPCR);
        result = Elem_set(result, e, esize, if abs then FPAbs(diff) else diff)
    };
    V_set(datasize, d) = result
}

val decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (Rd, Rn, Rm, U, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(Rd, Rn, Rm, U, Q)
}

val decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd : (bits(5), bits(5), bits(5), bits(1), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd (Rd, Rn, Rm, sz, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let abs : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd(abs, d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitone, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd(Rd, Rn, Rm, sz, U, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int : forall 'd 'datasize 'elements 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int (d, datasize, elements, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits(32) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 32);
        result = Elem_set(result, e, 32, UnsignedRecipEstimate(element))
    };
    V_set(datasize, d) = result
}

val decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int(d, datasize, elements, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_crypto_sm3_sm3partw2 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sm3_sm3partw2 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Vd : bits(128) = V_read(128, d);
    result : bits(128) = undefined;
    tmp : bits(128) = undefined;
    tmp[127 .. 0] = EOR(Vn, ((ROL(Vm[127 .. 96], 7) @ ROL(Vm[95 .. 64], 7)) @ ROL(Vm[63 .. 32], 7)) @ ROL(Vm[31 .. 0], 7));
    result[127 .. 0] = EOR(Vd[127 .. 0], tmp[127 .. 0]);
    tmp2 : bits(32) = ROL(tmp[31 .. 0], 15);
    let tmp2 : bits(32) = EOR(EOR(tmp2, ROL(tmp2, 15)), ROL(tmp2, 23));
    result[127 .. 96] = EOR(result[127 .. 96], tmp2);
    V_set(128, d) = result
}

val decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2 (Rd, Rn, Rm) = {
    if not_bool(HaveSM3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sm3_sm3partw2(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2(Rd, Rn, Rm)
}

val execute_aarch64_instrs_memory_literal_simdfp : forall 'size 't,
  (0 <= 't & 't <= 31 & 'size in {4, 8, 16}).
  (bits(64), int('size), int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_literal_simdfp (offset, size, t) = {
    let base : VirtualAddress = VAFromCapability(PCC);
    let address : bits(64) = VAddress(base) + offset;
    CheckFPAdvSIMDEnabled64();
    VACheckAddress(base, address, size, CAP_PERM_LOAD, AccType_VEC);
    let data : bits('size * 8) = Mem_read(address, size, AccType_VEC);
    V_set(size * 8, t) = data
}

val decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp : (bits(5), bits(19), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp (Rt, imm19, opc) = {
    let 't = UInt(Rt);
    size : {|4, 8, 16|} = 4;
    match opc {
      0b00 => {
          size = 4
      },
      0b01 => {
          size = 8
      },
      0b10 => {
          size = 16
      },
      0b11 => {
          throw(Error_Undefined())
      }
    };
    let 'size = size;
    let offset : bits(64) = SignExtend(imm19 @ 0b00, 64);
    execute_aarch64_instrs_memory_literal_simdfp(offset, size, t)
}

function clause __DecodeA64 (pc, ([_, _, bitzero, bitone, bitone, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let imm19 = Slice(__opcode, 5, 19);
    let opc = Slice(__opcode, 30, 2);
    decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp(Rt, imm19, opc)
}

val execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : forall 'd 'datasize 'elements 'esize 'm 'n 'part ('round : Bool) ('sub_op : Bool),
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), int('part), bool('round), bool('sub_op)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (d, datasize, elements, esize, m, n, part, round, sub_op) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits(2 * 'datasize) = V_read(2 * datasize, n);
    let operand2 : bits(2 * 'datasize) = V_read(2 * datasize, m);
    result : bits('datasize) = undefined;
    let 'round_const = if round then (1 << (esize - 1)) else 0;
    element1 : bits(2 * 'esize) = undefined;
    element2 : bits(2 * 'esize) = undefined;
    sum : bits(2 * 'esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, 2 * esize);
        element2 = Elem_read(operand2, e, 2 * esize);
        if sub_op then {
            sum = element1 - element2
        } else {
            sum = element1 + element2
        };
        sum = sum + round_const;
        result = Elem_set(result, e, esize, sum[2 * esize - 1 .. esize])
    };
    Vpart_set(datasize, d, part) = result
}

val decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow : (bits(5), bits(5), bits(1), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd, Rn, o1, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    let sub_op : bool = o1 == 0b1;
    let round : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(d, datasize, elements, esize, m, n, part, round, sub_op)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let o1 = Slice(__opcode, 13, 1);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow(Rd, Rn, o1, Rm, size, U, Q)
}

val execute_aarch64_instrs_memory_atomicops_cas_pair : forall 'datasize 'n 'regsize 's 't,
  (0 <= 't & 't <= 31 & 0 <= 's & 's <= 31 & 'regsize in {32, 64} & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64}).
  (int('datasize), AccType, int('n), int('regsize), int('s), AccType, int('t)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_atomicops_cas_pair (datasize, ldacctype, n, regsize, s, stacctype, t) = {
    let s1 : bits('datasize) = X_read(datasize, s);
    let s2 : bits('datasize) = X_read(datasize, s + 1);
    let t1 : bits('datasize) = X_read(datasize, t);
    let t2 : bits('datasize) = X_read(datasize, t + 1);
    let comparevalue : bits(2 * 'datasize) = if BigEndian() then s1 @ s2 else s2 @ s1;
    let newvalue : bits(2 * 'datasize) = if BigEndian() then t1 @ t2 else t2 @ t1;
    let base : VirtualAddress = BaseReg_read__1(n);
    let data : bits(2 * 'datasize) = MemAtomicCompareAndSwap(base, comparevalue, newvalue, ldacctype, stacctype);
    if BigEndian() then {
        assert(constraint('regsize >= 2 * 'datasize - 1 - 'datasize + 1));
        X_set(regsize, s) = ZeroExtend(data[2 * datasize - 1 .. datasize], regsize);
        X_set(regsize, s + 1) = ZeroExtend(data[datasize - 1 .. 0], regsize)
    } else {
        assert(constraint('regsize >= 'datasize - 1 - 0 + 1));
        X_set(regsize, s) = ZeroExtend(data[datasize - 1 .. 0], regsize);
        X_set(regsize, s + 1) = ZeroExtend(data[2 * datasize - 1 .. datasize], regsize)
    }
}

val decode_casp_aarch64_instrs_memory_atomicops_cas_pair : (bits(5), bits(5), bits(5), bits(1), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_casp_aarch64_instrs_memory_atomicops_cas_pair (Rt, Rn, Rt2, o0, Rs, L, sz) = {
    if not_bool(HaveAtomicExt()) then {
        throw(Error_Undefined())
    } else ();
    if [Rs[0]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    if [Rt[0]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 's = UInt(Rs);
    let 'datasize = (32 << UInt(sz));
    let 'regsize = datasize;
    let ldacctype : AccType = if L == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    let stacctype : AccType = if o0 == 0b1 then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
    execute_aarch64_instrs_memory_atomicops_cas_pair(datasize, ldacctype, n, regsize, s, stacctype, t)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, bitone, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let o0 = Slice(__opcode, 15, 1);
    let Rs = Slice(__opcode, 16, 5);
    let L = Slice(__opcode, 22, 1);
    let sz = Slice(__opcode, 30, 1);
    decode_casp_aarch64_instrs_memory_atomicops_cas_pair(Rt, Rn, Rt2, o0, Rs, L, sz)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'elements == 1 & 'datasize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRecpX(element, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16(Rd, Rn)
}

val decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx(Rd, Rn, sz)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int : forall 'd 'datasize 'elements 'esize ('is_unsigned : Bool) 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n), bool('is_unsigned)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (d, datasize, elements, esize, m, n, is_unsigned) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : int = undefined;
    element2 : int = undefined;
    diff : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = asl_Int(Elem_read(operand1, e, esize), is_unsigned);
        element2 = asl_Int(Elem_read(operand2, e, esize), is_unsigned);
        diff = element1 - element2;
        result = Elem_set(result, e, esize, diff[esize .. 1])
    };
    V_set(datasize, d) = result
}

val decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(Rd, Rn, Rm, size, U, Q)
}

val decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int : (bits(5), bits(5), bits(5), bits(2), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (Rd, Rn, Rm, size, U, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let is_unsigned : bool = U == 0b1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(d, datasize, elements, esize, m, n, is_unsigned)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let size = Slice(__opcode, 22, 2);
    let U = Slice(__opcode, 29, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int(Rd, Rn, Rm, size, U, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    X : bits(128) = V_read(128, d);
    Y : bits(32) = V_read(32, n);
    let W : bits(128) = V_read(128, m);
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAmajority(X[63 .. 32], X[95 .. 64], X[127 .. 96]);
        Y = Y + ROL(X[31 .. 0], 5) + t + Elem_read(W, e, 32);
        X[63 .. 32] = ROL(X[63 .. 32], 30);
        (Y @ X) = ROL(Y @ X, 32)
    };
    V_set(128, d) = X
}

val decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority(d, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_not : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize == 8 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_not (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, not_vec(element))
    };
    V_set(datasize, d) = result
}

val decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not (Rd, Rn, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    execute_aarch64_instrs_vector_arithmetic_unary_not(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not(Rd, Rn, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, esize);
        result = Elem_set(result, e, esize, FPRSqrtEstimate(element, FPCR))
    };
    V_set(datasize, d) = result
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd : (bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd (Rd, Rn) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(Rd, Rn)
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd(Rd, Rn, sz)
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd (Rd, Rn, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd(Rd, Rn, Q)
}

val decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512h : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha512_sha512h (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    let X : bits(128) = V_read(128, n);
    let Y : bits(128) = V_read(128, m);
    let W : bits(128) = V_read(128, d);
    MSigma1 : bits(64) = EOR(EOR(ROR(Y[127 .. 64], 14), ROR(Y[127 .. 64], 18)), ROR(Y[127 .. 64], 41));
    Vtmp[127 .. 64] = EOR(Y[127 .. 64] & X[63 .. 0], not_vec(Y[127 .. 64]) & X[127 .. 64]);
    Vtmp[127 .. 64] = Vtmp[127 .. 64] + MSigma1 + W[127 .. 64];
    let tmp : bits(64) = Vtmp[127 .. 64] + Y[63 .. 0];
    let MSigma1 : bits(64) = EOR(EOR(ROR(tmp, 14), ROR(tmp, 18)), ROR(tmp, 41));
    Vtmp[63 .. 0] = EOR(tmp & Y[127 .. 64], not_vec(tmp) & X[63 .. 0]);
    Vtmp[63 .. 0] = Vtmp[63 .. 0] + MSigma1 + W[63 .. 0];
    V_set(128, d) = Vtmp
}

val decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h (Rd, Rn, Rm) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha512_sha512h(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int : forall 'd 'datasize 'elements 'n,
  (0 <= 'n & 'n <= 31 & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int (d, datasize, elements, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    element : bits(32) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 32);
        result = Elem_set(result, e, 32, UnsignedRSqrtEstimate(element))
    };
    V_set(datasize, d) = result
}

val decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int (Rd, Rn, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = 32;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int(d, datasize, elements, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int(Rd, Rn, sz, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    X : bits(128) = V_read(128, d);
    Y : bits(32) = V_read(32, n);
    let W : bits(128) = V_read(128, m);
    t : bits(32) = undefined;
    foreach (e from 0 to 3 by 1 in inc) {
        t = SHAparity(X[63 .. 32], X[95 .. 64], X[127 .. 96]);
        Y = Y + ROL(X[31 .. 0], 5) + t + Elem_read(W, e, 32);
        X[63 .. 32] = ROL(X[63 .. 32], 30);
        (Y @ X) = ROL(Y @ X, 32)
    };
    V_set(128, d) = X
}

val decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA1Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity(d, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash : forall 'd 'm 'n ('part1 : Bool),
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n), bool('part1)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash (d, m, n, part1) = {
    AArch64_CheckFPAdvSIMDEnabled();
    result : bits(128) = undefined;
    if part1 then {
        result = SHA256hash(V_read(128, d), V_read(128, n), V_read(128, m), true)
    } else {
        result = SHA256hash(V_read(128, n), V_read(128, d), V_read(128, m), false)
    };
    V_set(128, d) = result
}

val decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash : (bits(5), bits(5), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash (Rd, Rn, P, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    } else ();
    let part1 : bool = P == 0b0;
    execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash(d, m, n, part1)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let P = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash(Rd, Rn, P, Rm)
}

val decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash : (bits(5), bits(5), bits(1), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash (Rd, Rn, P, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    } else ();
    let part1 : bool = P == 0b0;
    execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash(d, m, n, part1)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let P = Slice(__opcode, 12, 1);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash(Rd, Rn, P, Rm)
}

val execute_aarch64_instrs_integer_ins_ext_extract_immediate : forall 'd 'datasize 'lsb 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'lsb & 'lsb <= 63 & 'datasize in {32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('lsb), int('m), int('n)) -> unit effect {escape, rreg, wreg}

function execute_aarch64_instrs_integer_ins_ext_extract_immediate (d, datasize, lsb, m, n) = {
    let operand1 : bits('datasize) = X_read(datasize, n);
    let operand2 : bits('datasize) = X_read(datasize, m);
    let concat : bits(2 * 'datasize) = operand1 @ operand2;
    assert(constraint('lsb + 'datasize - 1 < 2 * 'datasize));
    let result : bits('datasize) = concat[lsb + datasize - 1 .. lsb];
    X_set(datasize, d) = result
}

val decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate : (bits(5), bits(5), bits(6), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, wreg}

function decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate (Rd, Rn, imms, Rm, N, sf) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'datasize = if sf == 0b1 then 64 else 32;
    if N != sf then {
        throw(Error_Undefined())
    } else ();
    if sf == 0b0 & [imms[5]] == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'lsb = UInt(imms);
    execute_aarch64_instrs_integer_ins_ext_extract_immediate(d, datasize, lsb, m, n)
}

function clause __DecodeA64 (pc, ([_, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitone, bitone, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imms = Slice(__opcode, 10, 6);
    let Rm = Slice(__opcode, 16, 5);
    let N = Slice(__opcode, 22, 1);
    let sf = Slice(__opcode, 31, 1);
    decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate(Rd, Rn, imms, Rm, N, sf)
}

val execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize in {8, 16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(2 * datasize, n);
    result : bits('datasize) = undefined;
    element : bits(2 * 'esize) = undefined;
    sat : bool = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 2 * esize);
        let (__tup_0 : bits('esize), __tup_1 : bool) = UnsignedSatQ(SInt(element), esize) in
          {
              result = Elem_set(result, e, esize, __tup_0);
              sat = __tup_1
          };
        if sat then {
            FPSR = SetSlice(1, FPSR, 27, 0b1)
        } else ()
    };
    Vpart_set(datasize, d, part) = result
}

val decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd : (bits(5), bits(5), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd (Rd, Rn, size) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = esize;
    let 'part = 0;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd(Rd, Rn, size)
}

val decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd : forall 'd 'datasize 'elements 'esize 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 'esize in {16, 32, 64} & 'datasize in {16, 32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd (d, datasize, elements, esize, m, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand1 : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, m);
    result : bits('datasize) = undefined;
    element1 : bits('esize) = undefined;
    element2 : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element1 = Elem_read(operand1, e, esize);
        element2 = Elem_read(operand2, e, esize);
        result = Elem_set(result, e, esize, FPRSqrtStepFused(element1, element2))
    };
    V_set(datasize, d) = result
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd (Rd, Rn, Rm) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(Rd, Rn, Rm)
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd (Rd, Rn, Rm, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize;
    let 'elements = 1;
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd(Rd, Rn, Rm, sz)
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd (Rd, Rn, Rm, Q) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'esize = 16;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, bitzero, bitzero, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd(Rd, Rn, Rm, Q)
}

val decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd : (bits(5), bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd (Rd, Rn, Rm, sz, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if (sz @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (32 << UInt(sz));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd(d, datasize, elements, esize, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitone, _, bitone, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    let sz = Slice(__opcode, 22, 1);
    let Q = Slice(__opcode, 30, 1);
    decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd(Rd, Rn, Rm, sz, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_cnt : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize == 8 & 'elements in {8, 16} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_cnt (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    result : bits('datasize) = undefined;
    count : int = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        count = BitCount(Elem_read(operand, e, esize));
        result = Elem_set(result, e, esize, count[esize - 1 .. 0])
    };
    V_set(datasize, d) = result
}

val decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size != 0b00 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = 8;
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, 8);
    execute_aarch64_instrs_vector_arithmetic_unary_cnt(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_system_exceptions_debug_halt : unit -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_exceptions_debug_halt () = {
    Halt(DebugHalt_HaltInstruction)
}

val decode_hlt_aarch64_instrs_system_exceptions_debug_halt : bits(16) -> unit effect {escape, rreg, undef, wreg}

function decode_hlt_aarch64_instrs_system_exceptions_debug_halt imm16 = {
    if Slice(EDSCR, 14, 1) == 0b0 | not_bool(HaltingAllowed()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_system_exceptions_debug_halt()
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitzero] as __opcode)) = {
    let imm16 = Slice(__opcode, 5, 16);
    decode_hlt_aarch64_instrs_system_exceptions_debug_halt(imm16)
}

val execute_aarch64_instrs_vector_reduce_fp16_max_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_fp16_max_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    assert(constraint('datasize >= 'esize));
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd(Rd, Rn, sz, o1)
}

val decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd(Rd, Rn, sz, o1)
}

val decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd (Rd, Rn, sz, o1) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd(Rd, Rn, sz, o1)
}

val decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd : (bits(5), bits(5), bits(1), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd (Rd, Rn, sz, o1) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = if o1 == 0b1 then ReduceOp_FMIN else ReduceOp_FMAX;
    execute_aarch64_instrs_vector_reduce_fp16_max_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitone, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    let o1 = Slice(__opcode, 23, 1);
    decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd(Rd, Rn, sz, o1)
}

val execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let operand1 : bits(128) = V_read(128, d);
    let operand2 : bits(128) = V_read(128, n);
    let operand3 : bits(128) = V_read(128, m);
    result : bits(128) = undefined;
    let T0 : bits(128) = operand3[31 .. 0] @ operand2[127 .. 32];
    elt : bits(32) = undefined;
    T1 : bits(64) = operand3[127 .. 64];
    foreach (e from 0 to 1 by 1 in inc) {
        elt = Elem_read(T1, e, 32);
        elt = EOR(EOR(ROR(elt, 17), ROR(elt, 19)), LSR(elt, 10));
        elt = elt + Elem_read(operand1, e, 32) + Elem_read(T0, e, 32);
        result = Elem_set(result, e, 32, elt)
    };
    let T1 : bits(64) = result[63 .. 0];
    foreach (e from 2 to 3 by 1 in inc) {
        elt = Elem_read(T1, e - 2, 32);
        elt = EOR(EOR(ROR(elt, 17), ROR(elt, 19)), LSR(elt, 10));
        elt = elt + Elem_read(operand1, e, 32) + Elem_read(T0, e, 32);
        result = Elem_set(result, e, 32, elt)
    };
    V_set(128, d) = result
}

val decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 (Rd, Rn, Rm) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    if not_bool(HaveSHA256Ext()) then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1(d, m, n)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitone, bitone, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha3_bcax : forall 'a 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3_bcax (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Va : bits(128) = V_read(128, a);
    V_set(128, d) = EOR(Vn, Vm & not_vec(Va))
}

val decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax : (bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax (Rd, Rn, Ra, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    execute_aarch64_instrs_vector_crypto_sha3_bcax(a, d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax(Rd, Rn, Ra, Rm)
}

val execute_aarch64_instrs_branch_unconditional_dret : unit -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_branch_unconditional_dret () = {
    DRPSInstruction()
}

val decode_drps_aarch64_instrs_branch_unconditional_dret : unit -> unit effect {escape, rreg, undef, wreg}

function decode_drps_aarch64_instrs_branch_unconditional_dret () = {
    if not_bool(Halted()) | PSTATE.EL == EL0 then {
        throw(Error_Undefined())
    } else ();
    execute_aarch64_instrs_branch_unconditional_dret()
}

function clause __DecodeA64 (pc, (0b11010110101111110000001111100000 as __opcode)) = {
    decode_drps_aarch64_instrs_branch_unconditional_dret()
}

val execute_aarch64_instrs_memory_pair_simdfp_no_alloc : forall 'datasize 'n ('postindex : Bool) 't 't2 ('wback : Bool),
  (0 <= 't2 & 't2 <= 31 & 0 <= 't & 't <= 31 & 0 <= 'n & 'n <= 31 & 'datasize in {32, 64, 128, 256}).
  (AccType, int('datasize), MemOp, int('n), bits(64), bool('postindex), int('t), int('t2), bool('wback)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_memory_pair_simdfp_no_alloc (acctype, datasize, memop, n, offset, postindex, t, t2, wback) = {
    CheckFPAdvSIMDEnabled64();
    data1 : bits('datasize) = undefined;
    data2 : bits('datasize) = undefined;
    let 'dbytes = DIV(datasize, 8);
    rt_unknown : bool = false;
    if memop == MemOp_LOAD & t == t2 then {
        let c : Constraint = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
        assert(c == Constraint_UNKNOWN | c == Constraint_UNDEF | c == Constraint_NOP);
        match c {
          Constraint_UNKNOWN => {
              rt_unknown = true
          },
          Constraint_UNDEF => {
              throw(Error_Undefined())
          },
          Constraint_NOP => {
              EndOfInstruction()
          },
          _ => ()
        }
    } else ();
    base : VirtualAddress = BaseReg_read__1(n);
    address : bits(64) = VAddress(base);
    if not_bool(postindex) then {
        address = address + offset
    } else ();
    match memop {
      MemOp_STORE => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_STORE, acctype);
          assert(constraint('datasize in {8, 16, 32, 64, 128}));
          let data1 : bits('datasize) = V_read(datasize, t);
          let data2 : bits('datasize) = V_read(datasize, t2);
          Mem_set(address + 0, dbytes, acctype) = data1;
          Mem_set(address + dbytes, dbytes, acctype) = data2
      },
      MemOp_LOAD => {
          VACheckAddress(base, address, dbytes * 2, CAP_PERM_LOAD, acctype);
          assert(constraint('dbytes in {1, 2, 4, 8, 16}));
          data1 : bits('datasize) = Mem_read(address + 0, dbytes, acctype);
          data2 : bits('datasize) = Mem_read(address + dbytes, dbytes, acctype);
          if rt_unknown then {
              data1 = __UNKNOWN_bits(datasize);
              data2 = __UNKNOWN_bits(datasize)
          } else ();
          V_set(datasize, t) = data1;
          V_set(datasize, t2) = data2
      },
      _ => ()
    };
    if wback then {
        let base : VirtualAddress = VAAdd(base, offset);
        BaseReg_set(n) = base
    } else ()
}

val decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VECSTREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_no_alloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc : (bits(5), bits(5), bits(5), bits(7), bits(1), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc (Rt, Rn, Rt2, imm7, L, opc) = {
    let wback : bool = false;
    let postindex : bool = false;
    let 'n = UInt(Rn);
    let 't = UInt(Rt);
    let 't2 = UInt(Rt2);
    let acctype : AccType = AccType_VECSTREAM;
    let memop : MemOp = if L == 0b1 then MemOp_LOAD else MemOp_STORE;
    if opc == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'scale = 2 + UInt(opc);
    let 'datasize = (8 << scale);
    let offset : bits(64) = LSL(SignExtend(imm7, 64), scale);
    assert(constraint('datasize in {32, 64, 128, 256}));
    execute_aarch64_instrs_memory_pair_simdfp_no_alloc(acctype, datasize, memop, n, offset, postindex, t, t2, wback)
}

function clause __DecodeA64 (pc, ([_, _, bitone, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rt = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rt2 = Slice(__opcode, 10, 5);
    let imm7 = Slice(__opcode, 15, 7);
    let L = Slice(__opcode, 22, 1);
    let opc = Slice(__opcode, 30, 2);
    decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc(Rt, Rn, Rt2, imm7, L, opc)
}

val execute_aarch64_instrs_vector_crypto_sha512_sha512h2 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha512_sha512h2 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    Vtmp : bits(128) = undefined;
    tmp : bits(64) = undefined;
    let X : bits(128) = V_read(128, n);
    let Y : bits(128) = V_read(128, m);
    let W : bits(128) = V_read(128, d);
    NSigma0 : bits(64) = EOR(EOR(ROR(Y[63 .. 0], 28), ROR(Y[63 .. 0], 34)), ROR(Y[63 .. 0], 39));
    Vtmp[127 .. 64] = EOR(EOR(X[63 .. 0] & Y[127 .. 64], X[63 .. 0] & Y[63 .. 0]), Y[127 .. 64] & Y[63 .. 0]);
    Vtmp[127 .. 64] = Vtmp[127 .. 64] + NSigma0 + W[127 .. 64];
    let NSigma0 : bits(64) = EOR(EOR(ROR(Vtmp[127 .. 64], 28), ROR(Vtmp[127 .. 64], 34)), ROR(Vtmp[127 .. 64], 39));
    Vtmp[63 .. 0] = EOR(EOR(Vtmp[127 .. 64] & Y[63 .. 0], Vtmp[127 .. 64] & Y[127 .. 64]), Y[127 .. 64] & Y[63 .. 0]);
    Vtmp[63 .. 0] = Vtmp[63 .. 0] + NSigma0 + W[63 .. 0];
    V_set(128, d) = Vtmp
}

val decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2 (Rd, Rn, Rm) = {
    if not_bool(HaveSHA512Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha512_sha512h2(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2(Rd, Rn, Rm)
}

val execute_aarch64_instrs_vector_crypto_sha3_eor3 : forall 'a 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31 & 0 <= 'a & 'a <= 31).
  (int('a), int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3_eor3 (a, d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    let Va : bits(128) = V_read(128, a);
    V_set(128, d) = EOR(EOR(Vn, Vm), Va)
}

val decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3 : (bits(5), bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3 (Rd, Rn, Ra, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    let 'a = UInt(Ra);
    execute_aarch64_instrs_vector_crypto_sha3_eor3(a, d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, _, _, _, _, _, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Ra = Slice(__opcode, 10, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3(Rd, Rn, Ra, Rm)
}

val execute_aarch64_instrs_vector_reduce_fp16_add_sisd : forall 'd 'datasize 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {16, 32, 64} & 'datasize in {32, 64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('esize), int('n), ReduceOp) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_reduce_fp16_add_sisd (d, datasize, esize, n, op) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('datasize) = V_read(datasize, n);
    assert(constraint('datasize >= 'esize));
    V_set(esize, d) = Reduce(op, operand, esize)
}

val decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd (Rd, Rn, sz) = {
    if not_bool(HaveFP16Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = 16;
    if sz == 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = ReduceOp_FADD;
    execute_aarch64_instrs_vector_reduce_fp16_add_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd(Rd, Rn, sz)
}

val decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd : (bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd (Rd, Rn, sz) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'esize = (32 << UInt(sz));
    let 'datasize = esize * 2;
    let 'elements = 2;
    let op : ReduceOp = ReduceOp_FADD;
    execute_aarch64_instrs_vector_reduce_fp16_add_sisd(d, datasize, esize, n, op)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, bitzero, _, bitone, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitone, bitzero, bitone, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let sz = Slice(__opcode, 22, 1);
    decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd(Rd, Rn, sz)
}

val execute_aarch64_instrs_vector_shift_right_insert_sisd : forall 'd 'datasize 'elements 'esize 'n 'shift,
  (0 <= 'n & 'n <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('shift)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_shift_right_insert_sisd (d, datasize, elements, esize, n, shift) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('datasize in {8, 16, 32, 64, 128}));
    let operand : bits('datasize) = V_read(datasize, n);
    let operand2 : bits('datasize) = V_read(datasize, d);
    result : bits('datasize) = undefined;
    assert(constraint('esize >= 0));
    let mask : bits('esize) = LSR(Ones(esize), shift);
    shifted : bits('esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        assert(constraint((0 <= 'loop_e * 'esize & 'loop_e * 'esize <= 'loop_e * 'esize + 'esize - 1 | not(('loop_e >= 0 & ('loop_e + 1) * 'esize <= 'datasize)) | not('esize >= 0) | not('datasize in {8, 16, 32, 64, 128}))));
        shifted = LSR(Elem_read(operand, e, esize), shift);
        result = Elem_set(result, e, esize, Elem_read(operand2, e, esize) & not_vec(mask) | shifted)
    };
    V_set(datasize, d) = result
}

val decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd : (bits(5), bits(5), bits(3), bits(4)) -> unit effect {escape, rreg, undef, wreg}

function decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd (Rd, Rn, immb, immh) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if [immh[3]] != 0b1 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << 3);
    let 'datasize = esize;
    let 'elements = 1;
    let 'shift = esize * 2 - UInt(immh @ immb);
    execute_aarch64_instrs_vector_shift_right_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64 (pc, ([bitzero, bitone, bitone, bitone, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd(Rd, Rn, immb, immh)
}

val decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd : (bits(5), bits(5), bits(3), bits(4), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd (Rd, Rn, immb, immh, Q) = {
    assert(immh != 0b0000);
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if immh == 0b0000 then {
        throw(Error_See("asimdimm"))
    } else ();
    if ([immh[3]] @ Q) == 0b10 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << HighestSetBit(immh));
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    let 'shift = esize * 2 - UInt(immh @ immb);
    execute_aarch64_instrs_vector_shift_right_insert_sisd(d, datasize, elements, esize, n, shift)
}

function clause __DecodeA64 ((pc, ([bitzero, _, bitone, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, _, _, _, _, _, bitzero, bitone, bitzero, bitzero, bitzero, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) if Slice(__opcode, 19, 4) != 0b0000) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let immb = Slice(__opcode, 16, 3);
    let immh = Slice(__opcode, 19, 4);
    let Q = Slice(__opcode, 30, 1);
    decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd(Rd, Rn, immb, immh, Q)
}

val execute_aarch64_instrs_vector_transfer_integer_dup : forall 'd 'datasize 'elements 'esize 'n,
  (0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64, 128, 256} & 'datasize in {64, 128} & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_transfer_integer_dup (d, datasize, elements, esize, n) = {
    CheckFPAdvSIMDEnabled64();
    assert(constraint('esize in {8, 16, 32, 64}));
    let element : bits('esize) = X_read(esize, n);
    result : bits('datasize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        result = Elem_set(result, e, esize, element)
    };
    V_set(datasize, d) = result
}

val decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup : (bits(5), bits(5), bits(5), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup (Rd, Rn, imm5, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'size = LowestSetBit(imm5);
    if size > 3 then {
        throw(Error_Undefined())
    } else ();
    if size == 3 & Q == 0b0 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << size);
    let 'datasize = if Q == 0b1 then 128 else 64;
    let 'elements = DIV(datasize, esize);
    assert(constraint('esize in {8, 16, 32, 64, 128, 256}));
    execute_aarch64_instrs_vector_transfer_integer_dup(d, datasize, elements, esize, n)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, bitzero, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let imm5 = Slice(__opcode, 16, 5);
    let Q = Slice(__opcode, 30, 1);
    decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup(Rd, Rn, imm5, Q)
}

val execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat : forall 'd 'datasize 'elements 'esize 'n 'part,
  ('part in {0, 1} & 0 <= 'n & 'n <= 31 & 'esize in {8, 16, 32, 64} & 'datasize == 64 & 0 <= 'd & 'd <= 31).
  (int('d), int('datasize), int('elements), int('esize), int('n), int('part)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat (d, datasize, elements, esize, n, part) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits(2 * 'datasize) = V_read(2 * datasize, n);
    result : bits('datasize) = undefined;
    element : bits(2 * 'esize) = undefined;
    foreach (e from 0 to (elements - 1) by 1 in inc) {
        element = Elem_read(operand, e, 2 * esize);
        result = Elem_set(result, e, esize, element[esize - 1 .. 0])
    };
    Vpart_set(datasize, d, part) = result
}

val decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat : (bits(5), bits(5), bits(2), bits(1)) -> unit effect {escape, rreg, undef, wreg}

function decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat (Rd, Rn, size, Q) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    if size == 0b11 then {
        throw(Error_Undefined())
    } else ();
    let 'esize = (8 << UInt(size));
    let 'datasize = 64;
    let 'part = UInt(Q);
    let 'elements = DIV(datasize, esize);
    execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat(d, datasize, elements, esize, n, part)
}

function clause __DecodeA64 (pc, ([bitzero, _, bitzero, bitzero, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitzero, bitone, bitzero, bitzero, bitone, bitzero, bitone, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let size = Slice(__opcode, 22, 2);
    let Q = Slice(__opcode, 30, 1);
    decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat(Rd, Rn, size, Q)
}

val execute_aarch64_instrs_vector_crypto_sha3_rax1 : forall 'd 'm 'n,
  (0 <= 'n & 'n <= 31 & 0 <= 'm & 'm <= 31 & 0 <= 'd & 'd <= 31).
  (int('d), int('m), int('n)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_vector_crypto_sha3_rax1 (d, m, n) = {
    AArch64_CheckFPAdvSIMDEnabled();
    let Vm : bits(128) = V_read(128, m);
    let Vn : bits(128) = V_read(128, n);
    V_set(128, d) = EOR(Vn, ROL(Vm[127 .. 64], 1) @ ROL(Vm[63 .. 0], 1))
}

val decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1 : (bits(5), bits(5), bits(5)) -> unit effect {escape, rreg, undef, wreg}

function decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1 (Rd, Rn, Rm) = {
    if not_bool(HaveSHA3Ext()) then {
        throw(Error_Undefined())
    } else ();
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    let 'm = UInt(Rm);
    execute_aarch64_instrs_vector_crypto_sha3_rax1(d, m, n)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitzero, bitone, bitone, bitone, bitzero, bitzero, bitone, bitone, _, _, _, _, _, bitone, bitzero, bitzero, bitzero, bitone, bitone, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let Rm = Slice(__opcode, 16, 5);
    decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1(Rd, Rn, Rm)
}

val execute_aarch64_instrs_system_register_cpsr : (PSTATEField, bits(4)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_system_register_cpsr (field, operand) = {
    match field {
      PSTATEField_SSBS => {
          PSTATE.SSBS = [operand[0]]
      },
      PSTATEField_SP => {
          if not_bool(IsInRestricted()) then {
              PSTATE.SP = [operand[0]]
          } else ()
      },
      PSTATEField_DAIFSet => {
          PSTATE.D = PSTATE.D | [operand[3]];
          PSTATE.A = PSTATE.A | [operand[2]];
          PSTATE.I = PSTATE.I | [operand[1]];
          PSTATE.F = PSTATE.F | [operand[0]]
      },
      PSTATEField_DAIFClr => {
          PSTATE.D = PSTATE.D & not_vec([operand[3]]);
          PSTATE.A = PSTATE.A & not_vec([operand[2]]);
          PSTATE.I = PSTATE.I & not_vec([operand[1]]);
          PSTATE.F = PSTATE.F & not_vec([operand[0]])
      },
      PSTATEField_PAN => {
          PSTATE.PAN = [operand[0]]
      },
      PSTATEField_UAO => {
          PSTATE.UAO = [operand[0]]
      }
    }
}

val decode_msr_imm_aarch64_instrs_system_register_cpsr : (bits(3), bits(4), bits(3)) -> unit effect {escape, rreg, undef, wreg}

function decode_msr_imm_aarch64_instrs_system_register_cpsr (op2, CRm, op1) = {
    AArch64_CheckSystemAccess(0b00, op1, 0b0100, CRm, op2, 0b11111, 0b0);
    let operand : bits(4) = CRm;
    field : PSTATEField = undefined;
    match op1 @ op2 {
      0b000011 => {
          if not_bool(HaveUAOExt()) then {
              throw(Error_Undefined())
          } else ();
          field = PSTATEField_UAO
      },
      0b000100 => {
          if not_bool(HavePANExt()) then {
              throw(Error_Undefined())
          } else ();
          field = PSTATEField_PAN
      },
      0b000101 => {
          field = PSTATEField_SP
      },
      0b011110 => {
          field = PSTATEField_DAIFSet
      },
      0b011111 => {
          field = PSTATEField_DAIFClr
      },
      0b011001 => {
          if not_bool(HaveSSBSExt()) then {
              throw(Error_Undefined())
          } else ();
          field = PSTATEField_SSBS
      },
      _ => {
          throw(Error_Undefined())
      }
    };
    let field = field;
    if PSTATE.EL == EL0 & (field == PSTATEField_DAIFSet | field == PSTATEField_DAIFClr) then {
        if not_bool(ELUsingAArch32(EL1)) & (EL2Enabled() & (Slice(HCR_EL2, 34, 1) @ Slice(HCR_EL2, 27, 1)) == 0b11 | Slice(SCTLR_EL1, 9, 1) == 0b0) then {
            if (EL2Enabled() & not_bool(ELUsingAArch32(EL2))) & Slice(HCR_EL2, 27, 1) == 0b1 then {
                AArch64_SystemAccessTrap(EL2, UInt(0x18))
            } else {
                AArch64_SystemAccessTrap(EL1, UInt(0x18))
            }
        } else ()
    } else ();
    execute_aarch64_instrs_system_register_cpsr(field, operand)
}

function clause __DecodeA64 (pc, ([bitone, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitone, bitzero, bitzero, bitzero, bitzero, bitzero, _, _, _, bitzero, bitone, bitzero, bitzero, _, _, _, _, _, _, _, bitone, bitone, bitone, bitone, bitone] as __opcode)) = {
    let op2 = Slice(__opcode, 5, 3);
    let CRm = Slice(__opcode, 8, 4);
    let op1 = Slice(__opcode, 16, 3);
    decode_msr_imm_aarch64_instrs_system_register_cpsr(op2, CRm, op1)
}

val execute_aarch64_instrs_float_convert_fp : forall 'd 'dstsize 'n 'srcsize,
  ('srcsize in {16, 32, 64} & 0 <= 'n & 'n <= 31 & 'dstsize in {16, 32, 64} & 0 <= 'd & 'd <= 31).
  (int('d), int('dstsize), int('n), int('srcsize)) -> unit effect {escape, rreg, undef, wreg}

function execute_aarch64_instrs_float_convert_fp (d, dstsize, n, srcsize) = {
    CheckFPAdvSIMDEnabled64();
    let operand : bits('srcsize) = V_read(srcsize, n);
    let result : bits('dstsize) = FPConvert__1(dstsize, operand, FPCR);
    V_set(dstsize, d) = result
}

val decode_fcvt_float_aarch64_instrs_float_convert_fp : (bits(5), bits(5), bits(2), bits(2)) -> unit effect {escape, rreg, undef, wreg}

function decode_fcvt_float_aarch64_instrs_float_convert_fp (Rd, Rn, opc, ftype) = {
    let 'd = UInt(Rd);
    let 'n = UInt(Rn);
    srcsize : {|16, 32, 64|} = 16;
    dstsize : {|16, 32, 64|} = 16;
    if ftype == opc then {
        throw(Error_Undefined())
    } else ();
    match ftype {
      0b00 => {
          srcsize = 32
      },
      0b01 => {
          srcsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          srcsize = 16
      }
    };
    let 'srcsize = srcsize;
    match opc {
      0b00 => {
          dstsize = 32
      },
      0b01 => {
          dstsize = 64
      },
      0b10 => {
          throw(Error_Undefined())
      },
      0b11 => {
          dstsize = 16
      }
    };
    let 'dstsize = dstsize;
    execute_aarch64_instrs_float_convert_fp(d, dstsize, n, srcsize)
}

function clause __DecodeA64 (pc, ([bitzero, bitzero, bitzero, bitone, bitone, bitone, bitone, bitzero, _, _, bitone, bitzero, bitzero, bitzero, bitone, _, _, bitone, bitzero, bitzero, bitzero, bitzero, _, _, _, _, _, _, _, _, _, _] as __opcode)) = {
    let Rd = Slice(__opcode, 0, 5);
    let Rn = Slice(__opcode, 5, 5);
    let opc = Slice(__opcode, 15, 2);
    let ftype = Slice(__opcode, 22, 2);
    decode_fcvt_float_aarch64_instrs_float_convert_fp(Rd, Rn, opc, ftype)
}
